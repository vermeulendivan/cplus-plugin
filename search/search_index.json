{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CPLUS QGIS plugin Introduction The challenge of mitigating climate change and achieving global and national climate targets requires innovative and holistic approaches. In this pursuit, the Climate Positive Land Use Strategy (CPLUS) decision support tool has emerged as a crucial resource. CPLUS is a spatially-explicit roadmap designed to guide land-use planning strategies, utilizing natural climate solutions to drive meaningful and sustainable change. The CPLUS decision support tool combines open-source technology, localized data sets, and modelled products to empower policymakers, land managers, and stakeholders in making informed decisions. By integrating spatial information, such as land cover, carbon stocks, and potential for carbon sequestration, CPLUS enables the identification of key areas for intervention and investment. By prioritizing these nature-based interventions, CPLUS seeks to harness the power of ecosystems and optimize their climate mitigation potential. One of the distinguishing features of CPLUS is its ability to address both global and national climate targets. While global climate targets provide a broad framework for action, national targets require context-specific strategies tailored to the unique characteristics of each country. The CPLUS decision support tool considers these diverse factors and assists in designing land-use planning strategies that align with national commitments while contributing to global climate goals. Furthermore, CPLUS recognizes that effective land-use planning involves collaboration and engagement among various stakeholders. It fosters dialogue and cooperation between governments, local communities, indigenous groups, conservation organizations, and private entities, facilitating the development of inclusive and equitable solutions. By involving diverse perspectives and expertise, CPLUS ensures that the decision-making process is participatory and informed by local knowledge. Piloted in the Bushbuckridge Municipality in the Kruger to Canyons Biosphere of South Africa, the CPLUS framework was tested with a diverse set of stakeholders to identify land use priorities and understand the carbon benefits and biodiversity, ecosystem services co-benefits of different scenarios. CPLUS model Implementation models Figure 1 shows a flow diagram of the CPLUS analysis model. Figure 1: Simplified analysis model Algorithms Shown in Figure 2 is the algorithms applied by the CPLUS model analysis model. Figure 2: CPLUS simplified analysis workflow with algorithms References https://www.pnas.org/doi/10.1073/pnas.1710465114 https://royalsocietypublishing.org/doi/10.1098/rstb.2019.0126 Site contents The aim of this is site is to provide details on the models and algorithms used by the CPLUS plugin, help a user on using the plugin, guide administrators on testings and providing feedback for the plugin, and provide guidance to developers who want to contribute to the plugin. Here is a quick introduction on the sections on the site: Users : Help for users of the plugin Quick Start : Installation guide and how to get started with the plugin Guide : Detailed workflow on how to use the plugin Manual : Descriptions of each UI element Administrators : Help for an administrator of the plugin Guide : Detailed guide for administrative requirements Repository : Downloadable versions of the plugin Developers : People who want to contribute towards improving the plugin Setup : How to set up the developers environment for the plugin Architecture : Documentation : Help on adding towards the API documentation for a developer API : Application programming interface for the plugin About : Information on CI and other contributors to the plugin","title":"Home"},{"location":"#cplus-qgis-plugin","text":"","title":"CPLUS QGIS plugin"},{"location":"#introduction","text":"The challenge of mitigating climate change and achieving global and national climate targets requires innovative and holistic approaches. In this pursuit, the Climate Positive Land Use Strategy (CPLUS) decision support tool has emerged as a crucial resource. CPLUS is a spatially-explicit roadmap designed to guide land-use planning strategies, utilizing natural climate solutions to drive meaningful and sustainable change. The CPLUS decision support tool combines open-source technology, localized data sets, and modelled products to empower policymakers, land managers, and stakeholders in making informed decisions. By integrating spatial information, such as land cover, carbon stocks, and potential for carbon sequestration, CPLUS enables the identification of key areas for intervention and investment. By prioritizing these nature-based interventions, CPLUS seeks to harness the power of ecosystems and optimize their climate mitigation potential. One of the distinguishing features of CPLUS is its ability to address both global and national climate targets. While global climate targets provide a broad framework for action, national targets require context-specific strategies tailored to the unique characteristics of each country. The CPLUS decision support tool considers these diverse factors and assists in designing land-use planning strategies that align with national commitments while contributing to global climate goals. Furthermore, CPLUS recognizes that effective land-use planning involves collaboration and engagement among various stakeholders. It fosters dialogue and cooperation between governments, local communities, indigenous groups, conservation organizations, and private entities, facilitating the development of inclusive and equitable solutions. By involving diverse perspectives and expertise, CPLUS ensures that the decision-making process is participatory and informed by local knowledge. Piloted in the Bushbuckridge Municipality in the Kruger to Canyons Biosphere of South Africa, the CPLUS framework was tested with a diverse set of stakeholders to identify land use priorities and understand the carbon benefits and biodiversity, ecosystem services co-benefits of different scenarios.","title":"Introduction"},{"location":"#cplus-model","text":"","title":"CPLUS model"},{"location":"#implementation-models","text":"Figure 1 shows a flow diagram of the CPLUS analysis model. Figure 1: Simplified analysis model","title":"Implementation models"},{"location":"#algorithms","text":"Shown in Figure 2 is the algorithms applied by the CPLUS model analysis model. Figure 2: CPLUS simplified analysis workflow with algorithms","title":"Algorithms"},{"location":"#references","text":"https://www.pnas.org/doi/10.1073/pnas.1710465114 https://royalsocietypublishing.org/doi/10.1098/rstb.2019.0126","title":"References"},{"location":"#site-contents","text":"The aim of this is site is to provide details on the models and algorithms used by the CPLUS plugin, help a user on using the plugin, guide administrators on testings and providing feedback for the plugin, and provide guidance to developers who want to contribute to the plugin. Here is a quick introduction on the sections on the site: Users : Help for users of the plugin Quick Start : Installation guide and how to get started with the plugin Guide : Detailed workflow on how to use the plugin Manual : Descriptions of each UI element Administrators : Help for an administrator of the plugin Guide : Detailed guide for administrative requirements Repository : Downloadable versions of the plugin Developers : People who want to contribute towards improving the plugin Setup : How to set up the developers environment for the plugin Architecture : Documentation : Help on adding towards the API documentation for a developer API : Application programming interface for the plugin About : Information on CI and other contributors to the plugin","title":"Site contents"},{"location":"about/ci/","text":"Conservation International Through the help of community leaders and policymakers, the mission of Conservation International (CI) is to combat climate change and preserve carbon stores. CI and the Climate Positive Land Use Strategy (CPLUS) project need the ability to spatially analyze a given area to determine the best land use in order to naturally combat climate change and the effects thereof on a global scale. Further, reports need to be generated to communicate to stakeholders the importance of conserving and maintaining certain areas and the need to restore lost climate-positive environments. Thus, mitigating the negative effects of climate change produced by our daily activities. The aim is to ensure a better future for everyone.","title":"Conservation International"},{"location":"about/ci/#conservation-international","text":"Through the help of community leaders and policymakers, the mission of Conservation International (CI) is to combat climate change and preserve carbon stores. CI and the Climate Positive Land Use Strategy (CPLUS) project need the ability to spatially analyze a given area to determine the best land use in order to naturally combat climate change and the effects thereof on a global scale. Further, reports need to be generated to communicate to stakeholders the importance of conserving and maintaining certain areas and the need to restore lost climate-positive environments. Thus, mitigating the negative effects of climate change produced by our daily activities. The aim is to ensure a better future for everyone.","title":"Conservation International"},{"location":"about/kartoza/","text":"Kartoza Kartoza will make geospatial data and technology work for you by partnering with us for training, development and maintenance of GIS systems. Kartoza is a South Africa-based Free and Open Source GIS (FOSSGIS) service provider. We use GIS software to solve complex location-related problems for individuals, businesses and governments around the world. Our team develops software using FOSSGIS to give you the freedom to share and modify your GIS as your needs grow and change.","title":"Kartoza"},{"location":"about/kartoza/#kartoza","text":"Kartoza will make geospatial data and technology work for you by partnering with us for training, development and maintenance of GIS systems. Kartoza is a South Africa-based Free and Open Source GIS (FOSSGIS) service provider. We use GIS software to solve complex location-related problems for individuals, businesses and governments around the world. Our team develops software using FOSSGIS to give you the freedom to share and modify your GIS as your needs grow and change.","title":"Kartoza"},{"location":"about/license/","text":"License","title":"License"},{"location":"about/license/#license","text":"","title":"License"},{"location":"administrator/","text":"Administrators This section is for administrators of the plugin: The guide details how to create new tasks, and how to download and install a staging version of the plugin. The repository provides access to different versions of the plugin. This includes version based on specific pull requests.","title":"Administrators"},{"location":"administrator/#administrators","text":"This section is for administrators of the plugin: The guide details how to create new tasks, and how to download and install a staging version of the plugin. The repository provides access to different versions of the plugin. This includes version based on specific pull requests.","title":"Administrators"},{"location":"administrator/guide/","text":"Administrators guide Bugs and suggestions This section relates to creating an issue for when a bug is found in the plugin, or if the user has a suggested improvement for the plugin. Go to the CPLUS repository Click on the Issues tab Click on New Issue (see Figure 1 ) Title: Short, but descriptive Description: Detailed description. If it's a bug, an explanation on how to replicate the bug will be best. Screenshots of the bug or suggestion will also be helpful Figure 1: An example of a new GitHub issue Select a Label (e.g. bug, enhancement, etc.) as shown in Figure 2 Figure 2: Selecting a label for an issue Select the CPLUS Project ( Figure 3 ). This will add the issue/task to the project board Figure 3: Selecting a Project for an issue The end result should be similar to Figure 4 . Figure 4: An example of a finalized issue Click Submit new issue The issue will now be submitted to the GitHub repository and be available to the developers. Staging version of the plugin When a pull requested is performed, an automatic staging version is created. This will allow a developer to test their changes to the plugin with other changes which has not been merged into the main branch. Another advantage of this approach is to show the client to progress of the plugin. Get the staging version Go to the repository: https://github.com/kartoza/cplus-plugin To the right there is a section named Releases Click on Latest release Download the cplus_plugin .zip file if you want to install the plugin in QGIS Developers will likely be interested in Source code (zip) and Source code (tar.gz) options See user/installation on how to install a QGIS plugin If you want to have a look at past versions of the plugin: On the repository page, click on Releases A list of option will appear Choose the version you are interested in, and follow the steps discussed above","title":"Guide"},{"location":"administrator/guide/#administrators-guide","text":"","title":"Administrators guide"},{"location":"administrator/guide/#bugs-and-suggestions","text":"This section relates to creating an issue for when a bug is found in the plugin, or if the user has a suggested improvement for the plugin. Go to the CPLUS repository Click on the Issues tab Click on New Issue (see Figure 1 ) Title: Short, but descriptive Description: Detailed description. If it's a bug, an explanation on how to replicate the bug will be best. Screenshots of the bug or suggestion will also be helpful Figure 1: An example of a new GitHub issue Select a Label (e.g. bug, enhancement, etc.) as shown in Figure 2 Figure 2: Selecting a label for an issue Select the CPLUS Project ( Figure 3 ). This will add the issue/task to the project board Figure 3: Selecting a Project for an issue The end result should be similar to Figure 4 . Figure 4: An example of a finalized issue Click Submit new issue The issue will now be submitted to the GitHub repository and be available to the developers.","title":"Bugs and suggestions"},{"location":"administrator/guide/#staging-version-of-the-plugin","text":"When a pull requested is performed, an automatic staging version is created. This will allow a developer to test their changes to the plugin with other changes which has not been merged into the main branch. Another advantage of this approach is to show the client to progress of the plugin.","title":"Staging version of the plugin"},{"location":"administrator/guide/#get-the-staging-version","text":"Go to the repository: https://github.com/kartoza/cplus-plugin To the right there is a section named Releases Click on Latest release Download the cplus_plugin .zip file if you want to install the plugin in QGIS Developers will likely be interested in Source code (zip) and Source code (tar.gz) options See user/installation on how to install a QGIS plugin If you want to have a look at past versions of the plugin: On the repository page, click on Releases A list of option will appear Choose the version you are interested in, and follow the steps discussed above","title":"Get the staging version"},{"location":"administrator/repository/","text":"Pull requests artifacts PR title PR url Artifact name Artifact link Created date Main branch artifacts Commit link Artifact name Artifact link Created date import { Octokit, App } from \"https://esm.sh/octokit\"; const octokit = new Octokit(); const pulls = await octokit.request( \"GET /repos/kartoza/cplus-plugin/pulls\", {'state':'all'} ); const fetched_artifacts = await octokit.request( \"GET /repos/kartoza/cplus-plugin/actions/artifacts\", {'per_page': 30} ); const pulls_artifacts = []; const commits_artifacts = []; const artifacts_comments = []; for ( const pull of pulls.data ){ const head_sha = pull['head']['sha']; const pull_artifact = {}; const artifact_comments = []; if (pull == undefined) continue; for ( const artifact of fetched_artifacts.data.artifacts){ if ( artifact['workflow_run']['head_sha'] == head_sha && artifact['name'].indexOf('cplus_plugin') != -1 ){ pull_artifact['pull'] = pull; pull_artifact['artifact'] = artifact; artifact_comments['artifact'] = artifact; artifact_comments['comments'] = pull['comments_url']; } } pulls_artifacts.push(pull_artifact); artifacts_comments.push(artifact_comments); } for ( const artifact of fetched_artifacts.data.artifacts){ if ( artifact['name'].indexOf('cplus_plugin') == -1){ continue; } const commit = await octokit.request( \"GET /repos/kartoza/cplus-plugin/commits/\"+ artifact['workflow_run']['head_sha'] ); if ( commit == undefined | commit.data.parents.length < 2 ){ continue; } const commit_artifact = { 'commit': commit, 'artifact': artifact }; commits_artifacts.push(commit_artifact); } const pulls_tbody = document.getElementById('pulls_tbody'); const main_tbody = document.getElementById('main_tbody'); for (const pull_artifact of pulls_artifacts){ if (pull_artifact['pull'] == undefined) { continue; } const tr = document.createElement('tr'); const first_td = document.createElement('td'); const second_td = document.createElement('td'); const third_td = document.createElement('td'); const fourth_td = document.createElement('td'); const fifth_td = document.createElement('td'); const pull_link = document.createElement(\"a\"); const link_node = document.createTextNode( pull_artifact['pull']['title'] ); pull_link.appendChild(link_node); pull_link.textContent = pull_artifact['pull']['html_url']; pull_link.title = pull_artifact['pull']['html_url']; pull_link.href = pull_artifact['pull']['html_url']; first_td.appendChild(link_node); second_td.appendChild(pull_link); tr.appendChild(first_td); tr.appendChild(second_td); const artifact_link = document.createElement(\"a\"); const second_link_node = document.createTextNode( pull_artifact['artifact']['name'] ); const date_node = document.createTextNode( pull_artifact['artifact']['created_at'] ); artifact_link.appendChild(second_link_node); artifact_link.textContent = pull_artifact['artifact']['archive_download_url']; artifact_link.href = pull_artifact['artifact']['archive_download_url']; artifact_link.id = pull_artifact['artifact']['name']; third_td.appendChild(second_link_node); fourth_td.appendChild(artifact_link); fifth_td.appendChild(date_node); tr.appendChild(third_td); tr.appendChild(fourth_td); tr.appendChild(fifth_td); pulls_tbody.appendChild(tr) } for( const artifact_comment of artifacts_comments){ if (artifact_comment['comments'] === undefined) continue; const comments = await fetch(artifact_comment['comments']); const result = comments.json().then(function(results){ for(const comment of results){ if (comment.body.indexOf(\"Download the plugin zip file here\") != -1){ const artifact_link_regex = /(https?:\\/\\/[^ ]*)/; const matches = comment.body.match(artifact_link_regex); const art_link = matches[0]; const artifact_name = artifact_comment['artifact']['name']; const artifact_url = art_link.split(\"\\n\")[0]; const pull_artifact = document.getElementById(artifact_name); if( pull_artifact == undefined){ continue; } pull_artifact.textContent = artifact_url; pull_artifact.href = artifact_url; } } }) } for (const commit_artifact of commits_artifacts){ if (commit_artifact['commit'] === undefined) continue; const tr = document.createElement('tr'); const first_td = document.createElement('td'); const second_td = document.createElement('td'); const third_td = document.createElement('td'); const fourth_td = document.createElement('td'); const fifth_td = document.createElement('td'); const pull_link = document.createElement(\"a\"); const link_node = document.createTextNode( commit_artifact['commit']['data']['sha'] ); pull_link.appendChild(link_node); pull_link.textContent = commit_artifact['commit']['data']['html_url']; pull_link.title = commit_artifact['commit']['data']['html_url']; pull_link.href = commit_artifact['commit']['data']['html_url']; first_td.appendChild(link_node); second_td.appendChild(pull_link); tr.appendChild(second_td); const artifact_link = document.createElement(\"a\"); const second_link_node = document.createTextNode( commit_artifact['artifact']['name'] ); const date_node = document.createTextNode( commit_artifact['artifact']['created_at'] ); artifact_link.appendChild(second_link_node); artifact_link.textContent = commit_artifact['artifact']['archive_download_url']; artifact_link.href = commit_artifact['artifact']['archive_download_url']; third_td.appendChild(second_link_node); artifact_link.id = commit_artifact['artifact']['name']; fourth_td.appendChild(artifact_link); fifth_td.appendChild(date_node); tr.appendChild(third_td); tr.appendChild(fourth_td); tr.appendChild(fifth_td); main_tbody.appendChild(tr) } const response = await fetch( \"https://raw.githubusercontent.com/kartoza/cplus-plugin/docs/docs/admin/artifacts_list.txt\" ); const file_text_promise = response.text(); const res = file_text_promise.then(function(result){ const art_list = result.split(\"\\n\"); for( const art of art_list){ if( art === \"\"){ continue; } const parts = art.split(\" - \"); const artifact_name = parts[0].trim(); const artifact_url = parts[1].trim(); const main_artifact = document.getElementById(artifact_name); if( main_artifact == undefined){ continue; } main_artifact.textContent = artifact_url; main_artifact.href = artifact_url; } const loading_div = document.getElementById('loading_div'); loading_div.remove(); });","title":"Repository"},{"location":"developer/","text":"Developers Section which aims at guiding developers of the plugin: Setup details how to set up a developers environment of the plugin. Developers documentation details how a developer should document changes to the code. Architecture of the plugin","title":"Developers"},{"location":"developer/#developers","text":"Section which aims at guiding developers of the plugin: Setup details how to set up a developers environment of the plugin. Developers documentation details how a developer should document changes to the code. Architecture of the plugin","title":"Developers"},{"location":"developer/api/core/api_conf/","text":"Configuration Handles storage and retrieval of the plugin QgsSettings. ScenarioSettings dataclass Bases: Scenario Plugin Scenario settings. from_qgs_settings classmethod from_qgs_settings ( identifier , settings ) Reads QGIS settings and parses them into a scenario settings instance with the respective settings values as properties. Parameters: Name Type Description Default identifier str Scenario identifier required settings QgsSettings Scenario identifier required Returns: Type Description ScenarioSettings Scenario settings object Source code in src/cplus_plugin/conf.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 @classmethod def from_qgs_settings ( cls , identifier : str , settings : QgsSettings ): \"\"\"Reads QGIS settings and parses them into a scenario settings instance with the respective settings values as properties. :param identifier: Scenario identifier :type identifier: str :param settings: Scenario identifier :type settings: QgsSettings :returns: Scenario settings object :rtype: ScenarioSettings \"\"\" return cls ( uuid = uuid . UUID ( identifier ), name = settings . value ( \"name\" , None ), description = settings . value ( \"description\" , None ), ) get_scenario_extent classmethod get_scenario_extent () Fetches Scenario extent from the passed scenario settings. Returns: Type Description SpatialExtent Spatial extent instance extent Source code in src/cplus_plugin/conf.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 @classmethod def get_scenario_extent ( cls ): \"\"\"Fetches Scenario extent from the passed scenario settings. :returns: Spatial extent instance extent :rtype: SpatialExtent \"\"\" spatial_key = \"extent/spatial\" with qgis_settings ( spatial_key , cls ) as settings : bbox = settings . value ( \"bbox\" , None ) spatial_extent = SpatialExtent ( bbox = bbox ) return spatial_extent Settings Bases: Enum Plugin settings names SettingsManager Bases: QObject Manages saving/loading settings for the plugin in QgsSettings. delete_all_scenarios delete_all_scenarios () Deletes all the plugin scenarios settings. Source code in src/cplus_plugin/conf.py 327 328 329 330 331 332 333 def delete_all_scenarios ( self ): \"\"\"Deletes all the plugin scenarios settings.\"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . SCENARIO_GROUP_NAME } \" ) as settings : for scenario_name in settings . childGroups (): settings . remove ( scenario_name ) delete_priority_groups delete_priority_groups () Deletes all the plugin priority groups settings. Source code in src/cplus_plugin/conf.py 624 625 626 627 628 629 630 def delete_priority_groups ( self ): \"\"\"Deletes all the plugin priority groups settings.\"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_GROUP_NAME } \" ) as settings : for priority_group in settings . childGroups (): settings . remove ( priority_group ) delete_priority_layer delete_priority_layer ( identifier ) Removes priority layer that match the passed identifier Parameters: Name Type Description Default identifier str Priority layer identifier required Source code in src/cplus_plugin/conf.py 522 523 524 525 526 527 528 529 530 531 532 533 def delete_priority_layer ( self , identifier ): \"\"\"Removes priority layer that match the passed identifier :param identifier: Priority layer identifier :type identifier: str \"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_LAYERS_GROUP_NAME } /\" ) as settings : for priority_layer in settings . childGroups (): if str ( priority_layer ) == str ( identifier ): settings . remove ( priority_layer ) delete_priority_layers delete_priority_layers () Deletes all the plugin priority settings. Source code in src/cplus_plugin/conf.py 514 515 516 517 518 519 520 def delete_priority_layers ( self ): \"\"\"Deletes all the plugin priority settings.\"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_LAYERS_GROUP_NAME } \" ) as settings : for priority_layer in settings . childGroups (): settings . remove ( priority_layer ) delete_settings delete_settings () Deletes the all the plugin settings. Source code in src/cplus_plugin/conf.py 210 211 212 def delete_settings ( self ): \"\"\"Deletes the all the plugin settings.\"\"\" self . settings . remove ( f \" { self . BASE_GROUP_NAME } \" ) find_group_by_name find_group_by_name ( name ) Finds a priority group setting inside the plugin QgsSettings by name. Parameters: Name Type Description Default name str Name of the group required Returns: Type Description typing.Dict Priority group Source code in src/cplus_plugin/conf.py 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 def find_group_by_name ( self , name ) -> typing . Dict : \"\"\"Finds a priority group setting inside the plugin QgsSettings by name. :param name: Name of the group :type name: str :returns: Priority group :rtype: typing.Dict \"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_GROUP_NAME } \" ) as settings : for group_id in settings . childGroups (): group_settings_key = self . _get_priority_groups_settings_base ( group_id ) with qgis_settings ( group_settings_key ) as group_settings_key : group_name = group_settings_key . value ( \"name\" ) if group_name == name : found_id = uuid . UUID ( group_id ) break return self . get_priority_group ( found_id ) find_layer_by_name find_layer_by_name ( name ) Finds a priority layer setting inside the plugin QgsSettings by name. Parameters: Name Type Description Default name str Priority layers identifier required Returns: Type Description dict Priority layers dict Source code in src/cplus_plugin/conf.py 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 def find_layer_by_name ( self , name ) -> typing . Dict : \"\"\"Finds a priority layer setting inside the plugin QgsSettings by name. :param name: Priority layers identifier :type name: str :returns: Priority layers dict :rtype: dict \"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_LAYERS_GROUP_NAME } \" ) as settings : for layer_id in settings . childGroups (): layer_settings_key = self . _get_priority_layers_settings_base ( layer_id ) with qgis_settings ( layer_settings_key ) as layer_settings : layer_name = layer_settings . value ( \"name\" ) if layer_name == name : found_id = uuid . UUID ( layer_id ) break return self . get_priority_layer ( found_id ) find_layers_by_group find_layers_by_group ( group ) Finds priority layers inside the plugin QgsSettings that contain the passed group. Parameters: Name Type Description Default group str Priority group name required Returns: Type Description list Priority layers list Source code in src/cplus_plugin/conf.py 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 def find_layers_by_group ( self , group ) -> typing . List : \"\"\"Finds priority layers inside the plugin QgsSettings that contain the passed group. :param group: Priority group name :type group: str :returns: Priority layers list :rtype: list \"\"\" layers = [] with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_LAYERS_GROUP_NAME } \" ) as settings : for layer_id in settings . childGroups (): priority_layer_settings = self . _get_priority_layers_settings_base ( layer_id ) with qgis_settings ( priority_layer_settings ) as priority_settings : groups_key = f \" { priority_layer_settings } /groups\" with qgis_settings ( groups_key ) as groups_settings : for name in groups_settings . childGroups (): group_settings_key = f \" { groups_key } / { name } \" with qgis_settings ( group_settings_key ) as group_settings : if group == group_settings . value ( \"name\" ): layers . append ( self . get_priority_layer ( layer_id )) return layers get_all_implementation_models get_all_implementation_models () Get all the implementation model objects stored in settings. Returns: Type Description list Returns all the implementation model objects. Source code in src/cplus_plugin/conf.py 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 def get_all_implementation_models ( self ) -> typing . List [ ImplementationModel ]: \"\"\"Get all the implementation model objects stored in settings. :returns: Returns all the implementation model objects. :rtype: list \"\"\" implementation_models = [] implementation_model_root = self . _get_implementation_model_settings_base () with qgis_settings ( implementation_model_root ) as settings : keys = settings . childKeys () for k in keys : implementation_model = self . get_implementation_model ( k ) if implementation_model is not None : implementation_models . append ( implementation_model ) return sorted ( implementation_models , key = lambda imp_model : imp_model . name ) get_all_ncs_pathways get_all_ncs_pathways () Get all the NCS pathway objects stored in settings. Returns: Type Description list Returns all the NCS pathway objects. Source code in src/cplus_plugin/conf.py 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 def get_all_ncs_pathways ( self ) -> typing . List [ NcsPathway ]: \"\"\"Get all the NCS pathway objects stored in settings. :returns: Returns all the NCS pathway objects. :rtype: list \"\"\" ncs_pathways = [] ncs_root = self . _get_ncs_pathway_settings_base () with qgis_settings ( ncs_root ) as settings : keys = settings . childKeys () for k in keys : ncs_pathway = self . get_ncs_pathway ( k ) if ncs_pathway is not None : ncs_pathways . append ( ncs_pathway ) return sorted ( ncs_pathways , key = lambda ncs : ncs . name ) get_implementation_model get_implementation_model ( implementation_model_uuid ) Gets an implementation model object matching the given unique identified. Parameters: Name Type Description Default implementation_model_uuid str Unique identifier for the implementation model object. required Returns: Type Description ImplementationModel Returns the implementation model object matching the given identifier else None if not found. Source code in src/cplus_plugin/conf.py 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 def get_implementation_model ( self , implementation_model_uuid : str ) -> typing . Union [ ImplementationModel , None ]: \"\"\"Gets an implementation model object matching the given unique identified. :param implementation_model_uuid: Unique identifier for the implementation model object. :type implementation_model_uuid: str :returns: Returns the implementation model object matching the given identifier else None if not found. :rtype: ImplementationModel \"\"\" implementation_model = None implementation_model_root = self . _get_implementation_model_settings_base () with qgis_settings ( implementation_model_root ) as settings : implementation_model = settings . value ( implementation_model_uuid , None ) ncs_uuids = [] if implementation_model is not None : implementation_model_dict = {} try : implementation_model_dict = json . loads ( implementation_model ) except json . JSONDecodeError : log ( \"Implementation model JSON is invalid.\" ) if PATHWAYS_ATTRIBUTE in implementation_model_dict : ncs_uuids = implementation_model_dict [ PATHWAYS_ATTRIBUTE ] implementation_model = create_implementation_model ( implementation_model_dict ) if implementation_model is not None : for ncs_uuid in ncs_uuids : ncs = self . get_ncs_pathway ( ncs_uuid ) if ncs is not None : implementation_model . add_ncs_pathway ( ncs ) return implementation_model get_ncs_pathway get_ncs_pathway ( ncs_uuid ) Gets an NCS pathway object matching the given unique identified. Parameters: Name Type Description Default ncs_uuid str Unique identifier for the NCS pathway object. required Returns: Type Description NcsPathway Returns the NCS pathway object matching the given identifier else None if not found. Source code in src/cplus_plugin/conf.py 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 def get_ncs_pathway ( self , ncs_uuid : str ) -> typing . Union [ NcsPathway , None ]: \"\"\"Gets an NCS pathway object matching the given unique identified. :param ncs_uuid: Unique identifier for the NCS pathway object. :type ncs_uuid: str :returns: Returns the NCS pathway object matching the given identifier else None if not found. :rtype: NcsPathway \"\"\" ncs_pathway = None ncs_dict = self . get_ncs_pathway_dict ( ncs_uuid ) if len ( ncs_dict ) == 0 : return None ncs_pathway = create_ncs_pathway ( ncs_dict ) return ncs_pathway get_ncs_pathway_dict get_ncs_pathway_dict ( ncs_uuid ) Gets an NCS pathway attribute values as a dictionary. Parameters: Name Type Description Default ncs_uuid str Unique identifier for the NCS pathway object. required Returns: Type Description dict Returns the NCS pathway attribute values matching the given identifier else an empty dictionary if not found. Source code in src/cplus_plugin/conf.py 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 def get_ncs_pathway_dict ( self , ncs_uuid : str ) -> dict : \"\"\"Gets an NCS pathway attribute values as a dictionary. :param ncs_uuid: Unique identifier for the NCS pathway object. :type ncs_uuid: str :returns: Returns the NCS pathway attribute values matching the given identifier else an empty dictionary if not found. :rtype: dict \"\"\" ncs_pathway_dict = {} ncs_root = self . _get_ncs_pathway_settings_base () with qgis_settings ( ncs_root ) as settings : ncs_model = settings . value ( ncs_uuid , dict ()) if len ( ncs_model ) > 0 : try : ncs_pathway_dict = json . loads ( ncs_model ) except json . JSONDecodeError : log ( \"NCS pathway JSON is invalid\" ) return ncs_pathway_dict get_priority_group get_priority_group ( identifier ) Retrieves the priority group that matches the passed identifier. Parameters: Name Type Description Default identifier str Priority group identifier required Returns: Type Description typing.Dict Priority group Source code in src/cplus_plugin/conf.py 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 def get_priority_group ( self , identifier ) -> typing . Dict : \"\"\"Retrieves the priority group that matches the passed identifier. :param identifier: Priority group identifier :type identifier: str :returns: Priority group :rtype: typing.Dict \"\"\" settings_key = self . _get_priority_groups_settings_base ( identifier ) with qgis_settings ( settings_key ) as settings : priority_group = { \"uuid\" : identifier } priority_group [ \"name\" ] = settings . value ( \"name\" ) priority_group [ \"value\" ] = settings . value ( \"value\" ) return priority_group get_priority_groups get_priority_groups () Gets all the available priority groups in the plugin. Returns: Type Description list List of the priority groups instances Source code in src/cplus_plugin/conf.py 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 def get_priority_groups ( self ) -> typing . List [ typing . Dict ]: \"\"\"Gets all the available priority groups in the plugin. :returns: List of the priority groups instances :rtype: list \"\"\" priority_groups = [] with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_GROUP_NAME } \" ) as settings : for uuid in settings . childGroups (): priority_layer_settings = self . _get_priority_groups_settings_base ( uuid ) with qgis_settings ( priority_layer_settings ) as priority_settings : group = { \"uuid\" : uuid , \"name\" : priority_settings . value ( \"name\" ), \"value\" : priority_settings . value ( \"value\" ), } priority_groups . append ( group ) return priority_groups get_priority_layer get_priority_layer ( identifier ) Retrieves the priority layer that matches the passed identifier. Parameters: Name Type Description Default identifier uuid.UUID Priority layers identifier required Returns: Type Description dict Priority layers dict Source code in src/cplus_plugin/conf.py 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 def get_priority_layer ( self , identifier ) -> typing . Dict : \"\"\"Retrieves the priority layer that matches the passed identifier. :param identifier: Priority layers identifier :type identifier: uuid.UUID :returns: Priority layers dict :rtype: dict \"\"\" settings_key = self . _get_priority_layers_settings_base ( identifier ) with qgis_settings ( settings_key ) as settings : groups_key = f \" { settings_key } /groups\" groups = [] with qgis_settings ( groups_key ) as groups_settings : for name in groups_settings . childGroups (): group_settings_key = f \" { groups_key } / { name } \" with qgis_settings ( group_settings_key ) as group_settings : stored_group = {} stored_group [ \"name\" ] = group_settings . value ( \"name\" ) stored_group [ \"value\" ] = group_settings . value ( \"value\" ) groups . append ( stored_group ) priority_layer = { \"uuid\" : str ( identifier )} priority_layer [ \"name\" ] = settings . value ( \"name\" ) priority_layer [ \"description\" ] = settings . value ( \"description\" ) priority_layer [ \"path\" ] = settings . value ( \"path\" ) priority_layer [ \"selected\" ] = settings . value ( \"selected\" , type = bool ) priority_layer [ \"groups\" ] = groups return priority_layer get_priority_layers get_priority_layers () Gets all the available priority layers in the plugin. Returns: Type Description list Priority layers list Source code in src/cplus_plugin/conf.py 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 def get_priority_layers ( self ) -> typing . List : \"\"\"Gets all the available priority layers in the plugin. :returns: Priority layers list :rtype: list \"\"\" priority_layer_list = [] with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_LAYERS_GROUP_NAME } \" ) as settings : for uuid in settings . childGroups (): priority_layer_settings = self . _get_priority_layers_settings_base ( uuid ) with qgis_settings ( priority_layer_settings ) as priority_settings : groups_key = f \" { priority_layer_settings } /groups\" groups = [] with qgis_settings ( groups_key ) as groups_settings : for name in groups_settings . childGroups (): group_settings_key = f \" { groups_key } / { name } \" with qgis_settings ( group_settings_key ) as group_settings : stored_group = {} stored_group [ \"name\" ] = group_settings . value ( \"name\" ) stored_group [ \"value\" ] = group_settings . value ( \"value\" ) groups . append ( stored_group ) layer = { \"uuid\" : uuid , \"name\" : priority_settings . value ( \"name\" ), \"description\" : priority_settings . value ( \"description\" ), \"path\" : priority_settings . value ( \"path\" ), \"selected\" : priority_settings . value ( \"selected\" , type = bool ), \"groups\" : groups , } priority_layer_list . append ( layer ) return priority_layer_list get_scenario get_scenario ( scenario_id ) Retrieves the first scenario that matched the passed scenario id. Parameters: Name Type Description Default scenario_id str Scenario id required Returns: Type Description ScenarioSettings Scenario settings instance Source code in src/cplus_plugin/conf.py 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 def get_scenario ( self , scenario_id ): \"\"\"Retrieves the first scenario that matched the passed scenario id. :param scenario_id: Scenario id :type scenario_id: str :returns: Scenario settings instance :rtype: ScenarioSettings \"\"\" result = [] with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . SCENARIO_GROUP_NAME } \" ) as settings : for uuid in settings . childGroups (): scenario_settings_key = self . _get_scenario_settings_base ( uuid ) with qgis_settings ( scenario_settings_key ) as scenario_settings : scenario = ScenarioSettings . from_qgs_settings ( uuid , scenario_settings ) if scenario . id == scenario_id : return scenario return None get_scenarios get_scenarios () Gets all the available scenarios settings in the plugin. Returns: Type Description list List of the scenario settings instances Source code in src/cplus_plugin/conf.py 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 def get_scenarios ( self ): \"\"\"Gets all the available scenarios settings in the plugin. :returns: List of the scenario settings instances :rtype: list \"\"\" result = [] with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . SCENARIO_GROUP_NAME } \" ) as settings : for uuid in settings . childGroups (): scenario_settings_key = self . _get_scenario_settings_base ( uuid ) with qgis_settings ( scenario_settings_key ) as scenario_settings : scenario = ScenarioSettings . from_qgs_settings ( uuid , scenario_settings ) scenario . extent = self . get_scenario_ result . append ( ScenarioSettings . from_qgs_settings ( uuid , scenario_settings ) ) return result get_value get_value ( name , default = None , setting_type = None ) Gets value of the setting with the passed name. Parameters: Name Type Description Default name str Name of setting key required default Any Default value returned when the setting key does not exist None setting_type Any Type of the store setting None Returns: Type Description Any Value of the setting Source code in src/cplus_plugin/conf.py 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 def get_value ( self , name : str , default = None , setting_type = None ): \"\"\"Gets value of the setting with the passed name. :param name: Name of setting key :type name: str :param default: Default value returned when the setting key does not exist :type default: Any :param setting_type: Type of the store setting :type setting_type: Any :returns: Value of the setting :rtype: Any \"\"\" if setting_type : return self . settings . value ( f \" { self . BASE_GROUP_NAME } / { name } \" , default , setting_type ) return self . settings . value ( f \" { self . BASE_GROUP_NAME } / { name } \" , default ) remove remove ( name ) Remove the setting with the specified name. Parameters: Name Type Description Default name str Name of the setting key required Source code in src/cplus_plugin/conf.py 202 203 204 205 206 207 208 def remove ( self , name ): \"\"\"Remove the setting with the specified name. :param name: Name of the setting key :type name: str \"\"\" self . settings . remove ( f \" { self . BASE_GROUP_NAME } / { name } \" ) remove_implementation_model remove_implementation_model ( implementation_model_uuid ) Removes an implementation model settings entry using the UUID. Parameters: Name Type Description Default implementation_model_uuid str Unique identifier of the implementation model entry to removed. required Source code in src/cplus_plugin/conf.py 931 932 933 934 935 936 937 938 939 def remove_implementation_model ( self , implementation_model_uuid : str ): \"\"\"Removes an implementation model settings entry using the UUID. :param implementation_model_uuid: Unique identifier of the implementation model entry to removed. :type implementation_model_uuid: str \"\"\" if self . get_implementation_model ( implementation_model_uuid ) is not None : self . remove ( f \" { self . IMPLEMENTATION_MODEL_BASE } / { implementation_model_uuid } \" ) remove_ncs_pathway remove_ncs_pathway ( ncs_uuid ) Removes an NCS pathway settings entry using the UUID. Parameters: Name Type Description Default ncs_uuid str Unique identifier of the NCS pathway entry to removed. required Source code in src/cplus_plugin/conf.py 777 778 779 780 781 782 783 784 785 def remove_ncs_pathway ( self , ncs_uuid : str ): \"\"\"Removes an NCS pathway settings entry using the UUID. :param ncs_uuid: Unique identifier of the NCS pathway entry to removed. :type ncs_uuid: str \"\"\" if self . get_ncs_pathway ( ncs_uuid ) is not None : self . remove ( f \" { self . NCS_PATHWAY_BASE } / { ncs_uuid } \" ) save_implementation_model save_implementation_model ( implementation_model ) Saves an implementation model object serialized to a json string indexed by the UUID. Parameters: Name Type Description Default implementation_model Union [ ImplementationModel , dict ] Implementation model object or attribute values in a dictionary which are then serialized to a JSON string. required Source code in src/cplus_plugin/conf.py 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 def save_implementation_model ( self , implementation_model : typing . Union [ ImplementationModel , dict ] ): \"\"\"Saves an implementation model object serialized to a json string indexed by the UUID. :param implementation_model: Implementation model object or attribute values in a dictionary which are then serialized to a JSON string. :type implementation_model: ImplementationModel, dict \"\"\" if isinstance ( implementation_model , ImplementationModel ): priority_layers = implementation_model . priority_layers ncs_pathways = [] for ncs in implementation_model . pathways : ncs_pathways . append ( str ( ncs . uuid )) implementation_model = layer_component_to_dict ( implementation_model ) implementation_model [ PRIORITY_LAYERS_SEGMENT ] = priority_layers implementation_model [ PATHWAYS_ATTRIBUTE ] = ncs_pathways if isinstance ( implementation_model , dict ): priority_layers = [] if implementation_model . get ( \"pwls_ids\" ) is not None : for layer_id in implementation_model . get ( \"pwls_ids\" , []): layer = self . get_priority_layer ( layer_id ) priority_layers . append ( layer ) if len ( priority_layers ) > 0 : implementation_model [ PRIORITY_LAYERS_SEGMENT ] = priority_layers implementation_model_str = json . dumps ( implementation_model ) implementation_model_uuid = implementation_model [ UUID_ATTRIBUTE ] implementation_model_root = self . _get_implementation_model_settings_base () with qgis_settings ( implementation_model_root ) as settings : settings . setValue ( implementation_model_uuid , implementation_model_str ) save_ncs_pathway save_ncs_pathway ( ncs_pathway ) Saves an NCS pathway object serialized to a json string indexed by the UUID. Parameters: Name Type Description Default ncs_pathway Union [ NcsPathway , dict ] NCS pathway object or attribute values in a dictionary which are then serialized to a JSON string. required Source code in src/cplus_plugin/conf.py 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 def save_ncs_pathway ( self , ncs_pathway : typing . Union [ NcsPathway , dict ]): \"\"\"Saves an NCS pathway object serialized to a json string indexed by the UUID. :param ncs_pathway: NCS pathway object or attribute values in a dictionary which are then serialized to a JSON string. :type ncs_pathway: NcsPathway, dict \"\"\" if isinstance ( ncs_pathway , NcsPathway ): ncs_pathway = ncs_pathway_to_dict ( ncs_pathway ) ncs_str = json . dumps ( ncs_pathway ) ncs_uuid = ncs_pathway [ UUID_ATTRIBUTE ] ncs_root = self . _get_ncs_pathway_settings_base () with qgis_settings ( ncs_root ) as settings : settings . setValue ( ncs_uuid , ncs_str ) save_priority_group save_priority_group ( priority_group ) Save the priority group into the plugin settings Parameters: Name Type Description Default priority_group str Priority group required Source code in src/cplus_plugin/conf.py 611 612 613 614 615 616 617 618 619 620 621 622 def save_priority_group ( self , priority_group ): \"\"\"Save the priority group into the plugin settings :param priority_group: Priority group :type priority_group: str \"\"\" settings_key = self . _get_priority_groups_settings_base ( priority_group [ \"uuid\" ]) with qgis_settings ( settings_key ) as settings : settings . setValue ( \"name\" , priority_group [ \"name\" ]) settings . setValue ( \"value\" , priority_group [ \"value\" ]) save_priority_layer save_priority_layer ( priority_layer ) Save the priority layer into the plugin settings. Updates the layer with new priority groups. Note: Emits priority_layers_changed signal Parameters: Name Type Description Default priority_layer dict Priority layer required Source code in src/cplus_plugin/conf.py 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 def save_priority_layer ( self , priority_layer ): \"\"\"Save the priority layer into the plugin settings. Updates the layer with new priority groups. Note: Emits priority_layers_changed signal :param priority_layer: Priority layer :type priority_layer: dict \"\"\" settings_key = self . _get_priority_layers_settings_base ( priority_layer [ \"uuid\" ]) with qgis_settings ( settings_key ) as settings : groups = priority_layer . get ( \"groups\" , []) settings . setValue ( \"name\" , priority_layer [ \"name\" ]) settings . setValue ( \"description\" , priority_layer [ \"description\" ]) settings . setValue ( \"path\" , priority_layer [ \"path\" ]) settings . setValue ( \"selected\" , priority_layer . get ( \"selected\" , False )) groups_key = f \" { settings_key } /groups\" with qgis_settings ( groups_key ) as groups_settings : for group_id in groups_settings . childGroups (): groups_settings . remove ( group_id ) for group in groups : group_key = f \" { groups_key } / { group [ 'name' ] } \" with qgis_settings ( group_key ) as group_settings : group_settings . setValue ( \"name\" , group [ \"name\" ]) group_settings . setValue ( \"value\" , group [ \"value\" ]) self . priority_layers_changed . emit () save_scenario save_scenario ( scenario_settings ) Save the passed scenario settings into the plugin settings Parameters: Name Type Description Default scenario_settings ScenarioSettings Scenario settings required Source code in src/cplus_plugin/conf.py 229 230 231 232 233 234 235 236 237 238 239 240 241 242 def save_scenario ( self , scenario_settings ): \"\"\"Save the passed scenario settings into the plugin settings :param scenario_settings: Scenario settings :type scenario_settings: ScenarioSettings \"\"\" settings_key = self . _get_scenario_settings_base ( scenario_settings . uuid ) self . save_scenario_extent ( settings_key , scenario_settings . extent ) with qgis_settings ( settings_key ) as settings : settings . setValue ( \"name\" , scenario_settings . name ) settings . setValue ( \"description\" , scenario_settings . description ) settings . setValue ( \"uuid\" , scenario_settings . uuid ) save_scenario_extent save_scenario_extent ( key , extent ) Saves the scenario extent into plugin settings using the provided settings group key. Parameters: Name Type Description Default key SpatialExtent Scenario extent required extent str Args: extent (SpatialExtent): Scenario extent key (str): QgsSettings group key QgsSettings group key required Source code in src/cplus_plugin/conf.py 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 def save_scenario_extent ( self , key , extent ): \"\"\"Saves the scenario extent into plugin settings using the provided settings group key. :param key: Scenario extent :type key: SpatialExtent :param extent: QgsSettings group key :type extent: str Args: extent (SpatialExtent): Scenario extent key (str): QgsSettings group key \"\"\" spatial_extent = extent . spatial . bbox spatial_key = f \" { key } /extent/spatial/\" with qgis_settings ( spatial_key ) as settings : settings . setValue ( \"bbox\" , spatial_extent ) set_current_priority_layer set_current_priority_layer ( identifier ) Set current priority layer Parameters: Name Type Description Default identifier str Priority layer identifier required Source code in src/cplus_plugin/conf.py 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 def set_current_priority_layer ( self , identifier ): \"\"\"Set current priority layer :param identifier: Priority layer identifier :type identifier: str \"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_LAYERS_GROUP_NAME } /\" ) as settings : for priority_layer in settings . childGroups (): settings_key = self . _get_priority_layers_settings_base ( identifier ) with qgis_settings ( settings_key ) as layer_settings : layer_settings . setValue ( \"selected\" , str ( priority_layer ) == str ( identifier ) ) set_value set_value ( name , value ) Adds a new setting key and value on the plugin specific settings. Parameters: Name Type Description Default name str Name of setting key required value Any Value of the setting required Source code in src/cplus_plugin/conf.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 def set_value ( self , name : str , value ): \"\"\"Adds a new setting key and value on the plugin specific settings. :param name: Name of setting key :type name: str :param value: Value of the setting :type value: Any \"\"\" self . settings . setValue ( f \" { self . BASE_GROUP_NAME } / { name } \" , value ) if isinstance ( name , Settings ): name = name . value self . settings_updated . emit ( name , value ) update_implementation_model update_implementation_model ( implementation_model ) Updates the attributes of the Implementation object in settings. On the path, the BASE_DIR in settings is used to reflect the absolute path of each NCS pathway layer. If BASE_DIR is empty then the NCS pathway setting will not be updated. Parameters: Name Type Description Default implementation_model ImplementationModel ImplementationModel object to be updated. required Source code in src/cplus_plugin/conf.py 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 def update_implementation_model ( self , implementation_model : ImplementationModel ): \"\"\"Updates the attributes of the Implementation object in settings. On the path, the BASE_DIR in settings is used to reflect the absolute path of each NCS pathway layer. If BASE_DIR is empty then the NCS pathway setting will not be updated. :param implementation_model: ImplementationModel object to be updated. :type implementation_model: ImplementationModel \"\"\" base_dir = self . get_value ( Settings . BASE_DIR ) if not base_dir : return # PWLs path update for layer in implementation_model . priority_layers : if layer in PRIORITY_LAYERS and base_dir not in layer . get ( PATH_ATTRIBUTE ): abs_pwl_path = ( f \" { base_dir } / { PRIORITY_LAYERS_SEGMENT } /\" f \" { layer . get ( PATH_ATTRIBUTE ) } \" ) abs_pwl_path = str ( os . path . normpath ( abs_pwl_path )) layer [ PATH_ATTRIBUTE ] = abs_pwl_path # Remove then re-insert self . remove_implementation_model ( str ( implementation_model . uuid )) self . save_implementation_model ( implementation_model ) update_implementation_models update_implementation_models () Updates the attributes of the avaialable implementation models Parameters: Name Type Description Default implementation_model ImplementationModel Implementation model object to be updated. required Source code in src/cplus_plugin/conf.py 920 921 922 923 924 925 926 927 928 929 def update_implementation_models ( self ): \"\"\"Updates the attributes of the avaialable implementation models :param implementation_model: Implementation model object to be updated. :type implementation_model: ImplementationModel \"\"\" models = self . get_all_implementation_models () for implementation_model in models : self . update_implementation_model ( implementation_model ) update_ncs_pathway update_ncs_pathway ( ncs_pathway ) Updates the attributes of the NCS pathway object in settings. On the path, the BASE_DIR in settings is used to reflect the absolute path of each NCS pathway layer. If BASE_DIR is empty then the NCS pathway setting will not be updated, this only applies for default pathways. Parameters: Name Type Description Default ncs_pathway NcsPathway NCS pathway object to be updated. required Source code in src/cplus_plugin/conf.py 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 def update_ncs_pathway ( self , ncs_pathway : NcsPathway ): \"\"\"Updates the attributes of the NCS pathway object in settings. On the path, the BASE_DIR in settings is used to reflect the absolute path of each NCS pathway layer. If BASE_DIR is empty then the NCS pathway setting will not be updated, this only applies for default pathways. :param ncs_pathway: NCS pathway object to be updated. :type ncs_pathway: NcsPathway \"\"\" base_dir = self . get_value ( Settings . BASE_DIR ) if not base_dir : return # Pathway location for default pathway if not ncs_pathway . user_defined : p = Path ( ncs_pathway . path ) # Only update if path does not exist otherwise # fallback to check under base directory. if not p . exists (): abs_path = f \" { base_dir } / { NCS_PATHWAY_SEGMENT } /\" f \" { p . name } \" abs_path = str ( os . path . normpath ( abs_path )) ncs_pathway . path = abs_path # Carbon location abs_carbon_paths = [] for cb_path in ncs_pathway . carbon_paths : cp = Path ( cb_path ) # Similarly, if the given carbon path does not exist then try # to use the default one in the ncs_carbon directory. if not cp . exists (): abs_carbon_path = f \" { base_dir } / { NCS_CARBON_SEGMENT } /\" f \" { cp . name } \" abs_carbon_path = str ( os . path . normpath ( abs_carbon_path )) abs_carbon_paths . append ( abs_carbon_path ) else : abs_carbon_paths . append ( cb_path ) ncs_pathway . carbon_paths = abs_carbon_paths # Remove then re-insert self . remove_ncs_pathway ( str ( ncs_pathway . uuid )) self . save_ncs_pathway ( ncs_pathway ) update_ncs_pathways update_ncs_pathways () Updates the path attribute of all NCS pathway settings based on the BASE_DIR settings to reflect the absolute path of each NCS pathway layer. If BASE_DIR is empty then the NCS pathway settings will not be updated. Source code in src/cplus_plugin/conf.py 722 723 724 725 726 727 728 729 730 731 def update_ncs_pathways ( self ): \"\"\"Updates the path attribute of all NCS pathway settings based on the BASE_DIR settings to reflect the absolute path of each NCS pathway layer. If BASE_DIR is empty then the NCS pathway settings will not be updated. \"\"\" ncs_pathways = self . get_all_ncs_pathways () for ncs in ncs_pathways : self . update_ncs_pathway ( ncs ) qgis_settings qgis_settings ( group_root , settings = None ) Context manager to help defining groups when creating QgsSettings. :yields: Instance of the created settings :ytype: QgsSettings Parameters: Name Type Description Default group_root str Name of the root group for the settings required settings QgsSettings QGIS settings to use None Source code in src/cplus_plugin/conf.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 @contextlib . contextmanager def qgis_settings ( group_root : str , settings = None ): \"\"\"Context manager to help defining groups when creating QgsSettings. :param group_root: Name of the root group for the settings :type group_root: str :param settings: QGIS settings to use :type settings: QgsSettings :yields: Instance of the created settings :ytype: QgsSettings \"\"\" if settings is None : settings = QgsSettings () settings . beginGroup ( group_root ) try : yield settings finally : settings . endGroup ()","title":"Configuration"},{"location":"developer/api/core/api_conf/#configuration","text":"Handles storage and retrieval of the plugin QgsSettings.","title":"Configuration"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.ScenarioSettings","text":"Bases: Scenario Plugin Scenario settings.","title":"ScenarioSettings"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.ScenarioSettings.from_qgs_settings","text":"from_qgs_settings ( identifier , settings ) Reads QGIS settings and parses them into a scenario settings instance with the respective settings values as properties. Parameters: Name Type Description Default identifier str Scenario identifier required settings QgsSettings Scenario identifier required Returns: Type Description ScenarioSettings Scenario settings object Source code in src/cplus_plugin/conf.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 @classmethod def from_qgs_settings ( cls , identifier : str , settings : QgsSettings ): \"\"\"Reads QGIS settings and parses them into a scenario settings instance with the respective settings values as properties. :param identifier: Scenario identifier :type identifier: str :param settings: Scenario identifier :type settings: QgsSettings :returns: Scenario settings object :rtype: ScenarioSettings \"\"\" return cls ( uuid = uuid . UUID ( identifier ), name = settings . value ( \"name\" , None ), description = settings . value ( \"description\" , None ), )","title":"from_qgs_settings()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.ScenarioSettings.get_scenario_extent","text":"get_scenario_extent () Fetches Scenario extent from the passed scenario settings. Returns: Type Description SpatialExtent Spatial extent instance extent Source code in src/cplus_plugin/conf.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 @classmethod def get_scenario_extent ( cls ): \"\"\"Fetches Scenario extent from the passed scenario settings. :returns: Spatial extent instance extent :rtype: SpatialExtent \"\"\" spatial_key = \"extent/spatial\" with qgis_settings ( spatial_key , cls ) as settings : bbox = settings . value ( \"bbox\" , None ) spatial_extent = SpatialExtent ( bbox = bbox ) return spatial_extent","title":"get_scenario_extent()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.Settings","text":"Bases: Enum Plugin settings names","title":"Settings"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager","text":"Bases: QObject Manages saving/loading settings for the plugin in QgsSettings.","title":"SettingsManager"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.delete_all_scenarios","text":"delete_all_scenarios () Deletes all the plugin scenarios settings. Source code in src/cplus_plugin/conf.py 327 328 329 330 331 332 333 def delete_all_scenarios ( self ): \"\"\"Deletes all the plugin scenarios settings.\"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . SCENARIO_GROUP_NAME } \" ) as settings : for scenario_name in settings . childGroups (): settings . remove ( scenario_name )","title":"delete_all_scenarios()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.delete_priority_groups","text":"delete_priority_groups () Deletes all the plugin priority groups settings. Source code in src/cplus_plugin/conf.py 624 625 626 627 628 629 630 def delete_priority_groups ( self ): \"\"\"Deletes all the plugin priority groups settings.\"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_GROUP_NAME } \" ) as settings : for priority_group in settings . childGroups (): settings . remove ( priority_group )","title":"delete_priority_groups()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.delete_priority_layer","text":"delete_priority_layer ( identifier ) Removes priority layer that match the passed identifier Parameters: Name Type Description Default identifier str Priority layer identifier required Source code in src/cplus_plugin/conf.py 522 523 524 525 526 527 528 529 530 531 532 533 def delete_priority_layer ( self , identifier ): \"\"\"Removes priority layer that match the passed identifier :param identifier: Priority layer identifier :type identifier: str \"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_LAYERS_GROUP_NAME } /\" ) as settings : for priority_layer in settings . childGroups (): if str ( priority_layer ) == str ( identifier ): settings . remove ( priority_layer )","title":"delete_priority_layer()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.delete_priority_layers","text":"delete_priority_layers () Deletes all the plugin priority settings. Source code in src/cplus_plugin/conf.py 514 515 516 517 518 519 520 def delete_priority_layers ( self ): \"\"\"Deletes all the plugin priority settings.\"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_LAYERS_GROUP_NAME } \" ) as settings : for priority_layer in settings . childGroups (): settings . remove ( priority_layer )","title":"delete_priority_layers()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.delete_settings","text":"delete_settings () Deletes the all the plugin settings. Source code in src/cplus_plugin/conf.py 210 211 212 def delete_settings ( self ): \"\"\"Deletes the all the plugin settings.\"\"\" self . settings . remove ( f \" { self . BASE_GROUP_NAME } \" )","title":"delete_settings()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.find_group_by_name","text":"find_group_by_name ( name ) Finds a priority group setting inside the plugin QgsSettings by name. Parameters: Name Type Description Default name str Name of the group required Returns: Type Description typing.Dict Priority group Source code in src/cplus_plugin/conf.py 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 def find_group_by_name ( self , name ) -> typing . Dict : \"\"\"Finds a priority group setting inside the plugin QgsSettings by name. :param name: Name of the group :type name: str :returns: Priority group :rtype: typing.Dict \"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_GROUP_NAME } \" ) as settings : for group_id in settings . childGroups (): group_settings_key = self . _get_priority_groups_settings_base ( group_id ) with qgis_settings ( group_settings_key ) as group_settings_key : group_name = group_settings_key . value ( \"name\" ) if group_name == name : found_id = uuid . UUID ( group_id ) break return self . get_priority_group ( found_id )","title":"find_group_by_name()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.find_layer_by_name","text":"find_layer_by_name ( name ) Finds a priority layer setting inside the plugin QgsSettings by name. Parameters: Name Type Description Default name str Priority layers identifier required Returns: Type Description dict Priority layers dict Source code in src/cplus_plugin/conf.py 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 def find_layer_by_name ( self , name ) -> typing . Dict : \"\"\"Finds a priority layer setting inside the plugin QgsSettings by name. :param name: Priority layers identifier :type name: str :returns: Priority layers dict :rtype: dict \"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_LAYERS_GROUP_NAME } \" ) as settings : for layer_id in settings . childGroups (): layer_settings_key = self . _get_priority_layers_settings_base ( layer_id ) with qgis_settings ( layer_settings_key ) as layer_settings : layer_name = layer_settings . value ( \"name\" ) if layer_name == name : found_id = uuid . UUID ( layer_id ) break return self . get_priority_layer ( found_id )","title":"find_layer_by_name()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.find_layers_by_group","text":"find_layers_by_group ( group ) Finds priority layers inside the plugin QgsSettings that contain the passed group. Parameters: Name Type Description Default group str Priority group name required Returns: Type Description list Priority layers list Source code in src/cplus_plugin/conf.py 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 def find_layers_by_group ( self , group ) -> typing . List : \"\"\"Finds priority layers inside the plugin QgsSettings that contain the passed group. :param group: Priority group name :type group: str :returns: Priority layers list :rtype: list \"\"\" layers = [] with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_LAYERS_GROUP_NAME } \" ) as settings : for layer_id in settings . childGroups (): priority_layer_settings = self . _get_priority_layers_settings_base ( layer_id ) with qgis_settings ( priority_layer_settings ) as priority_settings : groups_key = f \" { priority_layer_settings } /groups\" with qgis_settings ( groups_key ) as groups_settings : for name in groups_settings . childGroups (): group_settings_key = f \" { groups_key } / { name } \" with qgis_settings ( group_settings_key ) as group_settings : if group == group_settings . value ( \"name\" ): layers . append ( self . get_priority_layer ( layer_id )) return layers","title":"find_layers_by_group()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_all_implementation_models","text":"get_all_implementation_models () Get all the implementation model objects stored in settings. Returns: Type Description list Returns all the implementation model objects. Source code in src/cplus_plugin/conf.py 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 def get_all_implementation_models ( self ) -> typing . List [ ImplementationModel ]: \"\"\"Get all the implementation model objects stored in settings. :returns: Returns all the implementation model objects. :rtype: list \"\"\" implementation_models = [] implementation_model_root = self . _get_implementation_model_settings_base () with qgis_settings ( implementation_model_root ) as settings : keys = settings . childKeys () for k in keys : implementation_model = self . get_implementation_model ( k ) if implementation_model is not None : implementation_models . append ( implementation_model ) return sorted ( implementation_models , key = lambda imp_model : imp_model . name )","title":"get_all_implementation_models()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_all_ncs_pathways","text":"get_all_ncs_pathways () Get all the NCS pathway objects stored in settings. Returns: Type Description list Returns all the NCS pathway objects. Source code in src/cplus_plugin/conf.py 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 def get_all_ncs_pathways ( self ) -> typing . List [ NcsPathway ]: \"\"\"Get all the NCS pathway objects stored in settings. :returns: Returns all the NCS pathway objects. :rtype: list \"\"\" ncs_pathways = [] ncs_root = self . _get_ncs_pathway_settings_base () with qgis_settings ( ncs_root ) as settings : keys = settings . childKeys () for k in keys : ncs_pathway = self . get_ncs_pathway ( k ) if ncs_pathway is not None : ncs_pathways . append ( ncs_pathway ) return sorted ( ncs_pathways , key = lambda ncs : ncs . name )","title":"get_all_ncs_pathways()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_implementation_model","text":"get_implementation_model ( implementation_model_uuid ) Gets an implementation model object matching the given unique identified. Parameters: Name Type Description Default implementation_model_uuid str Unique identifier for the implementation model object. required Returns: Type Description ImplementationModel Returns the implementation model object matching the given identifier else None if not found. Source code in src/cplus_plugin/conf.py 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 def get_implementation_model ( self , implementation_model_uuid : str ) -> typing . Union [ ImplementationModel , None ]: \"\"\"Gets an implementation model object matching the given unique identified. :param implementation_model_uuid: Unique identifier for the implementation model object. :type implementation_model_uuid: str :returns: Returns the implementation model object matching the given identifier else None if not found. :rtype: ImplementationModel \"\"\" implementation_model = None implementation_model_root = self . _get_implementation_model_settings_base () with qgis_settings ( implementation_model_root ) as settings : implementation_model = settings . value ( implementation_model_uuid , None ) ncs_uuids = [] if implementation_model is not None : implementation_model_dict = {} try : implementation_model_dict = json . loads ( implementation_model ) except json . JSONDecodeError : log ( \"Implementation model JSON is invalid.\" ) if PATHWAYS_ATTRIBUTE in implementation_model_dict : ncs_uuids = implementation_model_dict [ PATHWAYS_ATTRIBUTE ] implementation_model = create_implementation_model ( implementation_model_dict ) if implementation_model is not None : for ncs_uuid in ncs_uuids : ncs = self . get_ncs_pathway ( ncs_uuid ) if ncs is not None : implementation_model . add_ncs_pathway ( ncs ) return implementation_model","title":"get_implementation_model()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_ncs_pathway","text":"get_ncs_pathway ( ncs_uuid ) Gets an NCS pathway object matching the given unique identified. Parameters: Name Type Description Default ncs_uuid str Unique identifier for the NCS pathway object. required Returns: Type Description NcsPathway Returns the NCS pathway object matching the given identifier else None if not found. Source code in src/cplus_plugin/conf.py 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 def get_ncs_pathway ( self , ncs_uuid : str ) -> typing . Union [ NcsPathway , None ]: \"\"\"Gets an NCS pathway object matching the given unique identified. :param ncs_uuid: Unique identifier for the NCS pathway object. :type ncs_uuid: str :returns: Returns the NCS pathway object matching the given identifier else None if not found. :rtype: NcsPathway \"\"\" ncs_pathway = None ncs_dict = self . get_ncs_pathway_dict ( ncs_uuid ) if len ( ncs_dict ) == 0 : return None ncs_pathway = create_ncs_pathway ( ncs_dict ) return ncs_pathway","title":"get_ncs_pathway()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_ncs_pathway_dict","text":"get_ncs_pathway_dict ( ncs_uuid ) Gets an NCS pathway attribute values as a dictionary. Parameters: Name Type Description Default ncs_uuid str Unique identifier for the NCS pathway object. required Returns: Type Description dict Returns the NCS pathway attribute values matching the given identifier else an empty dictionary if not found. Source code in src/cplus_plugin/conf.py 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 def get_ncs_pathway_dict ( self , ncs_uuid : str ) -> dict : \"\"\"Gets an NCS pathway attribute values as a dictionary. :param ncs_uuid: Unique identifier for the NCS pathway object. :type ncs_uuid: str :returns: Returns the NCS pathway attribute values matching the given identifier else an empty dictionary if not found. :rtype: dict \"\"\" ncs_pathway_dict = {} ncs_root = self . _get_ncs_pathway_settings_base () with qgis_settings ( ncs_root ) as settings : ncs_model = settings . value ( ncs_uuid , dict ()) if len ( ncs_model ) > 0 : try : ncs_pathway_dict = json . loads ( ncs_model ) except json . JSONDecodeError : log ( \"NCS pathway JSON is invalid\" ) return ncs_pathway_dict","title":"get_ncs_pathway_dict()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_priority_group","text":"get_priority_group ( identifier ) Retrieves the priority group that matches the passed identifier. Parameters: Name Type Description Default identifier str Priority group identifier required Returns: Type Description typing.Dict Priority group Source code in src/cplus_plugin/conf.py 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 def get_priority_group ( self , identifier ) -> typing . Dict : \"\"\"Retrieves the priority group that matches the passed identifier. :param identifier: Priority group identifier :type identifier: str :returns: Priority group :rtype: typing.Dict \"\"\" settings_key = self . _get_priority_groups_settings_base ( identifier ) with qgis_settings ( settings_key ) as settings : priority_group = { \"uuid\" : identifier } priority_group [ \"name\" ] = settings . value ( \"name\" ) priority_group [ \"value\" ] = settings . value ( \"value\" ) return priority_group","title":"get_priority_group()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_priority_groups","text":"get_priority_groups () Gets all the available priority groups in the plugin. Returns: Type Description list List of the priority groups instances Source code in src/cplus_plugin/conf.py 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 def get_priority_groups ( self ) -> typing . List [ typing . Dict ]: \"\"\"Gets all the available priority groups in the plugin. :returns: List of the priority groups instances :rtype: list \"\"\" priority_groups = [] with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_GROUP_NAME } \" ) as settings : for uuid in settings . childGroups (): priority_layer_settings = self . _get_priority_groups_settings_base ( uuid ) with qgis_settings ( priority_layer_settings ) as priority_settings : group = { \"uuid\" : uuid , \"name\" : priority_settings . value ( \"name\" ), \"value\" : priority_settings . value ( \"value\" ), } priority_groups . append ( group ) return priority_groups","title":"get_priority_groups()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_priority_layer","text":"get_priority_layer ( identifier ) Retrieves the priority layer that matches the passed identifier. Parameters: Name Type Description Default identifier uuid.UUID Priority layers identifier required Returns: Type Description dict Priority layers dict Source code in src/cplus_plugin/conf.py 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 def get_priority_layer ( self , identifier ) -> typing . Dict : \"\"\"Retrieves the priority layer that matches the passed identifier. :param identifier: Priority layers identifier :type identifier: uuid.UUID :returns: Priority layers dict :rtype: dict \"\"\" settings_key = self . _get_priority_layers_settings_base ( identifier ) with qgis_settings ( settings_key ) as settings : groups_key = f \" { settings_key } /groups\" groups = [] with qgis_settings ( groups_key ) as groups_settings : for name in groups_settings . childGroups (): group_settings_key = f \" { groups_key } / { name } \" with qgis_settings ( group_settings_key ) as group_settings : stored_group = {} stored_group [ \"name\" ] = group_settings . value ( \"name\" ) stored_group [ \"value\" ] = group_settings . value ( \"value\" ) groups . append ( stored_group ) priority_layer = { \"uuid\" : str ( identifier )} priority_layer [ \"name\" ] = settings . value ( \"name\" ) priority_layer [ \"description\" ] = settings . value ( \"description\" ) priority_layer [ \"path\" ] = settings . value ( \"path\" ) priority_layer [ \"selected\" ] = settings . value ( \"selected\" , type = bool ) priority_layer [ \"groups\" ] = groups return priority_layer","title":"get_priority_layer()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_priority_layers","text":"get_priority_layers () Gets all the available priority layers in the plugin. Returns: Type Description list Priority layers list Source code in src/cplus_plugin/conf.py 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 def get_priority_layers ( self ) -> typing . List : \"\"\"Gets all the available priority layers in the plugin. :returns: Priority layers list :rtype: list \"\"\" priority_layer_list = [] with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_LAYERS_GROUP_NAME } \" ) as settings : for uuid in settings . childGroups (): priority_layer_settings = self . _get_priority_layers_settings_base ( uuid ) with qgis_settings ( priority_layer_settings ) as priority_settings : groups_key = f \" { priority_layer_settings } /groups\" groups = [] with qgis_settings ( groups_key ) as groups_settings : for name in groups_settings . childGroups (): group_settings_key = f \" { groups_key } / { name } \" with qgis_settings ( group_settings_key ) as group_settings : stored_group = {} stored_group [ \"name\" ] = group_settings . value ( \"name\" ) stored_group [ \"value\" ] = group_settings . value ( \"value\" ) groups . append ( stored_group ) layer = { \"uuid\" : uuid , \"name\" : priority_settings . value ( \"name\" ), \"description\" : priority_settings . value ( \"description\" ), \"path\" : priority_settings . value ( \"path\" ), \"selected\" : priority_settings . value ( \"selected\" , type = bool ), \"groups\" : groups , } priority_layer_list . append ( layer ) return priority_layer_list","title":"get_priority_layers()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_scenario","text":"get_scenario ( scenario_id ) Retrieves the first scenario that matched the passed scenario id. Parameters: Name Type Description Default scenario_id str Scenario id required Returns: Type Description ScenarioSettings Scenario settings instance Source code in src/cplus_plugin/conf.py 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 def get_scenario ( self , scenario_id ): \"\"\"Retrieves the first scenario that matched the passed scenario id. :param scenario_id: Scenario id :type scenario_id: str :returns: Scenario settings instance :rtype: ScenarioSettings \"\"\" result = [] with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . SCENARIO_GROUP_NAME } \" ) as settings : for uuid in settings . childGroups (): scenario_settings_key = self . _get_scenario_settings_base ( uuid ) with qgis_settings ( scenario_settings_key ) as scenario_settings : scenario = ScenarioSettings . from_qgs_settings ( uuid , scenario_settings ) if scenario . id == scenario_id : return scenario return None","title":"get_scenario()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_scenarios","text":"get_scenarios () Gets all the available scenarios settings in the plugin. Returns: Type Description list List of the scenario settings instances Source code in src/cplus_plugin/conf.py 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 def get_scenarios ( self ): \"\"\"Gets all the available scenarios settings in the plugin. :returns: List of the scenario settings instances :rtype: list \"\"\" result = [] with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . SCENARIO_GROUP_NAME } \" ) as settings : for uuid in settings . childGroups (): scenario_settings_key = self . _get_scenario_settings_base ( uuid ) with qgis_settings ( scenario_settings_key ) as scenario_settings : scenario = ScenarioSettings . from_qgs_settings ( uuid , scenario_settings ) scenario . extent = self . get_scenario_ result . append ( ScenarioSettings . from_qgs_settings ( uuid , scenario_settings ) ) return result","title":"get_scenarios()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_value","text":"get_value ( name , default = None , setting_type = None ) Gets value of the setting with the passed name. Parameters: Name Type Description Default name str Name of setting key required default Any Default value returned when the setting key does not exist None setting_type Any Type of the store setting None Returns: Type Description Any Value of the setting Source code in src/cplus_plugin/conf.py 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 def get_value ( self , name : str , default = None , setting_type = None ): \"\"\"Gets value of the setting with the passed name. :param name: Name of setting key :type name: str :param default: Default value returned when the setting key does not exist :type default: Any :param setting_type: Type of the store setting :type setting_type: Any :returns: Value of the setting :rtype: Any \"\"\" if setting_type : return self . settings . value ( f \" { self . BASE_GROUP_NAME } / { name } \" , default , setting_type ) return self . settings . value ( f \" { self . BASE_GROUP_NAME } / { name } \" , default )","title":"get_value()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.remove","text":"remove ( name ) Remove the setting with the specified name. Parameters: Name Type Description Default name str Name of the setting key required Source code in src/cplus_plugin/conf.py 202 203 204 205 206 207 208 def remove ( self , name ): \"\"\"Remove the setting with the specified name. :param name: Name of the setting key :type name: str \"\"\" self . settings . remove ( f \" { self . BASE_GROUP_NAME } / { name } \" )","title":"remove()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.remove_implementation_model","text":"remove_implementation_model ( implementation_model_uuid ) Removes an implementation model settings entry using the UUID. Parameters: Name Type Description Default implementation_model_uuid str Unique identifier of the implementation model entry to removed. required Source code in src/cplus_plugin/conf.py 931 932 933 934 935 936 937 938 939 def remove_implementation_model ( self , implementation_model_uuid : str ): \"\"\"Removes an implementation model settings entry using the UUID. :param implementation_model_uuid: Unique identifier of the implementation model entry to removed. :type implementation_model_uuid: str \"\"\" if self . get_implementation_model ( implementation_model_uuid ) is not None : self . remove ( f \" { self . IMPLEMENTATION_MODEL_BASE } / { implementation_model_uuid } \" )","title":"remove_implementation_model()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.remove_ncs_pathway","text":"remove_ncs_pathway ( ncs_uuid ) Removes an NCS pathway settings entry using the UUID. Parameters: Name Type Description Default ncs_uuid str Unique identifier of the NCS pathway entry to removed. required Source code in src/cplus_plugin/conf.py 777 778 779 780 781 782 783 784 785 def remove_ncs_pathway ( self , ncs_uuid : str ): \"\"\"Removes an NCS pathway settings entry using the UUID. :param ncs_uuid: Unique identifier of the NCS pathway entry to removed. :type ncs_uuid: str \"\"\" if self . get_ncs_pathway ( ncs_uuid ) is not None : self . remove ( f \" { self . NCS_PATHWAY_BASE } / { ncs_uuid } \" )","title":"remove_ncs_pathway()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.save_implementation_model","text":"save_implementation_model ( implementation_model ) Saves an implementation model object serialized to a json string indexed by the UUID. Parameters: Name Type Description Default implementation_model Union [ ImplementationModel , dict ] Implementation model object or attribute values in a dictionary which are then serialized to a JSON string. required Source code in src/cplus_plugin/conf.py 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 def save_implementation_model ( self , implementation_model : typing . Union [ ImplementationModel , dict ] ): \"\"\"Saves an implementation model object serialized to a json string indexed by the UUID. :param implementation_model: Implementation model object or attribute values in a dictionary which are then serialized to a JSON string. :type implementation_model: ImplementationModel, dict \"\"\" if isinstance ( implementation_model , ImplementationModel ): priority_layers = implementation_model . priority_layers ncs_pathways = [] for ncs in implementation_model . pathways : ncs_pathways . append ( str ( ncs . uuid )) implementation_model = layer_component_to_dict ( implementation_model ) implementation_model [ PRIORITY_LAYERS_SEGMENT ] = priority_layers implementation_model [ PATHWAYS_ATTRIBUTE ] = ncs_pathways if isinstance ( implementation_model , dict ): priority_layers = [] if implementation_model . get ( \"pwls_ids\" ) is not None : for layer_id in implementation_model . get ( \"pwls_ids\" , []): layer = self . get_priority_layer ( layer_id ) priority_layers . append ( layer ) if len ( priority_layers ) > 0 : implementation_model [ PRIORITY_LAYERS_SEGMENT ] = priority_layers implementation_model_str = json . dumps ( implementation_model ) implementation_model_uuid = implementation_model [ UUID_ATTRIBUTE ] implementation_model_root = self . _get_implementation_model_settings_base () with qgis_settings ( implementation_model_root ) as settings : settings . setValue ( implementation_model_uuid , implementation_model_str )","title":"save_implementation_model()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.save_ncs_pathway","text":"save_ncs_pathway ( ncs_pathway ) Saves an NCS pathway object serialized to a json string indexed by the UUID. Parameters: Name Type Description Default ncs_pathway Union [ NcsPathway , dict ] NCS pathway object or attribute values in a dictionary which are then serialized to a JSON string. required Source code in src/cplus_plugin/conf.py 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 def save_ncs_pathway ( self , ncs_pathway : typing . Union [ NcsPathway , dict ]): \"\"\"Saves an NCS pathway object serialized to a json string indexed by the UUID. :param ncs_pathway: NCS pathway object or attribute values in a dictionary which are then serialized to a JSON string. :type ncs_pathway: NcsPathway, dict \"\"\" if isinstance ( ncs_pathway , NcsPathway ): ncs_pathway = ncs_pathway_to_dict ( ncs_pathway ) ncs_str = json . dumps ( ncs_pathway ) ncs_uuid = ncs_pathway [ UUID_ATTRIBUTE ] ncs_root = self . _get_ncs_pathway_settings_base () with qgis_settings ( ncs_root ) as settings : settings . setValue ( ncs_uuid , ncs_str )","title":"save_ncs_pathway()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.save_priority_group","text":"save_priority_group ( priority_group ) Save the priority group into the plugin settings Parameters: Name Type Description Default priority_group str Priority group required Source code in src/cplus_plugin/conf.py 611 612 613 614 615 616 617 618 619 620 621 622 def save_priority_group ( self , priority_group ): \"\"\"Save the priority group into the plugin settings :param priority_group: Priority group :type priority_group: str \"\"\" settings_key = self . _get_priority_groups_settings_base ( priority_group [ \"uuid\" ]) with qgis_settings ( settings_key ) as settings : settings . setValue ( \"name\" , priority_group [ \"name\" ]) settings . setValue ( \"value\" , priority_group [ \"value\" ])","title":"save_priority_group()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.save_priority_layer","text":"save_priority_layer ( priority_layer ) Save the priority layer into the plugin settings. Updates the layer with new priority groups. Note: Emits priority_layers_changed signal Parameters: Name Type Description Default priority_layer dict Priority layer required Source code in src/cplus_plugin/conf.py 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 def save_priority_layer ( self , priority_layer ): \"\"\"Save the priority layer into the plugin settings. Updates the layer with new priority groups. Note: Emits priority_layers_changed signal :param priority_layer: Priority layer :type priority_layer: dict \"\"\" settings_key = self . _get_priority_layers_settings_base ( priority_layer [ \"uuid\" ]) with qgis_settings ( settings_key ) as settings : groups = priority_layer . get ( \"groups\" , []) settings . setValue ( \"name\" , priority_layer [ \"name\" ]) settings . setValue ( \"description\" , priority_layer [ \"description\" ]) settings . setValue ( \"path\" , priority_layer [ \"path\" ]) settings . setValue ( \"selected\" , priority_layer . get ( \"selected\" , False )) groups_key = f \" { settings_key } /groups\" with qgis_settings ( groups_key ) as groups_settings : for group_id in groups_settings . childGroups (): groups_settings . remove ( group_id ) for group in groups : group_key = f \" { groups_key } / { group [ 'name' ] } \" with qgis_settings ( group_key ) as group_settings : group_settings . setValue ( \"name\" , group [ \"name\" ]) group_settings . setValue ( \"value\" , group [ \"value\" ]) self . priority_layers_changed . emit ()","title":"save_priority_layer()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.save_scenario","text":"save_scenario ( scenario_settings ) Save the passed scenario settings into the plugin settings Parameters: Name Type Description Default scenario_settings ScenarioSettings Scenario settings required Source code in src/cplus_plugin/conf.py 229 230 231 232 233 234 235 236 237 238 239 240 241 242 def save_scenario ( self , scenario_settings ): \"\"\"Save the passed scenario settings into the plugin settings :param scenario_settings: Scenario settings :type scenario_settings: ScenarioSettings \"\"\" settings_key = self . _get_scenario_settings_base ( scenario_settings . uuid ) self . save_scenario_extent ( settings_key , scenario_settings . extent ) with qgis_settings ( settings_key ) as settings : settings . setValue ( \"name\" , scenario_settings . name ) settings . setValue ( \"description\" , scenario_settings . description ) settings . setValue ( \"uuid\" , scenario_settings . uuid )","title":"save_scenario()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.save_scenario_extent","text":"save_scenario_extent ( key , extent ) Saves the scenario extent into plugin settings using the provided settings group key. Parameters: Name Type Description Default key SpatialExtent Scenario extent required extent str Args: extent (SpatialExtent): Scenario extent key (str): QgsSettings group key QgsSettings group key required Source code in src/cplus_plugin/conf.py 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 def save_scenario_extent ( self , key , extent ): \"\"\"Saves the scenario extent into plugin settings using the provided settings group key. :param key: Scenario extent :type key: SpatialExtent :param extent: QgsSettings group key :type extent: str Args: extent (SpatialExtent): Scenario extent key (str): QgsSettings group key \"\"\" spatial_extent = extent . spatial . bbox spatial_key = f \" { key } /extent/spatial/\" with qgis_settings ( spatial_key ) as settings : settings . setValue ( \"bbox\" , spatial_extent )","title":"save_scenario_extent()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.set_current_priority_layer","text":"set_current_priority_layer ( identifier ) Set current priority layer Parameters: Name Type Description Default identifier str Priority layer identifier required Source code in src/cplus_plugin/conf.py 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 def set_current_priority_layer ( self , identifier ): \"\"\"Set current priority layer :param identifier: Priority layer identifier :type identifier: str \"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_LAYERS_GROUP_NAME } /\" ) as settings : for priority_layer in settings . childGroups (): settings_key = self . _get_priority_layers_settings_base ( identifier ) with qgis_settings ( settings_key ) as layer_settings : layer_settings . setValue ( \"selected\" , str ( priority_layer ) == str ( identifier ) )","title":"set_current_priority_layer()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.set_value","text":"set_value ( name , value ) Adds a new setting key and value on the plugin specific settings. Parameters: Name Type Description Default name str Name of setting key required value Any Value of the setting required Source code in src/cplus_plugin/conf.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 def set_value ( self , name : str , value ): \"\"\"Adds a new setting key and value on the plugin specific settings. :param name: Name of setting key :type name: str :param value: Value of the setting :type value: Any \"\"\" self . settings . setValue ( f \" { self . BASE_GROUP_NAME } / { name } \" , value ) if isinstance ( name , Settings ): name = name . value self . settings_updated . emit ( name , value )","title":"set_value()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.update_implementation_model","text":"update_implementation_model ( implementation_model ) Updates the attributes of the Implementation object in settings. On the path, the BASE_DIR in settings is used to reflect the absolute path of each NCS pathway layer. If BASE_DIR is empty then the NCS pathway setting will not be updated. Parameters: Name Type Description Default implementation_model ImplementationModel ImplementationModel object to be updated. required Source code in src/cplus_plugin/conf.py 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 def update_implementation_model ( self , implementation_model : ImplementationModel ): \"\"\"Updates the attributes of the Implementation object in settings. On the path, the BASE_DIR in settings is used to reflect the absolute path of each NCS pathway layer. If BASE_DIR is empty then the NCS pathway setting will not be updated. :param implementation_model: ImplementationModel object to be updated. :type implementation_model: ImplementationModel \"\"\" base_dir = self . get_value ( Settings . BASE_DIR ) if not base_dir : return # PWLs path update for layer in implementation_model . priority_layers : if layer in PRIORITY_LAYERS and base_dir not in layer . get ( PATH_ATTRIBUTE ): abs_pwl_path = ( f \" { base_dir } / { PRIORITY_LAYERS_SEGMENT } /\" f \" { layer . get ( PATH_ATTRIBUTE ) } \" ) abs_pwl_path = str ( os . path . normpath ( abs_pwl_path )) layer [ PATH_ATTRIBUTE ] = abs_pwl_path # Remove then re-insert self . remove_implementation_model ( str ( implementation_model . uuid )) self . save_implementation_model ( implementation_model )","title":"update_implementation_model()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.update_implementation_models","text":"update_implementation_models () Updates the attributes of the avaialable implementation models Parameters: Name Type Description Default implementation_model ImplementationModel Implementation model object to be updated. required Source code in src/cplus_plugin/conf.py 920 921 922 923 924 925 926 927 928 929 def update_implementation_models ( self ): \"\"\"Updates the attributes of the avaialable implementation models :param implementation_model: Implementation model object to be updated. :type implementation_model: ImplementationModel \"\"\" models = self . get_all_implementation_models () for implementation_model in models : self . update_implementation_model ( implementation_model )","title":"update_implementation_models()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.update_ncs_pathway","text":"update_ncs_pathway ( ncs_pathway ) Updates the attributes of the NCS pathway object in settings. On the path, the BASE_DIR in settings is used to reflect the absolute path of each NCS pathway layer. If BASE_DIR is empty then the NCS pathway setting will not be updated, this only applies for default pathways. Parameters: Name Type Description Default ncs_pathway NcsPathway NCS pathway object to be updated. required Source code in src/cplus_plugin/conf.py 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 def update_ncs_pathway ( self , ncs_pathway : NcsPathway ): \"\"\"Updates the attributes of the NCS pathway object in settings. On the path, the BASE_DIR in settings is used to reflect the absolute path of each NCS pathway layer. If BASE_DIR is empty then the NCS pathway setting will not be updated, this only applies for default pathways. :param ncs_pathway: NCS pathway object to be updated. :type ncs_pathway: NcsPathway \"\"\" base_dir = self . get_value ( Settings . BASE_DIR ) if not base_dir : return # Pathway location for default pathway if not ncs_pathway . user_defined : p = Path ( ncs_pathway . path ) # Only update if path does not exist otherwise # fallback to check under base directory. if not p . exists (): abs_path = f \" { base_dir } / { NCS_PATHWAY_SEGMENT } /\" f \" { p . name } \" abs_path = str ( os . path . normpath ( abs_path )) ncs_pathway . path = abs_path # Carbon location abs_carbon_paths = [] for cb_path in ncs_pathway . carbon_paths : cp = Path ( cb_path ) # Similarly, if the given carbon path does not exist then try # to use the default one in the ncs_carbon directory. if not cp . exists (): abs_carbon_path = f \" { base_dir } / { NCS_CARBON_SEGMENT } /\" f \" { cp . name } \" abs_carbon_path = str ( os . path . normpath ( abs_carbon_path )) abs_carbon_paths . append ( abs_carbon_path ) else : abs_carbon_paths . append ( cb_path ) ncs_pathway . carbon_paths = abs_carbon_paths # Remove then re-insert self . remove_ncs_pathway ( str ( ncs_pathway . uuid )) self . save_ncs_pathway ( ncs_pathway )","title":"update_ncs_pathway()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.update_ncs_pathways","text":"update_ncs_pathways () Updates the path attribute of all NCS pathway settings based on the BASE_DIR settings to reflect the absolute path of each NCS pathway layer. If BASE_DIR is empty then the NCS pathway settings will not be updated. Source code in src/cplus_plugin/conf.py 722 723 724 725 726 727 728 729 730 731 def update_ncs_pathways ( self ): \"\"\"Updates the path attribute of all NCS pathway settings based on the BASE_DIR settings to reflect the absolute path of each NCS pathway layer. If BASE_DIR is empty then the NCS pathway settings will not be updated. \"\"\" ncs_pathways = self . get_all_ncs_pathways () for ncs in ncs_pathways : self . update_ncs_pathway ( ncs )","title":"update_ncs_pathways()"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.qgis_settings","text":"qgis_settings ( group_root , settings = None ) Context manager to help defining groups when creating QgsSettings. :yields: Instance of the created settings :ytype: QgsSettings Parameters: Name Type Description Default group_root str Name of the root group for the settings required settings QgsSettings QGIS settings to use None Source code in src/cplus_plugin/conf.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 @contextlib . contextmanager def qgis_settings ( group_root : str , settings = None ): \"\"\"Context manager to help defining groups when creating QgsSettings. :param group_root: Name of the root group for the settings :type group_root: str :param settings: QGIS settings to use :type settings: QgsSettings :yields: Instance of the created settings :ytype: QgsSettings \"\"\" if settings is None : settings = QgsSettings () settings . beginGroup ( group_root ) try : yield settings finally : settings . endGroup ()","title":"qgis_settings()"},{"location":"developer/api/core/api_main/","text":"Main QGIS CPLUS Plugin Implementation. Source code in src/cplus_plugin/main.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 def __init__ ( self , iface ): self . iface = iface self . plugin_dir = os . path . dirname ( __file__ ) locale = QgsSettings () . value ( \"locale/userLocale\" )[ 0 : 2 ] locale_path = os . path . join ( self . plugin_dir , \"i18n\" , \"CPLUS {} .qm\" . format ( locale )) if os . path . exists ( locale_path ): self . translator = QTranslator () self . translator . load ( locale_path ) QCoreApplication . installTranslator ( self . translator ) # Declare instance attributes self . actions = [] self . pluginIsActive = False self . menu = QMenu ( \"&CPLUS\" ) self . menu . setIcon ( QIcon ( ICON_PATH )) self . raster_menu = self . iface . rasterMenu () self . raster_menu . addMenu ( self . menu ) self . toolbar = self . iface . addToolBar ( \"Open CPLUS\" ) self . toolbar . setObjectName ( \"CPLUS\" ) self . toolButton = QToolButton () self . toolButton . setMenu ( QMenu ()) self . toolButton . setPopupMode ( QToolButton . MenuButtonPopup ) self . toolBtnAction = self . toolbar . addWidget ( self . toolButton ) self . actions . append ( self . toolBtnAction ) if not settings_manager . get_value ( \"default_priority_layers_set\" , default = False , setting_type = bool ): create_priority_layers () self . main_widget = QgisCplusMain ( iface = self . iface , parent = self . iface . mainWindow () ) self . options_factory = None add_action add_action ( icon_path , text , callback , enabled_flag = True , add_to_menu = True , add_to_web_menu = True , add_to_toolbar = True , set_as_default_action = False , status_tip = None , whats_this = None , parent = None ) Add a toolbar icon to the toolbar. Parameters: Name Type Description Default icon_path str Path to the icon for this action required text str Text that should be shown in menu items for this action required callback function Function to be called when the action is triggered required enabled_flag bool A flag indicating if the action should be enabled True add_to_menu bool Flag indicating whether the action should also be added to the menu True add_to_web_menu bool Flag indicating whether the action should also be added to the web menu True add_to_toolbar bool Flag indicating whether the action should also be added to the toolbar True set_as_default_action bool Flag indicating whether the action is the default action False status_tip str Optional text to show in a popup when mouse pointer hovers over the action None parent QWidget Parent widget for the new action None whats_this str Optional text to show in the status bar when the mouse pointer hovers over the action None Returns: Type Description QAction The action that was created Source code in src/cplus_plugin/main.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 def add_action ( self , icon_path , text , callback , enabled_flag = True , add_to_menu = True , add_to_web_menu = True , add_to_toolbar = True , set_as_default_action = False , status_tip = None , whats_this = None , parent = None , ): \"\"\"Add a toolbar icon to the toolbar. :param icon_path: Path to the icon for this action :type icon_path: str :param text: Text that should be shown in menu items for this action :type text: str :param callback: Function to be called when the action is triggered :type callback: function :param enabled_flag: A flag indicating if the action should be enabled :type enabled_flag: bool :param add_to_menu: Flag indicating whether the action should also be added to the menu :type add_to_menu: bool :param add_to_web_menu: Flag indicating whether the action should also be added to the web menu :type add_to_web_menu: bool :param add_to_toolbar: Flag indicating whether the action should also be added to the toolbar :type add_to_toolbar: bool :param set_as_default_action: Flag indicating whether the action is the default action :type set_as_default_action: bool :param status_tip: Optional text to show in a popup when mouse pointer hovers over the action :type status_tip: str :param parent: Parent widget for the new action :type parent: QWidget :param whats_this: Optional text to show in the status bar when the mouse pointer hovers over the action :type whats_this: str :returns: The action that was created :rtype: QAction \"\"\" icon = QIcon ( icon_path ) action = QAction ( icon , text , parent ) action . triggered . connect ( callback ) action . setEnabled ( enabled_flag ) if status_tip is not None : action . setStatusTip ( status_tip ) if whats_this is not None : action . setWhatsThis ( whats_this ) if add_to_menu : self . menu . addAction ( action ) # If we want to read this # if add_to_web_menu: # self.iface.addPluginToWebMenu(self.menu, action) if add_to_toolbar : self . toolButton . menu () . addAction ( action ) if set_as_default_action : self . toolButton . setDefaultAction ( action ) if add_to_menu : self . menu . addAction ( action ) self . actions . append ( action ) return action initGui initGui () Create the menu entries and toolbar icons inside the QGIS GUI. Source code in src/cplus_plugin/main.py 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 def initGui ( self ): \"\"\"Create the menu entries and toolbar icons inside the QGIS GUI.\"\"\" self . add_action ( ICON_PATH , text = self . tr ( \"CPLUS\" ), callback = self . run , parent = self . iface . mainWindow (), set_as_default_action = True , ) self . add_action ( os . path . join ( os . path . dirname ( __file__ ), \"icons\" , \"settings.svg\" ), text = self . tr ( \"Settings\" ), callback = self . run_settings , parent = self . iface . mainWindow (), status_tip = self . tr ( \"CPLUS Settings\" ), ) self . add_action ( os . path . join ( os . path . dirname ( __file__ ), \"icons\" , \"mActionHelpContents_green.svg\" ), text = self . tr ( \"Help\" ), callback = self . open_help , parent = self . iface . mainWindow (), status_tip = self . tr ( \"CPLUS Help\" ), ) self . add_action ( os . path . join ( os . path . dirname ( __file__ ), \"icons\" , \"info_green.svg\" ), text = self . tr ( \"About\" ), callback = self . open_about , parent = self . iface . mainWindow (), status_tip = self . tr ( \"CPLUS About\" ), ) # Initialize default report settings initialize_report_settings () # Adds the settings to the QGIS options panel self . options_factory = CplusOptionsFactory () self . iface . registerOptionsWidgetFactory ( self . options_factory ) # Initialize default model components initialize_model_settings () # Register custom layout items self . register_layout_items () # Register custom report variables when a layout is opened self . iface . layoutDesignerOpened . connect ( self . on_layout_designer_opened ) onClosePlugin onClosePlugin () Cleanup necessary items here when plugin widget is closed. Source code in src/cplus_plugin/main.py 266 267 268 def onClosePlugin ( self ): \"\"\"Cleanup necessary items here when plugin widget is closed.\"\"\" self . pluginIsActive = False on_layout_designer_opened on_layout_designer_opened ( designer ) Register custom report variables in a print layout only. Source code in src/cplus_plugin/main.py 298 299 300 301 302 303 def on_layout_designer_opened ( self , designer : QgsLayoutDesignerInterface ): \"\"\"Register custom report variables in a print layout only.\"\"\" layout_type = designer . masterLayout () . layoutType () if layout_type == QgsMasterLayoutInterface . PrintLayout : layout = designer . layout () report_manager . register_variables ( layout ) open_about open_about () Opens the about documentation for the plugin in a browser Source code in src/cplus_plugin/main.py 321 322 323 def open_about ( self ): \"\"\"Opens the about documentation for the plugin in a browser\"\"\" open_documentation ( ABOUT_DOCUMENTATION_SITE ) open_help open_help () Opens documentation home page for the plugin in a browser Source code in src/cplus_plugin/main.py 317 318 319 def open_help ( self ): \"\"\"Opens documentation home page for the plugin in a browser\"\"\" open_documentation ( DOCUMENTATION_SITE ) register_layout_items register_layout_items () Register custom layout items. Source code in src/cplus_plugin/main.py 305 306 307 308 309 310 311 312 313 314 315 def register_layout_items ( self ): \"\"\"Register custom layout items.\"\"\" # Register map layout item QgsApplication . layoutItemRegistry () . addLayoutItemType ( CplusMapRepeatItemLayoutItemMetadata () ) # Register map GUI metadata item_gui_registry = QgsGui . layoutItemGuiRegistry () map_item_gui_metadata = CplusMapLayoutItemGuiMetadata () item_gui_registry . addLayoutItemGuiMetadata ( map_item_gui_metadata ) run run () Creates the main widget for the plugin. Source code in src/cplus_plugin/main.py 281 282 283 284 285 286 287 288 289 290 291 292 def run ( self ): \"\"\"Creates the main widget for the plugin.\"\"\" if self . main_widget is None : self . main_widget = QgisCplusMain ( iface = self . iface , parent = self . iface . mainWindow () ) self . iface . addDockWidget ( Qt . RightDockWidgetArea , self . main_widget ) self . main_widget . show () if not self . pluginIsActive : self . pluginIsActive = True run_settings run_settings () Options the CPLUS settings in the QGIS options dialog. Source code in src/cplus_plugin/main.py 294 295 296 def run_settings ( self ): \"\"\"Options the CPLUS settings in the QGIS options dialog.\"\"\" self . iface . showOptionsDialog ( currentPage = OPTIONS_TITLE ) tr tr ( message ) Get the translation for a string using Qt translation API. We implement this ourselves since we do not inherit QObject. Parameters: Name Type Description Default message str String for translation required Returns: Type Description QString Translated version of the message Source code in src/cplus_plugin/main.py 117 118 119 120 121 122 123 124 125 126 127 128 def tr ( self , message ) -> str : \"\"\"Get the translation for a string using Qt translation API. We implement this ourselves since we do not inherit QObject. :param message: String for translation :type message: str :returns: Translated version of the message :rtype: QString \"\"\" # noinspection PyTypeChecker,PyArgumentList,PyCallByClass return QCoreApplication . translate ( \"CPLUS\" , message ) unload unload () Removes the plugin menu item and icon from QGIS GUI. Source code in src/cplus_plugin/main.py 270 271 272 273 274 275 276 277 278 279 def unload ( self ): \"\"\"Removes the plugin menu item and icon from QGIS GUI.\"\"\" try : for action in self . actions : self . iface . removePluginMenu ( self . tr ( \"&CPLUS\" ), action ) self . iface . removePluginWebMenu ( self . tr ( \"&CPLUS\" ), action ) self . iface . removeToolBarIcon ( action ) except Exception as e : pass","title":"Main"},{"location":"developer/api/core/api_main/#main","text":"QGIS CPLUS Plugin Implementation. Source code in src/cplus_plugin/main.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 def __init__ ( self , iface ): self . iface = iface self . plugin_dir = os . path . dirname ( __file__ ) locale = QgsSettings () . value ( \"locale/userLocale\" )[ 0 : 2 ] locale_path = os . path . join ( self . plugin_dir , \"i18n\" , \"CPLUS {} .qm\" . format ( locale )) if os . path . exists ( locale_path ): self . translator = QTranslator () self . translator . load ( locale_path ) QCoreApplication . installTranslator ( self . translator ) # Declare instance attributes self . actions = [] self . pluginIsActive = False self . menu = QMenu ( \"&CPLUS\" ) self . menu . setIcon ( QIcon ( ICON_PATH )) self . raster_menu = self . iface . rasterMenu () self . raster_menu . addMenu ( self . menu ) self . toolbar = self . iface . addToolBar ( \"Open CPLUS\" ) self . toolbar . setObjectName ( \"CPLUS\" ) self . toolButton = QToolButton () self . toolButton . setMenu ( QMenu ()) self . toolButton . setPopupMode ( QToolButton . MenuButtonPopup ) self . toolBtnAction = self . toolbar . addWidget ( self . toolButton ) self . actions . append ( self . toolBtnAction ) if not settings_manager . get_value ( \"default_priority_layers_set\" , default = False , setting_type = bool ): create_priority_layers () self . main_widget = QgisCplusMain ( iface = self . iface , parent = self . iface . mainWindow () ) self . options_factory = None","title":"Main"},{"location":"developer/api/core/api_main/#src.cplus_plugin.main.QgisCplus.add_action","text":"add_action ( icon_path , text , callback , enabled_flag = True , add_to_menu = True , add_to_web_menu = True , add_to_toolbar = True , set_as_default_action = False , status_tip = None , whats_this = None , parent = None ) Add a toolbar icon to the toolbar. Parameters: Name Type Description Default icon_path str Path to the icon for this action required text str Text that should be shown in menu items for this action required callback function Function to be called when the action is triggered required enabled_flag bool A flag indicating if the action should be enabled True add_to_menu bool Flag indicating whether the action should also be added to the menu True add_to_web_menu bool Flag indicating whether the action should also be added to the web menu True add_to_toolbar bool Flag indicating whether the action should also be added to the toolbar True set_as_default_action bool Flag indicating whether the action is the default action False status_tip str Optional text to show in a popup when mouse pointer hovers over the action None parent QWidget Parent widget for the new action None whats_this str Optional text to show in the status bar when the mouse pointer hovers over the action None Returns: Type Description QAction The action that was created Source code in src/cplus_plugin/main.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 def add_action ( self , icon_path , text , callback , enabled_flag = True , add_to_menu = True , add_to_web_menu = True , add_to_toolbar = True , set_as_default_action = False , status_tip = None , whats_this = None , parent = None , ): \"\"\"Add a toolbar icon to the toolbar. :param icon_path: Path to the icon for this action :type icon_path: str :param text: Text that should be shown in menu items for this action :type text: str :param callback: Function to be called when the action is triggered :type callback: function :param enabled_flag: A flag indicating if the action should be enabled :type enabled_flag: bool :param add_to_menu: Flag indicating whether the action should also be added to the menu :type add_to_menu: bool :param add_to_web_menu: Flag indicating whether the action should also be added to the web menu :type add_to_web_menu: bool :param add_to_toolbar: Flag indicating whether the action should also be added to the toolbar :type add_to_toolbar: bool :param set_as_default_action: Flag indicating whether the action is the default action :type set_as_default_action: bool :param status_tip: Optional text to show in a popup when mouse pointer hovers over the action :type status_tip: str :param parent: Parent widget for the new action :type parent: QWidget :param whats_this: Optional text to show in the status bar when the mouse pointer hovers over the action :type whats_this: str :returns: The action that was created :rtype: QAction \"\"\" icon = QIcon ( icon_path ) action = QAction ( icon , text , parent ) action . triggered . connect ( callback ) action . setEnabled ( enabled_flag ) if status_tip is not None : action . setStatusTip ( status_tip ) if whats_this is not None : action . setWhatsThis ( whats_this ) if add_to_menu : self . menu . addAction ( action ) # If we want to read this # if add_to_web_menu: # self.iface.addPluginToWebMenu(self.menu, action) if add_to_toolbar : self . toolButton . menu () . addAction ( action ) if set_as_default_action : self . toolButton . setDefaultAction ( action ) if add_to_menu : self . menu . addAction ( action ) self . actions . append ( action ) return action","title":"add_action()"},{"location":"developer/api/core/api_main/#src.cplus_plugin.main.QgisCplus.initGui","text":"initGui () Create the menu entries and toolbar icons inside the QGIS GUI. Source code in src/cplus_plugin/main.py 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 def initGui ( self ): \"\"\"Create the menu entries and toolbar icons inside the QGIS GUI.\"\"\" self . add_action ( ICON_PATH , text = self . tr ( \"CPLUS\" ), callback = self . run , parent = self . iface . mainWindow (), set_as_default_action = True , ) self . add_action ( os . path . join ( os . path . dirname ( __file__ ), \"icons\" , \"settings.svg\" ), text = self . tr ( \"Settings\" ), callback = self . run_settings , parent = self . iface . mainWindow (), status_tip = self . tr ( \"CPLUS Settings\" ), ) self . add_action ( os . path . join ( os . path . dirname ( __file__ ), \"icons\" , \"mActionHelpContents_green.svg\" ), text = self . tr ( \"Help\" ), callback = self . open_help , parent = self . iface . mainWindow (), status_tip = self . tr ( \"CPLUS Help\" ), ) self . add_action ( os . path . join ( os . path . dirname ( __file__ ), \"icons\" , \"info_green.svg\" ), text = self . tr ( \"About\" ), callback = self . open_about , parent = self . iface . mainWindow (), status_tip = self . tr ( \"CPLUS About\" ), ) # Initialize default report settings initialize_report_settings () # Adds the settings to the QGIS options panel self . options_factory = CplusOptionsFactory () self . iface . registerOptionsWidgetFactory ( self . options_factory ) # Initialize default model components initialize_model_settings () # Register custom layout items self . register_layout_items () # Register custom report variables when a layout is opened self . iface . layoutDesignerOpened . connect ( self . on_layout_designer_opened )","title":"initGui()"},{"location":"developer/api/core/api_main/#src.cplus_plugin.main.QgisCplus.onClosePlugin","text":"onClosePlugin () Cleanup necessary items here when plugin widget is closed. Source code in src/cplus_plugin/main.py 266 267 268 def onClosePlugin ( self ): \"\"\"Cleanup necessary items here when plugin widget is closed.\"\"\" self . pluginIsActive = False","title":"onClosePlugin()"},{"location":"developer/api/core/api_main/#src.cplus_plugin.main.QgisCplus.on_layout_designer_opened","text":"on_layout_designer_opened ( designer ) Register custom report variables in a print layout only. Source code in src/cplus_plugin/main.py 298 299 300 301 302 303 def on_layout_designer_opened ( self , designer : QgsLayoutDesignerInterface ): \"\"\"Register custom report variables in a print layout only.\"\"\" layout_type = designer . masterLayout () . layoutType () if layout_type == QgsMasterLayoutInterface . PrintLayout : layout = designer . layout () report_manager . register_variables ( layout )","title":"on_layout_designer_opened()"},{"location":"developer/api/core/api_main/#src.cplus_plugin.main.QgisCplus.open_about","text":"open_about () Opens the about documentation for the plugin in a browser Source code in src/cplus_plugin/main.py 321 322 323 def open_about ( self ): \"\"\"Opens the about documentation for the plugin in a browser\"\"\" open_documentation ( ABOUT_DOCUMENTATION_SITE )","title":"open_about()"},{"location":"developer/api/core/api_main/#src.cplus_plugin.main.QgisCplus.open_help","text":"open_help () Opens documentation home page for the plugin in a browser Source code in src/cplus_plugin/main.py 317 318 319 def open_help ( self ): \"\"\"Opens documentation home page for the plugin in a browser\"\"\" open_documentation ( DOCUMENTATION_SITE )","title":"open_help()"},{"location":"developer/api/core/api_main/#src.cplus_plugin.main.QgisCplus.register_layout_items","text":"register_layout_items () Register custom layout items. Source code in src/cplus_plugin/main.py 305 306 307 308 309 310 311 312 313 314 315 def register_layout_items ( self ): \"\"\"Register custom layout items.\"\"\" # Register map layout item QgsApplication . layoutItemRegistry () . addLayoutItemType ( CplusMapRepeatItemLayoutItemMetadata () ) # Register map GUI metadata item_gui_registry = QgsGui . layoutItemGuiRegistry () map_item_gui_metadata = CplusMapLayoutItemGuiMetadata () item_gui_registry . addLayoutItemGuiMetadata ( map_item_gui_metadata )","title":"register_layout_items()"},{"location":"developer/api/core/api_main/#src.cplus_plugin.main.QgisCplus.run","text":"run () Creates the main widget for the plugin. Source code in src/cplus_plugin/main.py 281 282 283 284 285 286 287 288 289 290 291 292 def run ( self ): \"\"\"Creates the main widget for the plugin.\"\"\" if self . main_widget is None : self . main_widget = QgisCplusMain ( iface = self . iface , parent = self . iface . mainWindow () ) self . iface . addDockWidget ( Qt . RightDockWidgetArea , self . main_widget ) self . main_widget . show () if not self . pluginIsActive : self . pluginIsActive = True","title":"run()"},{"location":"developer/api/core/api_main/#src.cplus_plugin.main.QgisCplus.run_settings","text":"run_settings () Options the CPLUS settings in the QGIS options dialog. Source code in src/cplus_plugin/main.py 294 295 296 def run_settings ( self ): \"\"\"Options the CPLUS settings in the QGIS options dialog.\"\"\" self . iface . showOptionsDialog ( currentPage = OPTIONS_TITLE )","title":"run_settings()"},{"location":"developer/api/core/api_main/#src.cplus_plugin.main.QgisCplus.tr","text":"tr ( message ) Get the translation for a string using Qt translation API. We implement this ourselves since we do not inherit QObject. Parameters: Name Type Description Default message str String for translation required Returns: Type Description QString Translated version of the message Source code in src/cplus_plugin/main.py 117 118 119 120 121 122 123 124 125 126 127 128 def tr ( self , message ) -> str : \"\"\"Get the translation for a string using Qt translation API. We implement this ourselves since we do not inherit QObject. :param message: String for translation :type message: str :returns: Translated version of the message :rtype: QString \"\"\" # noinspection PyTypeChecker,PyArgumentList,PyCallByClass return QCoreApplication . translate ( \"CPLUS\" , message )","title":"tr()"},{"location":"developer/api/core/api_main/#src.cplus_plugin.main.QgisCplus.unload","text":"unload () Removes the plugin menu item and icon from QGIS GUI. Source code in src/cplus_plugin/main.py 270 271 272 273 274 275 276 277 278 279 def unload ( self ): \"\"\"Removes the plugin menu item and icon from QGIS GUI.\"\"\" try : for action in self . actions : self . iface . removePluginMenu ( self . tr ( \"&CPLUS\" ), action ) self . iface . removePluginWebMenu ( self . tr ( \"&CPLUS\" ), action ) self . iface . removeToolBarIcon ( action ) except Exception as e : pass","title":"unload()"},{"location":"developer/api/core/api_reports_generator/","text":"Report Generator CPLUS Report generator. ReportGenerator ReportGenerator ( context , feedback = None ) Generator for CPLUS reports. Source code in src/cplus_plugin/lib/reports/generator.py 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 def __init__ ( self , context : ReportContext , feedback : QgsFeedback = None ): self . _context = context self . _feedback = context . feedback or feedback self . _error_messages : typing . List [ str ] = [] self . _layout = None self . _project = None self . _variable_register = LayoutVariableRegister () self . _report_output_dir = \"\" self . _output_layout_path = \"\" self . _repeat_page = None self . _repeat_page_num = - 1 self . _repeat_item = None self . _reference_layer_group = None self . _scenario_layer = None self . _area_processing_feedback = None if self . _feedback : self . _feedback . canceled . connect ( self . _on_feedback_cancelled ) self . _area_calculation_progress_reference = 40 context property context Returns the report context used by the generator. Returns: Type Description ReportContext Report context object used by the generator. feedback property feedback Returns the feedback object for process update and cancellation. Returns: Type Description QgsFeedback Feedback object or None if not specified. layout property layout Returns the layout object used to generate the report. Returns: Type Description QgsPrintLayout The layout object used to generate the report or None if the process was not successful. output_dir property output_dir Creates, if it does not exist, the output directory where the analysis reports will be saved. This is relative to the base directory and outputs sub-folder. Returns: Type Description str Output directory where the analysis reports will be saved. output_layout_path property output_layout_path Absolute path to a temporary file containing the layout as a QPT file. When this object is used within a QgsTask, it is recommended to use this layout path to reconstruct the layout rather calling the layout attribute since it was created in a separate thread. Returns: Type Description str Path to the layout template file. repeat_page property repeat_page Returns the page item that will be repeated based on the number of implementation models in the scenario. A repeat page is a layout page item that contains the first instance of a CplusMapRepeatItem. Returns: Type Description QgsLayoutItemPage Page item containing a CplusMapRepeatItem or None if not found. duplicate_repeat_page duplicate_repeat_page ( position ) Duplicates the repeat page and adds it to the layout at the given position. Parameters: Name Type Description Default position int Zero-based position to insert the duplicated page. If the position is greater than the number of pages, then the duplicated page will be inserted at the end of the layout. required Returns: Type Description bool True if the page was successfully duplicated else False. Source code in src/cplus_plugin/lib/reports/generator.py 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 def duplicate_repeat_page ( self , position : int ) -> bool : \"\"\"Duplicates the repeat page and adds it to the layout at the given position. :param position: Zero-based position to insert the duplicated page. If the position is greater than the number of pages, then the duplicated page will be inserted at the end of the layout. :type position: int :returns: True if the page was successfully duplicated else False. :rtype: bool \"\"\" if self . _repeat_page is None : return False if self . _layout is None : return False if self . _repeat_page_num == - 1 : tr_msg = \"Repeat page not found in page collection\" self . _error_messages . append ( tr_msg ) return False new_page = QgsLayoutItemPage ( self . _layout ) new_page . attemptResize ( self . _repeat_page . sizeWithUnits ()) new_page . setPageStyleSymbol ( self . _repeat_page . pageStyleSymbol () . clone ()) # Insert empty repeat page at the given position if position < self . _layout . pageCollection () . pageCount (): self . _layout . pageCollection () . insertPage ( new_page , position ) else : # Add at the end position = self . _layout . pageCollection () . pageCount () self . _layout . pageCollection () . addPage ( new_page ) doc = QtXml . QDomDocument () el = doc . createElement ( \"CopyItems\" ) ctx = QgsReadWriteContext () repeat_page_items = self . _layout . pageCollection () . itemsOnPage ( self . _repeat_page_num ) for item in repeat_page_items : item . writeXml ( el , doc , ctx ) doc . appendChild ( el ) # Clear element identifier references nodes = doc . elementsByTagName ( \"LayoutItem\" ) for n in range ( nodes . count ()): node = nodes . at ( n ) if node . isElement (): node . toElement () . removeAttribute ( \"uuid\" ) page_ref_point = self . _layout . pageCollection () . pagePositionToLayoutPosition ( position , QgsLayoutPoint ( 0 , 0 ) ) _ = self . _layout . addItemsFromXml ( el , doc , ctx , page_ref_point , True ) return True export_to_pdf export_to_pdf () Exports the layout to a PDF file in the output directory using the layout name as the file name. Returns: Type Description bool True if the layout was successfully exported else False. Source code in src/cplus_plugin/lib/reports/generator.py 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 def export_to_pdf ( self ) -> bool : \"\"\"Exports the layout to a PDF file in the output directory using the layout name as the file name. :returns: True if the layout was successfully exported else False. :rtype: bool \"\"\" if self . _layout is None or self . _project is None or not self . output_dir : return False exporter = QgsLayoutExporter ( self . _layout ) pdf_path = f \" { self . output_dir } / { self . _layout . name () } .pdf\" result = exporter . exportToPdf ( pdf_path , QgsLayoutExporter . PdfExportSettings ()) if result == QgsLayoutExporter . ExportResult . Success : return True else : tr_msg = tr ( \"Could not export layout to PDF\" ) self . _error_messages . append ( f \" { tr_msg } { pdf_path } .\" ) return False run run () Initiates the report generation process and returns a result which contains information on whether the process succeeded or failed. Returns: Type Description ReportResult The result of the report generation process. Source code in src/cplus_plugin/lib/reports/generator.py 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 def run ( self ) -> ReportResult : \"\"\"Initiates the report generation process and returns a result which contains information on whether the process succeeded or failed. :returns: The result of the report generation process. :rtype: ReportResult \"\"\" try : return self . _run () except Exception as ex : # Last resort to capture general exceptions. exc_info = \"\" . join ( traceback . TracebackException . from_exception ( ex ) . format ()) self . _error_messages . append ( exc_info ) return self . _get_failed_result () set_label_font classmethod set_label_font ( label , size , bold = False , italic = False ) Set font properties of the given layout label item. Parameters: Name Type Description Default label QgsLayoutItemLabel Label item whose font properties will be updated. required size float Point size of the font. required bold bool True if font is to be bold, else False (default). False italic bool True if font is to be in italics, else False (default). False Source code in src/cplus_plugin/lib/reports/generator.py 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 @classmethod def set_label_font ( cls , label : QgsLayoutItemLabel , size : float , bold : bool = False , italic : bool = False , ): \"\"\"Set font properties of the given layout label item. :param label: Label item whose font properties will be updated. :type label: QgsLayoutItemLabel :param size: Point size of the font. :type size: int :param bold: True if font is to be bold, else False (default). :type bold: bool :param italic: True if font is to be in italics, else False (default). :type italic: bool \"\"\" font = get_report_font ( size , bold , italic ) version = Qgis . versionInt () # Text format size unit if version < 33000 : unit_type = QgsUnitTypes . RenderUnit . RenderPoints else : unit_type = Qgis . RenderUnit . Points # Label font setting option if version < 32400 : label . setFont ( font ) else : txt_format = QgsTextFormat () txt_format . setFont ( font ) txt_format . setSize ( size ) txt_format . setSizeUnit ( unit_type ) label . setTextFormat ( txt_format ) label . refresh () ReportGeneratorTask ReportGeneratorTask ( description , context ) Bases: QgsTask Proxy class for initiating the report generation process. Source code in src/cplus_plugin/lib/reports/generator.py 69 70 71 72 73 74 75 def __init__ ( self , description : str , context : ReportContext ): super () . __init__ ( description ) self . _context = context self . _result = None self . _generator = ReportGenerator ( self . _context , self . _context . feedback ) self . layout_manager = QgsProject . instance () . layoutManager () self . layout_manager . layoutAdded . connect ( self . _on_layout_added ) context property context Returns the report context used by the generator. Returns: Type Description ReportContext Report context object used by the generator. result property result Returns the result object which contains information on whether the process succeeded or failed. Returns: Type Description ReportResult The result of the report generation process. cancel cancel () Cancel the report generation task. Source code in src/cplus_plugin/lib/reports/generator.py 96 97 98 99 100 101 def cancel ( self ): \"\"\"Cancel the report generation task.\"\"\" if self . _context . feedback : self . _context . feedback . cancel () super () . cancel () finished finished ( result ) If successful, add the layout to the project. Parameters: Name Type Description Default result bool Flag indicating if the result of the report generation process. True if successful, else False. required Source code in src/cplus_plugin/lib/reports/generator.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 def finished ( self , result : bool ): \"\"\"If successful, add the layout to the project. :param result: Flag indicating if the result of the report generation process. True if successful, else False. :type result: bool \"\"\" if result : log ( f \"Successfully generated the report for \" f \" { self . _context . scenario . name } scenario.\" ) layout_path = self . _generator . output_layout_path if not layout_path : log ( \"Output layout could not be saved.\" , info = False ) return feedback = self . _context . feedback project = QgsProject . instance () layout = _load_layout_from_file ( layout_path , project ) if layout is None : log ( \"Could not load layout from file.\" , info = False ) return # Zoom the extents of map items in the layout then export to PDF self . _zoom_map_items_to_current_extents ( layout ) project . layoutManager () . addLayout ( layout ) if feedback is not None : feedback . setProgress ( 100 ) else : log ( f \"Error occurred when generating the \" f \"report for { self . _context . scenario . name } \" f \"scenario. See details below:\" , info = False , ) for err in self . _result . messages : err_msg = f \" { self . _context . scenario . name } - { err } \" log ( err_msg , info = False ) run run () Initiates the report generation process and returns a result indicating whether the process succeeded or failed. Returns: Type Description bool True if the report generation process succeeded or False it if failed. Source code in src/cplus_plugin/lib/reports/generator.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def run ( self ) -> bool : \"\"\"Initiates the report generation process and returns a result indicating whether the process succeeded or failed. :returns: True if the report generation process succeeded or False it if failed. :rtype: bool \"\"\" if self . isCanceled (): return False if self . _context . project_file : self . _result = self . _generator . run () else : msg = tr ( \"Unable to serialize current project for \" \"report generation.\" ) msgs : typing . List [ str ] = [ msg ] self . _result = ReportResult ( False , self . _context . scenario . uuid , \"\" , tuple ( msgs ) ) return self . _result . success","title":"Generator"},{"location":"developer/api/core/api_reports_generator/#report-generator","text":"CPLUS Report generator.","title":"Report Generator"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ReportGenerator","text":"ReportGenerator ( context , feedback = None ) Generator for CPLUS reports. Source code in src/cplus_plugin/lib/reports/generator.py 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 def __init__ ( self , context : ReportContext , feedback : QgsFeedback = None ): self . _context = context self . _feedback = context . feedback or feedback self . _error_messages : typing . List [ str ] = [] self . _layout = None self . _project = None self . _variable_register = LayoutVariableRegister () self . _report_output_dir = \"\" self . _output_layout_path = \"\" self . _repeat_page = None self . _repeat_page_num = - 1 self . _repeat_item = None self . _reference_layer_group = None self . _scenario_layer = None self . _area_processing_feedback = None if self . _feedback : self . _feedback . canceled . connect ( self . _on_feedback_cancelled ) self . _area_calculation_progress_reference = 40","title":"ReportGenerator"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ReportGenerator.context","text":"context Returns the report context used by the generator. Returns: Type Description ReportContext Report context object used by the generator.","title":"context"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ReportGenerator.feedback","text":"feedback Returns the feedback object for process update and cancellation. Returns: Type Description QgsFeedback Feedback object or None if not specified.","title":"feedback"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ReportGenerator.layout","text":"layout Returns the layout object used to generate the report. Returns: Type Description QgsPrintLayout The layout object used to generate the report or None if the process was not successful.","title":"layout"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ReportGenerator.output_dir","text":"output_dir Creates, if it does not exist, the output directory where the analysis reports will be saved. This is relative to the base directory and outputs sub-folder. Returns: Type Description str Output directory where the analysis reports will be saved.","title":"output_dir"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ReportGenerator.output_layout_path","text":"output_layout_path Absolute path to a temporary file containing the layout as a QPT file. When this object is used within a QgsTask, it is recommended to use this layout path to reconstruct the layout rather calling the layout attribute since it was created in a separate thread. Returns: Type Description str Path to the layout template file.","title":"output_layout_path"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ReportGenerator.repeat_page","text":"repeat_page Returns the page item that will be repeated based on the number of implementation models in the scenario. A repeat page is a layout page item that contains the first instance of a CplusMapRepeatItem. Returns: Type Description QgsLayoutItemPage Page item containing a CplusMapRepeatItem or None if not found.","title":"repeat_page"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ReportGenerator.duplicate_repeat_page","text":"duplicate_repeat_page ( position ) Duplicates the repeat page and adds it to the layout at the given position. Parameters: Name Type Description Default position int Zero-based position to insert the duplicated page. If the position is greater than the number of pages, then the duplicated page will be inserted at the end of the layout. required Returns: Type Description bool True if the page was successfully duplicated else False. Source code in src/cplus_plugin/lib/reports/generator.py 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 def duplicate_repeat_page ( self , position : int ) -> bool : \"\"\"Duplicates the repeat page and adds it to the layout at the given position. :param position: Zero-based position to insert the duplicated page. If the position is greater than the number of pages, then the duplicated page will be inserted at the end of the layout. :type position: int :returns: True if the page was successfully duplicated else False. :rtype: bool \"\"\" if self . _repeat_page is None : return False if self . _layout is None : return False if self . _repeat_page_num == - 1 : tr_msg = \"Repeat page not found in page collection\" self . _error_messages . append ( tr_msg ) return False new_page = QgsLayoutItemPage ( self . _layout ) new_page . attemptResize ( self . _repeat_page . sizeWithUnits ()) new_page . setPageStyleSymbol ( self . _repeat_page . pageStyleSymbol () . clone ()) # Insert empty repeat page at the given position if position < self . _layout . pageCollection () . pageCount (): self . _layout . pageCollection () . insertPage ( new_page , position ) else : # Add at the end position = self . _layout . pageCollection () . pageCount () self . _layout . pageCollection () . addPage ( new_page ) doc = QtXml . QDomDocument () el = doc . createElement ( \"CopyItems\" ) ctx = QgsReadWriteContext () repeat_page_items = self . _layout . pageCollection () . itemsOnPage ( self . _repeat_page_num ) for item in repeat_page_items : item . writeXml ( el , doc , ctx ) doc . appendChild ( el ) # Clear element identifier references nodes = doc . elementsByTagName ( \"LayoutItem\" ) for n in range ( nodes . count ()): node = nodes . at ( n ) if node . isElement (): node . toElement () . removeAttribute ( \"uuid\" ) page_ref_point = self . _layout . pageCollection () . pagePositionToLayoutPosition ( position , QgsLayoutPoint ( 0 , 0 ) ) _ = self . _layout . addItemsFromXml ( el , doc , ctx , page_ref_point , True ) return True","title":"duplicate_repeat_page()"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ReportGenerator.export_to_pdf","text":"export_to_pdf () Exports the layout to a PDF file in the output directory using the layout name as the file name. Returns: Type Description bool True if the layout was successfully exported else False. Source code in src/cplus_plugin/lib/reports/generator.py 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 def export_to_pdf ( self ) -> bool : \"\"\"Exports the layout to a PDF file in the output directory using the layout name as the file name. :returns: True if the layout was successfully exported else False. :rtype: bool \"\"\" if self . _layout is None or self . _project is None or not self . output_dir : return False exporter = QgsLayoutExporter ( self . _layout ) pdf_path = f \" { self . output_dir } / { self . _layout . name () } .pdf\" result = exporter . exportToPdf ( pdf_path , QgsLayoutExporter . PdfExportSettings ()) if result == QgsLayoutExporter . ExportResult . Success : return True else : tr_msg = tr ( \"Could not export layout to PDF\" ) self . _error_messages . append ( f \" { tr_msg } { pdf_path } .\" ) return False","title":"export_to_pdf()"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ReportGenerator.run","text":"run () Initiates the report generation process and returns a result which contains information on whether the process succeeded or failed. Returns: Type Description ReportResult The result of the report generation process. Source code in src/cplus_plugin/lib/reports/generator.py 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 def run ( self ) -> ReportResult : \"\"\"Initiates the report generation process and returns a result which contains information on whether the process succeeded or failed. :returns: The result of the report generation process. :rtype: ReportResult \"\"\" try : return self . _run () except Exception as ex : # Last resort to capture general exceptions. exc_info = \"\" . join ( traceback . TracebackException . from_exception ( ex ) . format ()) self . _error_messages . append ( exc_info ) return self . _get_failed_result ()","title":"run()"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ReportGenerator.set_label_font","text":"set_label_font ( label , size , bold = False , italic = False ) Set font properties of the given layout label item. Parameters: Name Type Description Default label QgsLayoutItemLabel Label item whose font properties will be updated. required size float Point size of the font. required bold bool True if font is to be bold, else False (default). False italic bool True if font is to be in italics, else False (default). False Source code in src/cplus_plugin/lib/reports/generator.py 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 @classmethod def set_label_font ( cls , label : QgsLayoutItemLabel , size : float , bold : bool = False , italic : bool = False , ): \"\"\"Set font properties of the given layout label item. :param label: Label item whose font properties will be updated. :type label: QgsLayoutItemLabel :param size: Point size of the font. :type size: int :param bold: True if font is to be bold, else False (default). :type bold: bool :param italic: True if font is to be in italics, else False (default). :type italic: bool \"\"\" font = get_report_font ( size , bold , italic ) version = Qgis . versionInt () # Text format size unit if version < 33000 : unit_type = QgsUnitTypes . RenderUnit . RenderPoints else : unit_type = Qgis . RenderUnit . Points # Label font setting option if version < 32400 : label . setFont ( font ) else : txt_format = QgsTextFormat () txt_format . setFont ( font ) txt_format . setSize ( size ) txt_format . setSizeUnit ( unit_type ) label . setTextFormat ( txt_format ) label . refresh ()","title":"set_label_font()"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ReportGeneratorTask","text":"ReportGeneratorTask ( description , context ) Bases: QgsTask Proxy class for initiating the report generation process. Source code in src/cplus_plugin/lib/reports/generator.py 69 70 71 72 73 74 75 def __init__ ( self , description : str , context : ReportContext ): super () . __init__ ( description ) self . _context = context self . _result = None self . _generator = ReportGenerator ( self . _context , self . _context . feedback ) self . layout_manager = QgsProject . instance () . layoutManager () self . layout_manager . layoutAdded . connect ( self . _on_layout_added )","title":"ReportGeneratorTask"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ReportGeneratorTask.context","text":"context Returns the report context used by the generator. Returns: Type Description ReportContext Report context object used by the generator.","title":"context"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ReportGeneratorTask.result","text":"result Returns the result object which contains information on whether the process succeeded or failed. Returns: Type Description ReportResult The result of the report generation process.","title":"result"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ReportGeneratorTask.cancel","text":"cancel () Cancel the report generation task. Source code in src/cplus_plugin/lib/reports/generator.py 96 97 98 99 100 101 def cancel ( self ): \"\"\"Cancel the report generation task.\"\"\" if self . _context . feedback : self . _context . feedback . cancel () super () . cancel ()","title":"cancel()"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ReportGeneratorTask.finished","text":"finished ( result ) If successful, add the layout to the project. Parameters: Name Type Description Default result bool Flag indicating if the result of the report generation process. True if successful, else False. required Source code in src/cplus_plugin/lib/reports/generator.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 def finished ( self , result : bool ): \"\"\"If successful, add the layout to the project. :param result: Flag indicating if the result of the report generation process. True if successful, else False. :type result: bool \"\"\" if result : log ( f \"Successfully generated the report for \" f \" { self . _context . scenario . name } scenario.\" ) layout_path = self . _generator . output_layout_path if not layout_path : log ( \"Output layout could not be saved.\" , info = False ) return feedback = self . _context . feedback project = QgsProject . instance () layout = _load_layout_from_file ( layout_path , project ) if layout is None : log ( \"Could not load layout from file.\" , info = False ) return # Zoom the extents of map items in the layout then export to PDF self . _zoom_map_items_to_current_extents ( layout ) project . layoutManager () . addLayout ( layout ) if feedback is not None : feedback . setProgress ( 100 ) else : log ( f \"Error occurred when generating the \" f \"report for { self . _context . scenario . name } \" f \"scenario. See details below:\" , info = False , ) for err in self . _result . messages : err_msg = f \" { self . _context . scenario . name } - { err } \" log ( err_msg , info = False )","title":"finished()"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ReportGeneratorTask.run","text":"run () Initiates the report generation process and returns a result indicating whether the process succeeded or failed. Returns: Type Description bool True if the report generation process succeeded or False it if failed. Source code in src/cplus_plugin/lib/reports/generator.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def run ( self ) -> bool : \"\"\"Initiates the report generation process and returns a result indicating whether the process succeeded or failed. :returns: True if the report generation process succeeded or False it if failed. :rtype: bool \"\"\" if self . isCanceled (): return False if self . _context . project_file : self . _result = self . _generator . run () else : msg = tr ( \"Unable to serialize current project for \" \"report generation.\" ) msgs : typing . List [ str ] = [ msg ] self . _result = ReportResult ( False , self . _context . scenario . uuid , \"\" , tuple ( msgs ) ) return self . _result . success","title":"run()"},{"location":"developer/api/core/api_reports_layout_items/","text":"Layout Items Custom CPLUS layout items. CplusMapRepeatItem CplusMapRepeatItem ( * args , ** kwargs ) Bases: QgsLayoutItemShape Defines an outline area within a layout where map items containing NCS pathway or implementation model will be drawn. Source code in src/cplus_plugin/lib/reports/layout_items.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . setShapeType ( QgsLayoutItemShape . Shape . Rectangle ) # We shall use a frame so that it can be turned off / on # using the item properties UI. The symbol is just a proxy. # Symbol properties symbol_props = { \"color\" : \"229,182,54,0\" , \"style\" : \"solid\" , \"outline_style\" : \"dash\" , \"line_color\" : \"132,192,68\" , \"outline_width\" : \"0\" , \"joinstyle\" : \"miter\" , } symbol = QgsFillSymbol . createSimple ( symbol_props ) self . setSymbol ( symbol ) self . _model_component_type = kwargs . pop ( \"model_component_type\" , ModelComponentType . UNKNOWN ) model_component_type property writable model_component_type Gets the model component type associated with this map item i.e. NCS pathway or implementation model. Returns: Type Description Enum Type of the model component. icon icon () Override for custom CPLUS map item. Source code in src/cplus_plugin/lib/reports/layout_items.py 83 84 85 def icon ( self ) -> QtGui . QIcon : \"\"\"Override for custom CPLUS map item.\"\"\" return FileUtils . get_icon ( \"mLayoutItemMap_cplus.svg\" ) readPropertiesFromElement readPropertiesFromElement ( element , document , context ) Override reading of item properties. Source code in src/cplus_plugin/lib/reports/layout_items.py 95 96 97 98 99 100 101 102 103 104 def readPropertiesFromElement ( self , element , document , context ): \"\"\"Override reading of item properties.\"\"\" status = super () . readPropertiesFromElement ( element , document , context ) if status : model_component_type = element . attribute ( \"modelComponentType\" , \"\" ) self . _model_component_type = ModelComponentType . from_string ( model_component_type ) return status type type () Return item's unique type identifier. Source code in src/cplus_plugin/lib/reports/layout_items.py 71 72 73 def type ( self ): \"\"\"Return item's unique type identifier.\"\"\" return CPLUS_MAP_REPEAT_ITEM_TYPE visibleName visibleName () Override for visible name of the item. Source code in src/cplus_plugin/lib/reports/layout_items.py 75 76 77 def visibleName ( self ) -> str : \"\"\"Override for visible name of the item.\"\"\" return tr ( \"CPLUS Map Repeat Area Item\" ) visiblePluralName visiblePluralName () Override for plural name of the items. Source code in src/cplus_plugin/lib/reports/layout_items.py 79 80 81 def visiblePluralName ( self ) -> str : \"\"\"Override for plural name of the items.\"\"\" return tr ( \"CPLUS Map Repeat Area Items\" ) writePropertiesToElement writePropertiesToElement ( el , document , context ) Override saving of item properties. Source code in src/cplus_plugin/lib/reports/layout_items.py 87 88 89 90 91 92 93 def writePropertiesToElement ( self , el , document , context ): \"\"\"Override saving of item properties.\"\"\" status = super () . writePropertiesToElement ( el , document , context ) if status : el . setAttribute ( \"modelComponentType\" , self . _model_component_type . value ) return status CplusMapRepeatItemLayoutItemMetadata CplusMapRepeatItemLayoutItemMetadata () Bases: QgsLayoutItemAbstractMetadata Metadata info of the cplus map repeat item. Source code in src/cplus_plugin/lib/reports/layout_items.py 110 111 def __init__ ( self ): super () . __init__ ( CPLUS_MAP_REPEAT_ITEM_TYPE , tr ( \"CPLUS Map Repeat Area Item\" )) createItem createItem ( layout ) Factory method that return the cplus map item. Source code in src/cplus_plugin/lib/reports/layout_items.py 113 114 115 def createItem ( self , layout ) -> CplusMapRepeatItem : \"\"\"Factory method that return the cplus map item.\"\"\" return CplusMapRepeatItem ( layout )","title":"Layout items"},{"location":"developer/api/core/api_reports_layout_items/#layout-items","text":"Custom CPLUS layout items.","title":"Layout Items"},{"location":"developer/api/core/api_reports_layout_items/#src.cplus_plugin.lib.reports.layout_items.CplusMapRepeatItem","text":"CplusMapRepeatItem ( * args , ** kwargs ) Bases: QgsLayoutItemShape Defines an outline area within a layout where map items containing NCS pathway or implementation model will be drawn. Source code in src/cplus_plugin/lib/reports/layout_items.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . setShapeType ( QgsLayoutItemShape . Shape . Rectangle ) # We shall use a frame so that it can be turned off / on # using the item properties UI. The symbol is just a proxy. # Symbol properties symbol_props = { \"color\" : \"229,182,54,0\" , \"style\" : \"solid\" , \"outline_style\" : \"dash\" , \"line_color\" : \"132,192,68\" , \"outline_width\" : \"0\" , \"joinstyle\" : \"miter\" , } symbol = QgsFillSymbol . createSimple ( symbol_props ) self . setSymbol ( symbol ) self . _model_component_type = kwargs . pop ( \"model_component_type\" , ModelComponentType . UNKNOWN )","title":"CplusMapRepeatItem"},{"location":"developer/api/core/api_reports_layout_items/#src.cplus_plugin.lib.reports.layout_items.CplusMapRepeatItem.model_component_type","text":"model_component_type Gets the model component type associated with this map item i.e. NCS pathway or implementation model. Returns: Type Description Enum Type of the model component.","title":"model_component_type"},{"location":"developer/api/core/api_reports_layout_items/#src.cplus_plugin.lib.reports.layout_items.CplusMapRepeatItem.icon","text":"icon () Override for custom CPLUS map item. Source code in src/cplus_plugin/lib/reports/layout_items.py 83 84 85 def icon ( self ) -> QtGui . QIcon : \"\"\"Override for custom CPLUS map item.\"\"\" return FileUtils . get_icon ( \"mLayoutItemMap_cplus.svg\" )","title":"icon()"},{"location":"developer/api/core/api_reports_layout_items/#src.cplus_plugin.lib.reports.layout_items.CplusMapRepeatItem.readPropertiesFromElement","text":"readPropertiesFromElement ( element , document , context ) Override reading of item properties. Source code in src/cplus_plugin/lib/reports/layout_items.py 95 96 97 98 99 100 101 102 103 104 def readPropertiesFromElement ( self , element , document , context ): \"\"\"Override reading of item properties.\"\"\" status = super () . readPropertiesFromElement ( element , document , context ) if status : model_component_type = element . attribute ( \"modelComponentType\" , \"\" ) self . _model_component_type = ModelComponentType . from_string ( model_component_type ) return status","title":"readPropertiesFromElement()"},{"location":"developer/api/core/api_reports_layout_items/#src.cplus_plugin.lib.reports.layout_items.CplusMapRepeatItem.type","text":"type () Return item's unique type identifier. Source code in src/cplus_plugin/lib/reports/layout_items.py 71 72 73 def type ( self ): \"\"\"Return item's unique type identifier.\"\"\" return CPLUS_MAP_REPEAT_ITEM_TYPE","title":"type()"},{"location":"developer/api/core/api_reports_layout_items/#src.cplus_plugin.lib.reports.layout_items.CplusMapRepeatItem.visibleName","text":"visibleName () Override for visible name of the item. Source code in src/cplus_plugin/lib/reports/layout_items.py 75 76 77 def visibleName ( self ) -> str : \"\"\"Override for visible name of the item.\"\"\" return tr ( \"CPLUS Map Repeat Area Item\" )","title":"visibleName()"},{"location":"developer/api/core/api_reports_layout_items/#src.cplus_plugin.lib.reports.layout_items.CplusMapRepeatItem.visiblePluralName","text":"visiblePluralName () Override for plural name of the items. Source code in src/cplus_plugin/lib/reports/layout_items.py 79 80 81 def visiblePluralName ( self ) -> str : \"\"\"Override for plural name of the items.\"\"\" return tr ( \"CPLUS Map Repeat Area Items\" )","title":"visiblePluralName()"},{"location":"developer/api/core/api_reports_layout_items/#src.cplus_plugin.lib.reports.layout_items.CplusMapRepeatItem.writePropertiesToElement","text":"writePropertiesToElement ( el , document , context ) Override saving of item properties. Source code in src/cplus_plugin/lib/reports/layout_items.py 87 88 89 90 91 92 93 def writePropertiesToElement ( self , el , document , context ): \"\"\"Override saving of item properties.\"\"\" status = super () . writePropertiesToElement ( el , document , context ) if status : el . setAttribute ( \"modelComponentType\" , self . _model_component_type . value ) return status","title":"writePropertiesToElement()"},{"location":"developer/api/core/api_reports_layout_items/#src.cplus_plugin.lib.reports.layout_items.CplusMapRepeatItemLayoutItemMetadata","text":"CplusMapRepeatItemLayoutItemMetadata () Bases: QgsLayoutItemAbstractMetadata Metadata info of the cplus map repeat item. Source code in src/cplus_plugin/lib/reports/layout_items.py 110 111 def __init__ ( self ): super () . __init__ ( CPLUS_MAP_REPEAT_ITEM_TYPE , tr ( \"CPLUS Map Repeat Area Item\" ))","title":"CplusMapRepeatItemLayoutItemMetadata"},{"location":"developer/api/core/api_reports_layout_items/#src.cplus_plugin.lib.reports.layout_items.CplusMapRepeatItemLayoutItemMetadata.createItem","text":"createItem ( layout ) Factory method that return the cplus map item. Source code in src/cplus_plugin/lib/reports/layout_items.py 113 114 115 def createItem ( self , layout ) -> CplusMapRepeatItem : \"\"\"Factory method that return the cplus map item.\"\"\" return CplusMapRepeatItem ( layout )","title":"createItem()"},{"location":"developer/api/core/api_reports_manager/","text":"Report Manager Registers custom report variables for layout design and handles report generation. ReportManager ReportManager ( parent = None ) Bases: QObject Registers custom report variables for layout design and handles report generation. Source code in src/cplus_plugin/lib/reports/manager.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def __init__ ( self , parent = None ): super () . __init__ ( parent ) self . _variable_register = LayoutVariableRegister () self . report_name = tr ( \"Scenario Analysis Report\" ) # Task id (value) indexed by scenario id (key) self . _report_tasks = {} # Report results (value) indexed by scenario id (key) self . _report_results = {} self . task_manager = QgsApplication . instance () . taskManager () self . task_manager . statusChanged . connect ( self . on_task_status_changed ) self . root_output_dir = \"\" self . _set_root_output_dir () variable_register property variable_register Get the instance of the variable register used for the management of variables. Returns: Type Description LayoutVariableRegister The register for managing variables in report layout scope. create_report_context create_report_context ( scenario , feedback , output_layer_name ) Creates the report context for use in the report generator task. Parameters: Name Type Description Default scenario Scenario Scenario whose report context will be created under BASE_DIR. required feedback QgsFeedback Feedback object for reporting back to the main application. required output_layer_name str Name of the output scenario layer in the TOC. required Returns: Type Description ReportContext A report context object containing the information for generating the report else None if it could not be created. Source code in src/cplus_plugin/lib/reports/manager.py 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 def create_report_context ( self , scenario : Scenario , feedback : QgsFeedback , output_layer_name : str ) -> typing . Union [ ReportContext , None ]: \"\"\"Creates the report context for use in the report generator task. :param scenario: Scenario whose report context will be created under BASE_DIR. :type scenario: Scenario :param feedback: Feedback object for reporting back to the main application. :type feedback: QgsFeedback :param output_layer_name: Name of the output scenario layer in the TOC. :type output_layer_name: str :returns: A report context object containing the information for generating the report else None if it could not be created. :rtype: ReportContext \"\"\" # Try to update the root output directory. self . _set_root_output_dir () output_dir = self . create_scenario_dir ( scenario ) if not output_dir : return None project_file_path = f \" { output_dir } / { scenario . name } .qgz\" if os . path . exists ( project_file_path ): counter = 1 while True : project_file_path = f \" { output_dir } / { scenario . name } _ { counter !s} .qgz\" if not os . path . exists ( project_file_path ): break counter += 1 # Write project to file for use in the task since QgsProject # instances are not thread safe. storage_type = QgsProject . instance () . filePathStorage () QgsProject . instance () . setFilePathStorage ( Qgis . FilePathType . Absolute ) result = QgsProject . instance () . write ( project_file_path ) QgsProject . instance () . setFilePathStorage ( storage_type ) if not result : return None # Set base name for the layout and PDF file suffixed with a number # depending on the number of runs. layout_manager = QgsProject . instance () . layoutManager () counter = 1 context_name = \"\" while True : layout_name = f \" { scenario . name } { counter !s} \" matching_layout = layout_manager . layoutByName ( layout_name ) if matching_layout is None : context_name = layout_name break counter += 1 template_path = FileUtils . report_template_path () return ReportContext ( template_path , scenario , context_name , output_dir , project_file_path , feedback , output_layer_name , ) create_scenario_dir create_scenario_dir ( scenario ) Creates an output directory (within BASE_DIR) for saving the analysis outputs for the given scenario. Parameters: Name Type Description Default scenario Scenario Reference scenario object. required Returns: Type Description str The absolute path to the output directory. If BASE_DIR does not exist, it will not create the directory and will return an empty string. If the current user does not have write permissions to the base directory, it will return an empty string. Source code in src/cplus_plugin/lib/reports/manager.py 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 def create_scenario_dir ( self , scenario : Scenario ) -> str : \"\"\"Creates an output directory (within BASE_DIR) for saving the analysis outputs for the given scenario. :param scenario: Reference scenario object. :type scenario: Scenario :returns: The absolute path to the output directory. If BASE_DIR does not exist, it will not create the directory and will return an empty string. If the current user does not have write permissions to the base directory, it will return an empty string. :rtype: str \"\"\" if not self . root_output_dir : return \"\" output_path = Path ( self . root_output_dir ) if not output_path . exists (): try : output_path . mkdir () except FileNotFoundError : msg = ( \"Missing parent directory when creating \" \"outputs subdirectory in the base directory.\" ) log ( msg ) return \"\" scenario_path_str = f \" { self . root_output_dir } / { str ( scenario . uuid ) } \" scenario_output_path = Path ( scenario_path_str ) if not scenario_output_path . exists (): try : scenario_output_path . mkdir () except FileNotFoundError : msg = ( \"Missing parent directory when creating \" \"scenario subdirectory in the outputs directory.\" ) log ( msg ) return \"\" return scenario_path_str generate generate ( scenario_result , feedback = None ) Initiates the report generation process using information resulting from the scenario analysis. Parameters: Name Type Description Default scenario_result ScenarioResult Contains details from the scenario analysis. required feedback QgsFeedback Feedback for reporting back to the main application. If one is not specified then the manager will create one for the context. None Returns: Type Description ReportSubmitStatus True if the report generation process was successfully submitted else False if a running process is re-submitted. Object also contains feedback object for report updating and cancellation. Source code in src/cplus_plugin/lib/reports/manager.py 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 def generate ( self , scenario_result : ScenarioResult , feedback : QgsFeedback = None ) -> ReportSubmitStatus : \"\"\"Initiates the report generation process using information resulting from the scenario analysis. :param scenario_result: Contains details from the scenario analysis. :type scenario_result: ScenarioResult :param feedback: Feedback for reporting back to the main application. If one is not specified then the manager will create one for the context. :type feedback: QgsFeedback :returns: True if the report generation process was successfully submitted else False if a running process is re-submitted. Object also contains feedback object for report updating and cancellation. :rtype: ReportSubmitStatus \"\"\" scenario = scenario_result . scenario if not scenario_result . output_layer_name : log ( \"Layer name for output scenario is empty. Cannot generate reports.\" ) return ReportSubmitStatus ( False , None ) if feedback is None : feedback = QgsFeedback ( self ) ctx = self . create_report_context ( scenario , feedback , scenario_result . output_layer_name ) if ctx is None : log ( \"Could not create report context. Check directory settings.\" ) return ReportSubmitStatus ( False , None ) scenario_id = str ( ctx . scenario . uuid ) if scenario_id in self . _report_tasks : return ReportSubmitStatus ( False , ctx . feedback ) msg_tr = tr ( \"Generating report for\" ) description = f \" { msg_tr } { ctx . scenario . name } \" report_task = ReportGeneratorTask ( description , ctx ) task_id = self . task_manager . addTask ( report_task ) self . _report_tasks [ scenario_id ] = task_id return ReportSubmitStatus ( True , ctx . feedback ) on_task_status_changed on_task_status_changed ( task_id , status ) Slot raised when the status of a task has changed. This function will emit when the report generation task has started or when it has completed successfully or terminated due to an error. Parameters: Name Type Description Default task_id int ID of the task. required status TaskStatus New task status. required Source code in src/cplus_plugin/lib/reports/manager.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 def on_task_status_changed ( self , task_id : int , status : QgsTask . TaskStatus ): \"\"\"Slot raised when the status of a task has changed. This function will emit when the report generation task has started or when it has completed successfully or terminated due to an error. :param task_id: ID of the task. :type task_id: int :param status: New task status. :type status: QgsTask.TaskStatus \"\"\" scenario_id = self . scenario_by_task_id ( task_id ) # Not related to CPLUS report or task if not scenario_id : return if status == QgsTask . TaskStatus . Running : self . generate_started . emit ( scenario_id ) elif status == QgsTask . TaskStatus . Complete : # Get result task = self . task_manager . task ( task_id ) result = task . result if result is not None : self . _report_results [ scenario_id ] = result # Remove task self . remove_report_task ( scenario_id ) self . generate_completed . emit ( scenario_id ) open_layout_designer classmethod open_layout_designer ( result ) Opens the analysis report in the layout designer. The layout needs to exist in the currently loaded project. Parameters: Name Type Description Default result ReportResult Result object from the report generation process. required Returns: Type Description bool True if the layout was successfully loaded, else False if the result from the generation process was False or if the layout does not exist in the current project. Source code in src/cplus_plugin/lib/reports/manager.py 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 @classmethod def open_layout_designer ( cls , result : ReportResult ) -> bool : \"\"\"Opens the analysis report in the layout designer. The layout needs to exist in the currently loaded project. :param result: Result object from the report generation process. :type result: ReportResult :returns: True if the layout was successfully loaded, else False if the result from the generation process was False or if the layout does not exist in the current project. :rtype: bool \"\"\" if not result . success : return False layout = QgsProject . instance () . layoutManager () . layoutByName ( result . name ) if layout is None : return False iface . openLayoutDesigner ( layout ) return True register_variables register_variables ( layout ) Registers custom variables and their corresponding initial values in the layout. Parameters: Name Type Description Default layout QgsPrintLayout Layout object where the custom variables will be registered. required Source code in src/cplus_plugin/lib/reports/manager.py 74 75 76 77 78 79 80 81 82 def register_variables ( self , layout : QgsPrintLayout ): \"\"\"Registers custom variables and their corresponding initial values in the layout. :param layout: Layout object where the custom variables will be registered. :type layout: QgsPrintLayout \"\"\" self . _variable_register . register_variables ( layout ) remove_report_task remove_report_task ( scenario_id ) Remove report task associated with the given scenario. Parameters: Name Type Description Default scenario_id str Identified of the scenario whose report generation process is to be removed. required Returns: Type Description bool True if the task has been successfully removed else False if there is no associated task for the given scenario. Source code in src/cplus_plugin/lib/reports/manager.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 def remove_report_task ( self , scenario_id : str ) -> bool : \"\"\"Remove report task associated with the given scenario. :param scenario_id: Identified of the scenario whose report generation process is to be removed. :type scenario_id: str :returns: True if the task has been successfully removed else False if there is no associated task for the given scenario. :rtype: bool \"\"\" if scenario_id not in self . _report_tasks : return False task_id = self . _report_tasks [ scenario_id ] task = self . task_manager . task ( task_id ) if task is None : return False if ( task . status () != QgsTask . TaskStatus . Complete or task . status () != QgsTask . TaskStatus . Terminated ): task . cancel () _ = self . _report_tasks . pop ( scenario_id ) return True report_result report_result ( scenario_id ) Gets the report result for the scenario with the given ID. Parameters: Name Type Description Default scenario_id str Identifier of the scenario whose report is to be retrieved. required Returns: Type Description ReportResult Result of the report generation process. Caller needs to check if the process was successful or there was an error by checking the status of the success attribute. For scenarios that had not been submitted for report generation, a None object will be returned. Source code in src/cplus_plugin/lib/reports/manager.py 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 def report_result ( self , scenario_id : str ) -> typing . Union [ ReportResult , None ]: \"\"\"Gets the report result for the scenario with the given ID. :param scenario_id: Identifier of the scenario whose report is to be retrieved. :type scenario_id: str :returns: Result of the report generation process. Caller needs to check if the process was successful or there was an error by checking the status of the `success` attribute. For scenarios that had not been submitted for report generation, a None object will be returned. :rtype: ReportResult \"\"\" if scenario_id not in self . _report_results : return None return self . _report_results [ scenario_id ] scenario_by_task_id scenario_by_task_id ( task_id ) Gets the scenario identifier for the report generation t ask with the given ID. Parameters: Name Type Description Default task_id int ID of the task whose corresponding scenario is to be retrieved. required Returns: Type Description str Scenario identifier whose report is being generated by a process with the given task id or an empty string if there was no match. Source code in src/cplus_plugin/lib/reports/manager.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def scenario_by_task_id ( self , task_id : int ) -> str : \"\"\"Gets the scenario identifier for the report generation t ask with the given ID. :param task_id: ID of the task whose corresponding scenario is to be retrieved. :type task_id: int :returns: Scenario identifier whose report is being generated by a process with the given task id or an empty string if there was no match. :rtype: str \"\"\" scenario_ids = [ sid for sid , tid in self . _report_tasks . items () if tid == task_id ] if len ( scenario_ids ) == 0 : return \"\" return scenario_ids [ 0 ] view_pdf classmethod view_pdf ( result ) Opens the analysis in the host's default PDF viewer. Parameters: Name Type Description Default result ReportResult Result object from the report generation process. required Returns: Type Description bool True if the PDF was successfully loaded, else False if the result from the generation process was False. Source code in src/cplus_plugin/lib/reports/manager.py 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 @classmethod def view_pdf ( cls , result : ReportResult ) -> bool : \"\"\"Opens the analysis in the host's default PDF viewer. :param result: Result object from the report generation process. :type result: ReportResult :returns: True if the PDF was successfully loaded, else False if the result from the generation process was False. :rtype: bool \"\"\" if not result . success : return False pdf_url = QtCore . QUrl . fromLocalFile ( result . pdf_path ) if pdf_url . isEmpty (): return False return QtGui . QDesktopServices . openUrl ( pdf_url )","title":"Manager"},{"location":"developer/api/core/api_reports_manager/#report-manager","text":"Registers custom report variables for layout design and handles report generation.","title":"Report Manager"},{"location":"developer/api/core/api_reports_manager/#src.cplus_plugin.lib.reports.manager.ReportManager","text":"ReportManager ( parent = None ) Bases: QObject Registers custom report variables for layout design and handles report generation. Source code in src/cplus_plugin/lib/reports/manager.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def __init__ ( self , parent = None ): super () . __init__ ( parent ) self . _variable_register = LayoutVariableRegister () self . report_name = tr ( \"Scenario Analysis Report\" ) # Task id (value) indexed by scenario id (key) self . _report_tasks = {} # Report results (value) indexed by scenario id (key) self . _report_results = {} self . task_manager = QgsApplication . instance () . taskManager () self . task_manager . statusChanged . connect ( self . on_task_status_changed ) self . root_output_dir = \"\" self . _set_root_output_dir ()","title":"ReportManager"},{"location":"developer/api/core/api_reports_manager/#src.cplus_plugin.lib.reports.manager.ReportManager.variable_register","text":"variable_register Get the instance of the variable register used for the management of variables. Returns: Type Description LayoutVariableRegister The register for managing variables in report layout scope.","title":"variable_register"},{"location":"developer/api/core/api_reports_manager/#src.cplus_plugin.lib.reports.manager.ReportManager.create_report_context","text":"create_report_context ( scenario , feedback , output_layer_name ) Creates the report context for use in the report generator task. Parameters: Name Type Description Default scenario Scenario Scenario whose report context will be created under BASE_DIR. required feedback QgsFeedback Feedback object for reporting back to the main application. required output_layer_name str Name of the output scenario layer in the TOC. required Returns: Type Description ReportContext A report context object containing the information for generating the report else None if it could not be created. Source code in src/cplus_plugin/lib/reports/manager.py 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 def create_report_context ( self , scenario : Scenario , feedback : QgsFeedback , output_layer_name : str ) -> typing . Union [ ReportContext , None ]: \"\"\"Creates the report context for use in the report generator task. :param scenario: Scenario whose report context will be created under BASE_DIR. :type scenario: Scenario :param feedback: Feedback object for reporting back to the main application. :type feedback: QgsFeedback :param output_layer_name: Name of the output scenario layer in the TOC. :type output_layer_name: str :returns: A report context object containing the information for generating the report else None if it could not be created. :rtype: ReportContext \"\"\" # Try to update the root output directory. self . _set_root_output_dir () output_dir = self . create_scenario_dir ( scenario ) if not output_dir : return None project_file_path = f \" { output_dir } / { scenario . name } .qgz\" if os . path . exists ( project_file_path ): counter = 1 while True : project_file_path = f \" { output_dir } / { scenario . name } _ { counter !s} .qgz\" if not os . path . exists ( project_file_path ): break counter += 1 # Write project to file for use in the task since QgsProject # instances are not thread safe. storage_type = QgsProject . instance () . filePathStorage () QgsProject . instance () . setFilePathStorage ( Qgis . FilePathType . Absolute ) result = QgsProject . instance () . write ( project_file_path ) QgsProject . instance () . setFilePathStorage ( storage_type ) if not result : return None # Set base name for the layout and PDF file suffixed with a number # depending on the number of runs. layout_manager = QgsProject . instance () . layoutManager () counter = 1 context_name = \"\" while True : layout_name = f \" { scenario . name } { counter !s} \" matching_layout = layout_manager . layoutByName ( layout_name ) if matching_layout is None : context_name = layout_name break counter += 1 template_path = FileUtils . report_template_path () return ReportContext ( template_path , scenario , context_name , output_dir , project_file_path , feedback , output_layer_name , )","title":"create_report_context()"},{"location":"developer/api/core/api_reports_manager/#src.cplus_plugin.lib.reports.manager.ReportManager.create_scenario_dir","text":"create_scenario_dir ( scenario ) Creates an output directory (within BASE_DIR) for saving the analysis outputs for the given scenario. Parameters: Name Type Description Default scenario Scenario Reference scenario object. required Returns: Type Description str The absolute path to the output directory. If BASE_DIR does not exist, it will not create the directory and will return an empty string. If the current user does not have write permissions to the base directory, it will return an empty string. Source code in src/cplus_plugin/lib/reports/manager.py 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 def create_scenario_dir ( self , scenario : Scenario ) -> str : \"\"\"Creates an output directory (within BASE_DIR) for saving the analysis outputs for the given scenario. :param scenario: Reference scenario object. :type scenario: Scenario :returns: The absolute path to the output directory. If BASE_DIR does not exist, it will not create the directory and will return an empty string. If the current user does not have write permissions to the base directory, it will return an empty string. :rtype: str \"\"\" if not self . root_output_dir : return \"\" output_path = Path ( self . root_output_dir ) if not output_path . exists (): try : output_path . mkdir () except FileNotFoundError : msg = ( \"Missing parent directory when creating \" \"outputs subdirectory in the base directory.\" ) log ( msg ) return \"\" scenario_path_str = f \" { self . root_output_dir } / { str ( scenario . uuid ) } \" scenario_output_path = Path ( scenario_path_str ) if not scenario_output_path . exists (): try : scenario_output_path . mkdir () except FileNotFoundError : msg = ( \"Missing parent directory when creating \" \"scenario subdirectory in the outputs directory.\" ) log ( msg ) return \"\" return scenario_path_str","title":"create_scenario_dir()"},{"location":"developer/api/core/api_reports_manager/#src.cplus_plugin.lib.reports.manager.ReportManager.generate","text":"generate ( scenario_result , feedback = None ) Initiates the report generation process using information resulting from the scenario analysis. Parameters: Name Type Description Default scenario_result ScenarioResult Contains details from the scenario analysis. required feedback QgsFeedback Feedback for reporting back to the main application. If one is not specified then the manager will create one for the context. None Returns: Type Description ReportSubmitStatus True if the report generation process was successfully submitted else False if a running process is re-submitted. Object also contains feedback object for report updating and cancellation. Source code in src/cplus_plugin/lib/reports/manager.py 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 def generate ( self , scenario_result : ScenarioResult , feedback : QgsFeedback = None ) -> ReportSubmitStatus : \"\"\"Initiates the report generation process using information resulting from the scenario analysis. :param scenario_result: Contains details from the scenario analysis. :type scenario_result: ScenarioResult :param feedback: Feedback for reporting back to the main application. If one is not specified then the manager will create one for the context. :type feedback: QgsFeedback :returns: True if the report generation process was successfully submitted else False if a running process is re-submitted. Object also contains feedback object for report updating and cancellation. :rtype: ReportSubmitStatus \"\"\" scenario = scenario_result . scenario if not scenario_result . output_layer_name : log ( \"Layer name for output scenario is empty. Cannot generate reports.\" ) return ReportSubmitStatus ( False , None ) if feedback is None : feedback = QgsFeedback ( self ) ctx = self . create_report_context ( scenario , feedback , scenario_result . output_layer_name ) if ctx is None : log ( \"Could not create report context. Check directory settings.\" ) return ReportSubmitStatus ( False , None ) scenario_id = str ( ctx . scenario . uuid ) if scenario_id in self . _report_tasks : return ReportSubmitStatus ( False , ctx . feedback ) msg_tr = tr ( \"Generating report for\" ) description = f \" { msg_tr } { ctx . scenario . name } \" report_task = ReportGeneratorTask ( description , ctx ) task_id = self . task_manager . addTask ( report_task ) self . _report_tasks [ scenario_id ] = task_id return ReportSubmitStatus ( True , ctx . feedback )","title":"generate()"},{"location":"developer/api/core/api_reports_manager/#src.cplus_plugin.lib.reports.manager.ReportManager.on_task_status_changed","text":"on_task_status_changed ( task_id , status ) Slot raised when the status of a task has changed. This function will emit when the report generation task has started or when it has completed successfully or terminated due to an error. Parameters: Name Type Description Default task_id int ID of the task. required status TaskStatus New task status. required Source code in src/cplus_plugin/lib/reports/manager.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 def on_task_status_changed ( self , task_id : int , status : QgsTask . TaskStatus ): \"\"\"Slot raised when the status of a task has changed. This function will emit when the report generation task has started or when it has completed successfully or terminated due to an error. :param task_id: ID of the task. :type task_id: int :param status: New task status. :type status: QgsTask.TaskStatus \"\"\" scenario_id = self . scenario_by_task_id ( task_id ) # Not related to CPLUS report or task if not scenario_id : return if status == QgsTask . TaskStatus . Running : self . generate_started . emit ( scenario_id ) elif status == QgsTask . TaskStatus . Complete : # Get result task = self . task_manager . task ( task_id ) result = task . result if result is not None : self . _report_results [ scenario_id ] = result # Remove task self . remove_report_task ( scenario_id ) self . generate_completed . emit ( scenario_id )","title":"on_task_status_changed()"},{"location":"developer/api/core/api_reports_manager/#src.cplus_plugin.lib.reports.manager.ReportManager.open_layout_designer","text":"open_layout_designer ( result ) Opens the analysis report in the layout designer. The layout needs to exist in the currently loaded project. Parameters: Name Type Description Default result ReportResult Result object from the report generation process. required Returns: Type Description bool True if the layout was successfully loaded, else False if the result from the generation process was False or if the layout does not exist in the current project. Source code in src/cplus_plugin/lib/reports/manager.py 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 @classmethod def open_layout_designer ( cls , result : ReportResult ) -> bool : \"\"\"Opens the analysis report in the layout designer. The layout needs to exist in the currently loaded project. :param result: Result object from the report generation process. :type result: ReportResult :returns: True if the layout was successfully loaded, else False if the result from the generation process was False or if the layout does not exist in the current project. :rtype: bool \"\"\" if not result . success : return False layout = QgsProject . instance () . layoutManager () . layoutByName ( result . name ) if layout is None : return False iface . openLayoutDesigner ( layout ) return True","title":"open_layout_designer()"},{"location":"developer/api/core/api_reports_manager/#src.cplus_plugin.lib.reports.manager.ReportManager.register_variables","text":"register_variables ( layout ) Registers custom variables and their corresponding initial values in the layout. Parameters: Name Type Description Default layout QgsPrintLayout Layout object where the custom variables will be registered. required Source code in src/cplus_plugin/lib/reports/manager.py 74 75 76 77 78 79 80 81 82 def register_variables ( self , layout : QgsPrintLayout ): \"\"\"Registers custom variables and their corresponding initial values in the layout. :param layout: Layout object where the custom variables will be registered. :type layout: QgsPrintLayout \"\"\" self . _variable_register . register_variables ( layout )","title":"register_variables()"},{"location":"developer/api/core/api_reports_manager/#src.cplus_plugin.lib.reports.manager.ReportManager.remove_report_task","text":"remove_report_task ( scenario_id ) Remove report task associated with the given scenario. Parameters: Name Type Description Default scenario_id str Identified of the scenario whose report generation process is to be removed. required Returns: Type Description bool True if the task has been successfully removed else False if there is no associated task for the given scenario. Source code in src/cplus_plugin/lib/reports/manager.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 def remove_report_task ( self , scenario_id : str ) -> bool : \"\"\"Remove report task associated with the given scenario. :param scenario_id: Identified of the scenario whose report generation process is to be removed. :type scenario_id: str :returns: True if the task has been successfully removed else False if there is no associated task for the given scenario. :rtype: bool \"\"\" if scenario_id not in self . _report_tasks : return False task_id = self . _report_tasks [ scenario_id ] task = self . task_manager . task ( task_id ) if task is None : return False if ( task . status () != QgsTask . TaskStatus . Complete or task . status () != QgsTask . TaskStatus . Terminated ): task . cancel () _ = self . _report_tasks . pop ( scenario_id ) return True","title":"remove_report_task()"},{"location":"developer/api/core/api_reports_manager/#src.cplus_plugin.lib.reports.manager.ReportManager.report_result","text":"report_result ( scenario_id ) Gets the report result for the scenario with the given ID. Parameters: Name Type Description Default scenario_id str Identifier of the scenario whose report is to be retrieved. required Returns: Type Description ReportResult Result of the report generation process. Caller needs to check if the process was successful or there was an error by checking the status of the success attribute. For scenarios that had not been submitted for report generation, a None object will be returned. Source code in src/cplus_plugin/lib/reports/manager.py 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 def report_result ( self , scenario_id : str ) -> typing . Union [ ReportResult , None ]: \"\"\"Gets the report result for the scenario with the given ID. :param scenario_id: Identifier of the scenario whose report is to be retrieved. :type scenario_id: str :returns: Result of the report generation process. Caller needs to check if the process was successful or there was an error by checking the status of the `success` attribute. For scenarios that had not been submitted for report generation, a None object will be returned. :rtype: ReportResult \"\"\" if scenario_id not in self . _report_results : return None return self . _report_results [ scenario_id ]","title":"report_result()"},{"location":"developer/api/core/api_reports_manager/#src.cplus_plugin.lib.reports.manager.ReportManager.scenario_by_task_id","text":"scenario_by_task_id ( task_id ) Gets the scenario identifier for the report generation t ask with the given ID. Parameters: Name Type Description Default task_id int ID of the task whose corresponding scenario is to be retrieved. required Returns: Type Description str Scenario identifier whose report is being generated by a process with the given task id or an empty string if there was no match. Source code in src/cplus_plugin/lib/reports/manager.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def scenario_by_task_id ( self , task_id : int ) -> str : \"\"\"Gets the scenario identifier for the report generation t ask with the given ID. :param task_id: ID of the task whose corresponding scenario is to be retrieved. :type task_id: int :returns: Scenario identifier whose report is being generated by a process with the given task id or an empty string if there was no match. :rtype: str \"\"\" scenario_ids = [ sid for sid , tid in self . _report_tasks . items () if tid == task_id ] if len ( scenario_ids ) == 0 : return \"\" return scenario_ids [ 0 ]","title":"scenario_by_task_id()"},{"location":"developer/api/core/api_reports_manager/#src.cplus_plugin.lib.reports.manager.ReportManager.view_pdf","text":"view_pdf ( result ) Opens the analysis in the host's default PDF viewer. Parameters: Name Type Description Default result ReportResult Result object from the report generation process. required Returns: Type Description bool True if the PDF was successfully loaded, else False if the result from the generation process was False. Source code in src/cplus_plugin/lib/reports/manager.py 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 @classmethod def view_pdf ( cls , result : ReportResult ) -> bool : \"\"\"Opens the analysis in the host's default PDF viewer. :param result: Result object from the report generation process. :type result: ReportResult :returns: True if the PDF was successfully loaded, else False if the result from the generation process was False. :rtype: bool \"\"\" if not result . success : return False pdf_url = QtCore . QUrl . fromLocalFile ( result . pdf_path ) if pdf_url . isEmpty (): return False return QtGui . QDesktopServices . openUrl ( pdf_url )","title":"view_pdf()"},{"location":"developer/api/core/api_reports_variables/","text":"Variable Register Manages custom variable data for report design and generation. CplusVariableInfo dataclass Contains information about a CPLUS variable within a layout scope. update_final_value update_final_value ( context ) Computes the final value of the variable to be used in the layout. Default implementation does nothing. Parameters: Name Type Description Default context ReportContext Report context object used to compute the final variable value. required Source code in src/cplus_plugin/lib/reports/variables.py 28 29 30 31 32 33 34 35 36 37 38 def update_final_value ( self , context : ReportContext ): \"\"\"Computes the final value of the variable to be used in the layout. Default implementation does nothing. :param context: Report context object used to compute the final variable value. :type context: ReportContext \"\"\" pass LayoutVariableRegister LayoutVariableRegister () Manages variables and their corresponding values for use in layout design and report generation. Source code in src/cplus_plugin/lib/reports/variables.py 131 132 133 def __init__ ( self ): self . _var_infos = {} self . _init_vars () var_name_init_values property var_name_init_values Creates a collection of variable names and their corresponding initial values. Returns: Type Description dict Collection of variable names and corresponding initial values. variable_names property variable_names Gets the names of the registered variables. Returns: Type Description list A collection of registered variable names. is_analysis_report is_analysis_report ( layout ) Checks whether the layout has been produced from a report generation process. Parameters: Name Type Description Default layout QgsPrintLayout Layout to check whether its from a report generation process. required Returns: Type Description bool True if the layout is from a report generation process, else False. Source code in src/cplus_plugin/lib/reports/variables.py 272 273 274 275 276 277 278 279 280 281 282 283 284 def is_analysis_report ( self , layout : QgsPrintLayout ) -> bool : \"\"\"Checks whether the layout has been produced from a report generation process. :param layout: Layout to check whether its from a report generation process. :type layout: QgsPrintLayout :returns: True if the layout is from a report generation process, else False. :rtype: bool \"\"\" return layout . customProperty ( self . VAR_CPLUS_REPORT_PROPERTY , False ) register_variables register_variables ( layout ) Registers custom variables and their corresponding initial values in the layout. Parameters: Name Type Description Default layout QgsPrintLayout Layout object where the custom variables will be registered. required Source code in src/cplus_plugin/lib/reports/variables.py 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 def register_variables ( self , layout : QgsPrintLayout ): \"\"\"Registers custom variables and their corresponding initial values in the layout. :param layout: Layout object where the custom variables will be registered. :type layout: QgsPrintLayout \"\"\" # If layout from analysis process, do not register # the variables. if self . is_analysis_report ( layout ): return # Remove any duplicate cplus variable names and values var_names , var_values = self . remove_variables ( layout ) # Get cplus variable names and corresponding initial values var_name_init_values = self . var_name_init_values for var_name , init_value in var_name_init_values . items (): var_names . append ( var_name ) var_values . append ( init_value ) layout . setCustomProperty ( self . VAR_NAMES_PROPERTY , var_names ) layout . setCustomProperty ( self . VAR_VALUES_PROPERTY , var_values ) remove_var_name_in_collection classmethod remove_var_name_in_collection ( cplus_var_name , layout_var_names , layout_var_values ) Remove cplus variable name matches and corresponding values in the layout variable name/value mapping. Source code in src/cplus_plugin/lib/reports/variables.py 234 235 236 237 238 239 240 241 242 243 244 245 246 247 @classmethod def remove_var_name_in_collection ( cls , cplus_var_name : str , layout_var_names : typing . List [ str ], layout_var_values : typing . List [ str ], ): \"\"\"Remove cplus variable name matches and corresponding values in the layout variable name/value mapping. \"\"\" while cplus_var_name in layout_var_names : idx = layout_var_names . index ( cplus_var_name ) _ = layout_var_names . pop ( idx ) _ = layout_var_values . pop ( idx ) remove_variables remove_variables ( layout ) Removes duplicate variable names from the layout, this is done prior to registering new ones. Parameters: Name Type Description Default layout QgsPrintLayout Layout whose cplus variables are to be removed. required Returns: Type Description tuple Tuple only containing non-cplus variable names and corresponding values respectively. Source code in src/cplus_plugin/lib/reports/variables.py 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 def remove_variables ( self , layout : QgsPrintLayout ) -> typing . Tuple [ typing . List , typing . List ]: \"\"\"Removes duplicate variable names from the layout, this is done prior to registering new ones. :param layout: Layout whose cplus variables are to be removed. :type layout: QgsPrintLayout :returns: Tuple only containing non-cplus variable names and corresponding values respectively. :rtype: tuple \"\"\" cplus_var_names = self . variable_names var_names = layout . customProperty ( self . VAR_NAMES_PROPERTY , list ()) var_values = layout . customProperty ( self . VAR_VALUES_PROPERTY , list ()) # Remove only cplus variable names and values for cvn in cplus_var_names : self . remove_var_name_in_collection ( cvn , var_names , var_values ) return var_names , var_values set_report_flag set_report_flag ( layout ) Set a flag indicating that the layout has been produced from a report generation process. Parameters: Name Type Description Default layout QgsPrintLayout Layout to add the flag as a custom property. required Source code in src/cplus_plugin/lib/reports/variables.py 311 312 313 314 315 316 317 318 def set_report_flag ( self , layout : QgsPrintLayout ): \"\"\"Set a flag indicating that the layout has been produced from a report generation process. :param layout: Layout to add the flag as a custom property. :type layout: QgsPrintLayout \"\"\" layout . setCustomProperty ( self . VAR_CPLUS_REPORT_PROPERTY , True ) update_variables update_variables ( layout , context ) Update the values for the CPLUS variables in the layout. Parameters: Name Type Description Default layout QgsPrintLayout Layout object whose CPLUS variable values will be updated. required context ReportContext Context object containing the report information that will be used for computing the final value of the variable during the report generation process. required Source code in src/cplus_plugin/lib/reports/variables.py 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 def update_variables ( self , layout : QgsPrintLayout , context : ReportContext ): \"\"\"Update the values for the CPLUS variables in the layout. :param layout: Layout object whose CPLUS variable values will be updated. :type layout: QgsPrintLayout :param context: Context object containing the report information that will be used for computing the final value of the variable during the report generation process. :type context: ReportContext \"\"\" exp_scope = QgsExpressionContextUtils . layoutScope ( layout ) var_names = exp_scope . variableNames () var_values = [] vn = list ( self . _var_infos . keys ()) for name in var_names : if name in self . _var_infos : var_info = self . _var_infos [ name ] var_info . update_final_value ( context ) var_values . append ( var_info . final_value ) else : if not exp_scope . hasVariable ( name ): continue value = exp_scope . variable ( name ) var_values . append ( value ) layout . setCustomProperty ( self . VAR_NAMES_PROPERTY , var_names ) layout . setCustomProperty ( self . VAR_VALUES_PROPERTY , var_values ) layout . refresh () ScenarioDescriptionVariableInfo dataclass Bases: CplusVariableInfo Metadata for a scenario description variable. update_final_value update_final_value ( context ) Set the scenario description. Source code in src/cplus_plugin/lib/reports/variables.py 116 117 118 def update_final_value ( self , context : ReportContext ): \"\"\"Set the scenario description.\"\"\" self . final_value = context . scenario . description ScenarioNameVariableInfo dataclass Bases: CplusVariableInfo Metadata for a scenario name variable. update_final_value update_final_value ( context ) Set the scenario name. Source code in src/cplus_plugin/lib/reports/variables.py 94 95 96 def update_final_value ( self , context : ReportContext ): \"\"\"Set the scenario name.\"\"\" self . final_value = context . scenario . name SettingsVariableInfo dataclass Bases: CplusVariableInfo Metadata for a settings-related variable. update_final_value update_final_value ( context ) Computes the final value of the variable to be used in the layout. Fetches the latest settings value. Parameters: Name Type Description Default context ReportContext Report context object used to compute the final variable value. required Source code in src/cplus_plugin/lib/reports/variables.py 64 65 66 67 68 69 70 71 72 73 74 def update_final_value ( self , context : ReportContext ): \"\"\"Computes the final value of the variable to be used in the layout. Fetches the latest settings value. :param context: Report context object used to compute the final variable value. :type context: ReportContext \"\"\" self . final_value = self . _get_setting_value () create_bulleted_text create_bulleted_text ( main_text , bulleted_items ) Returns string containing text and bulleted/dashed text below it. Parameters: Name Type Description Default main_text str Primary non-bulleted text. required bulleted_items List [ str ] List containing bulleted items that will be rendered below the main text. required Returns: Type Description str Text containing primary text with bulleted items below it. Source code in src/cplus_plugin/lib/reports/variables.py 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 def create_bulleted_text ( main_text : str , bulleted_items : typing . List [ str ]) -> str : \"\"\"Returns string containing text and bulleted/dashed text below it. :param main_text: Primary non-bulleted text. :type main_text: str :param bulleted_items: List containing bulleted items that will be rendered below the main text. :type bulleted_items: list :returns: Text containing primary text with bulleted items below it. :rtype: str \"\"\" bulleted_items = \" \\n - \" . join ( bulleted_items ) if not main_text : return f \"- { bulleted_items } \" return f \" { main_text } \\n - { bulleted_items } \"","title":"Variables"},{"location":"developer/api/core/api_reports_variables/#variable-register","text":"Manages custom variable data for report design and generation.","title":"Variable Register"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.CplusVariableInfo","text":"Contains information about a CPLUS variable within a layout scope.","title":"CplusVariableInfo"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.CplusVariableInfo.update_final_value","text":"update_final_value ( context ) Computes the final value of the variable to be used in the layout. Default implementation does nothing. Parameters: Name Type Description Default context ReportContext Report context object used to compute the final variable value. required Source code in src/cplus_plugin/lib/reports/variables.py 28 29 30 31 32 33 34 35 36 37 38 def update_final_value ( self , context : ReportContext ): \"\"\"Computes the final value of the variable to be used in the layout. Default implementation does nothing. :param context: Report context object used to compute the final variable value. :type context: ReportContext \"\"\" pass","title":"update_final_value()"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.LayoutVariableRegister","text":"LayoutVariableRegister () Manages variables and their corresponding values for use in layout design and report generation. Source code in src/cplus_plugin/lib/reports/variables.py 131 132 133 def __init__ ( self ): self . _var_infos = {} self . _init_vars ()","title":"LayoutVariableRegister"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.LayoutVariableRegister.var_name_init_values","text":"var_name_init_values Creates a collection of variable names and their corresponding initial values. Returns: Type Description dict Collection of variable names and corresponding initial values.","title":"var_name_init_values"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.LayoutVariableRegister.variable_names","text":"variable_names Gets the names of the registered variables. Returns: Type Description list A collection of registered variable names.","title":"variable_names"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.LayoutVariableRegister.is_analysis_report","text":"is_analysis_report ( layout ) Checks whether the layout has been produced from a report generation process. Parameters: Name Type Description Default layout QgsPrintLayout Layout to check whether its from a report generation process. required Returns: Type Description bool True if the layout is from a report generation process, else False. Source code in src/cplus_plugin/lib/reports/variables.py 272 273 274 275 276 277 278 279 280 281 282 283 284 def is_analysis_report ( self , layout : QgsPrintLayout ) -> bool : \"\"\"Checks whether the layout has been produced from a report generation process. :param layout: Layout to check whether its from a report generation process. :type layout: QgsPrintLayout :returns: True if the layout is from a report generation process, else False. :rtype: bool \"\"\" return layout . customProperty ( self . VAR_CPLUS_REPORT_PROPERTY , False )","title":"is_analysis_report()"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.LayoutVariableRegister.register_variables","text":"register_variables ( layout ) Registers custom variables and their corresponding initial values in the layout. Parameters: Name Type Description Default layout QgsPrintLayout Layout object where the custom variables will be registered. required Source code in src/cplus_plugin/lib/reports/variables.py 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 def register_variables ( self , layout : QgsPrintLayout ): \"\"\"Registers custom variables and their corresponding initial values in the layout. :param layout: Layout object where the custom variables will be registered. :type layout: QgsPrintLayout \"\"\" # If layout from analysis process, do not register # the variables. if self . is_analysis_report ( layout ): return # Remove any duplicate cplus variable names and values var_names , var_values = self . remove_variables ( layout ) # Get cplus variable names and corresponding initial values var_name_init_values = self . var_name_init_values for var_name , init_value in var_name_init_values . items (): var_names . append ( var_name ) var_values . append ( init_value ) layout . setCustomProperty ( self . VAR_NAMES_PROPERTY , var_names ) layout . setCustomProperty ( self . VAR_VALUES_PROPERTY , var_values )","title":"register_variables()"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.LayoutVariableRegister.remove_var_name_in_collection","text":"remove_var_name_in_collection ( cplus_var_name , layout_var_names , layout_var_values ) Remove cplus variable name matches and corresponding values in the layout variable name/value mapping. Source code in src/cplus_plugin/lib/reports/variables.py 234 235 236 237 238 239 240 241 242 243 244 245 246 247 @classmethod def remove_var_name_in_collection ( cls , cplus_var_name : str , layout_var_names : typing . List [ str ], layout_var_values : typing . List [ str ], ): \"\"\"Remove cplus variable name matches and corresponding values in the layout variable name/value mapping. \"\"\" while cplus_var_name in layout_var_names : idx = layout_var_names . index ( cplus_var_name ) _ = layout_var_names . pop ( idx ) _ = layout_var_values . pop ( idx )","title":"remove_var_name_in_collection()"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.LayoutVariableRegister.remove_variables","text":"remove_variables ( layout ) Removes duplicate variable names from the layout, this is done prior to registering new ones. Parameters: Name Type Description Default layout QgsPrintLayout Layout whose cplus variables are to be removed. required Returns: Type Description tuple Tuple only containing non-cplus variable names and corresponding values respectively. Source code in src/cplus_plugin/lib/reports/variables.py 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 def remove_variables ( self , layout : QgsPrintLayout ) -> typing . Tuple [ typing . List , typing . List ]: \"\"\"Removes duplicate variable names from the layout, this is done prior to registering new ones. :param layout: Layout whose cplus variables are to be removed. :type layout: QgsPrintLayout :returns: Tuple only containing non-cplus variable names and corresponding values respectively. :rtype: tuple \"\"\" cplus_var_names = self . variable_names var_names = layout . customProperty ( self . VAR_NAMES_PROPERTY , list ()) var_values = layout . customProperty ( self . VAR_VALUES_PROPERTY , list ()) # Remove only cplus variable names and values for cvn in cplus_var_names : self . remove_var_name_in_collection ( cvn , var_names , var_values ) return var_names , var_values","title":"remove_variables()"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.LayoutVariableRegister.set_report_flag","text":"set_report_flag ( layout ) Set a flag indicating that the layout has been produced from a report generation process. Parameters: Name Type Description Default layout QgsPrintLayout Layout to add the flag as a custom property. required Source code in src/cplus_plugin/lib/reports/variables.py 311 312 313 314 315 316 317 318 def set_report_flag ( self , layout : QgsPrintLayout ): \"\"\"Set a flag indicating that the layout has been produced from a report generation process. :param layout: Layout to add the flag as a custom property. :type layout: QgsPrintLayout \"\"\" layout . setCustomProperty ( self . VAR_CPLUS_REPORT_PROPERTY , True )","title":"set_report_flag()"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.LayoutVariableRegister.update_variables","text":"update_variables ( layout , context ) Update the values for the CPLUS variables in the layout. Parameters: Name Type Description Default layout QgsPrintLayout Layout object whose CPLUS variable values will be updated. required context ReportContext Context object containing the report information that will be used for computing the final value of the variable during the report generation process. required Source code in src/cplus_plugin/lib/reports/variables.py 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 def update_variables ( self , layout : QgsPrintLayout , context : ReportContext ): \"\"\"Update the values for the CPLUS variables in the layout. :param layout: Layout object whose CPLUS variable values will be updated. :type layout: QgsPrintLayout :param context: Context object containing the report information that will be used for computing the final value of the variable during the report generation process. :type context: ReportContext \"\"\" exp_scope = QgsExpressionContextUtils . layoutScope ( layout ) var_names = exp_scope . variableNames () var_values = [] vn = list ( self . _var_infos . keys ()) for name in var_names : if name in self . _var_infos : var_info = self . _var_infos [ name ] var_info . update_final_value ( context ) var_values . append ( var_info . final_value ) else : if not exp_scope . hasVariable ( name ): continue value = exp_scope . variable ( name ) var_values . append ( value ) layout . setCustomProperty ( self . VAR_NAMES_PROPERTY , var_names ) layout . setCustomProperty ( self . VAR_VALUES_PROPERTY , var_values ) layout . refresh ()","title":"update_variables()"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.ScenarioDescriptionVariableInfo","text":"Bases: CplusVariableInfo Metadata for a scenario description variable.","title":"ScenarioDescriptionVariableInfo"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.ScenarioDescriptionVariableInfo.update_final_value","text":"update_final_value ( context ) Set the scenario description. Source code in src/cplus_plugin/lib/reports/variables.py 116 117 118 def update_final_value ( self , context : ReportContext ): \"\"\"Set the scenario description.\"\"\" self . final_value = context . scenario . description","title":"update_final_value()"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.ScenarioNameVariableInfo","text":"Bases: CplusVariableInfo Metadata for a scenario name variable.","title":"ScenarioNameVariableInfo"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.ScenarioNameVariableInfo.update_final_value","text":"update_final_value ( context ) Set the scenario name. Source code in src/cplus_plugin/lib/reports/variables.py 94 95 96 def update_final_value ( self , context : ReportContext ): \"\"\"Set the scenario name.\"\"\" self . final_value = context . scenario . name","title":"update_final_value()"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.SettingsVariableInfo","text":"Bases: CplusVariableInfo Metadata for a settings-related variable.","title":"SettingsVariableInfo"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.SettingsVariableInfo.update_final_value","text":"update_final_value ( context ) Computes the final value of the variable to be used in the layout. Fetches the latest settings value. Parameters: Name Type Description Default context ReportContext Report context object used to compute the final variable value. required Source code in src/cplus_plugin/lib/reports/variables.py 64 65 66 67 68 69 70 71 72 73 74 def update_final_value ( self , context : ReportContext ): \"\"\"Computes the final value of the variable to be used in the layout. Fetches the latest settings value. :param context: Report context object used to compute the final variable value. :type context: ReportContext \"\"\" self . final_value = self . _get_setting_value ()","title":"update_final_value()"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.create_bulleted_text","text":"create_bulleted_text ( main_text , bulleted_items ) Returns string containing text and bulleted/dashed text below it. Parameters: Name Type Description Default main_text str Primary non-bulleted text. required bulleted_items List [ str ] List containing bulleted items that will be rendered below the main text. required Returns: Type Description str Text containing primary text with bulleted items below it. Source code in src/cplus_plugin/lib/reports/variables.py 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 def create_bulleted_text ( main_text : str , bulleted_items : typing . List [ str ]) -> str : \"\"\"Returns string containing text and bulleted/dashed text below it. :param main_text: Primary non-bulleted text. :type main_text: str :param bulleted_items: List containing bulleted items that will be rendered below the main text. :type bulleted_items: list :returns: Text containing primary text with bulleted items below it. :rtype: str \"\"\" bulleted_items = \" \\n - \" . join ( bulleted_items ) if not main_text : return f \"- { bulleted_items } \" return f \" { main_text } \\n - { bulleted_items } \"","title":"create_bulleted_text()"},{"location":"developer/api/core/api_settings/","text":"Settings Plugin global settings. Covers the plugin global settings which a user can set and save. The settings will be saved using QgsSettings. Settings can be accessed via the QGIS options, a button on the docking widget, and from the toolbar menu. CplusOptionsFactory CplusOptionsFactory () Bases: QgsOptionsWidgetFactory Options factory initializes the CPLUS settings. Class which creates the widget requied for the CPLUS settings. QgsOptionsWidgetFactory is used to accomplish this. QGIS CPLUS Plugin Settings factory. Source code in src/cplus_plugin/settings.py 332 333 334 335 336 def __init__ ( self ) -> None : \"\"\"QGIS CPLUS Plugin Settings factory.\"\"\" super () . __init__ () self . setTitle ( OPTIONS_TITLE ) createWidget createWidget ( parent ) Creates a widget for CPLUS settings. Parameters: Name Type Description Default parent QWidget Parent widget required Returns: Type Description CplusSettings Widget to be used in the QGIS options Source code in src/cplus_plugin/settings.py 347 348 349 350 351 352 353 354 355 356 357 def createWidget ( self , parent : QWidget ) -> CplusSettings : \"\"\"Creates a widget for CPLUS settings. :param parent: Parent widget :type parent: QWidget :returns: Widget to be used in the QGIS options :rtype: CplusSettings \"\"\" return CplusSettings ( parent ) icon icon () Returns the icon which will be used for the CPLUS options tab. Returns: Type Description QIcon An icon object which contains the provided custom icon Source code in src/cplus_plugin/settings.py 338 339 340 341 342 343 344 345 def icon ( self ) -> QIcon : \"\"\"Returns the icon which will be used for the CPLUS options tab. :returns: An icon object which contains the provided custom icon :rtype: QIcon \"\"\" return QIcon ( ICON_PATH ) CplusSettings CplusSettings ( parent = None ) Bases: Ui_DlgSettings , QgsOptionsPageWidget QGIS CPLUS Plugin Settings dialog. Source code in src/cplus_plugin/settings.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def __init__ ( self , parent = None ) -> None : \"\"\"QGIS CPLUS Plugin Settings dialog.\"\"\" QgsOptionsPageWidget . __init__ ( self , parent ) self . setupUi ( self ) self . message_bar = qgis . gui . QgsMessageBar ( self ) self . layout () . insertWidget ( 0 , self . message_bar ) self . settings = qgis . core . QgsSettings () settings_manager . settings_updated [ str , object ] . connect ( self . on_settings_changed ) # Connections self . cb_custom_logo . stateChanged . connect ( self . logo_state_changed ) self . logo_file . fileChanged . connect ( self . logo_file_changed ) self . folder_data . fileChanged . connect ( self . base_dir_exists ) message_bar instance-attribute message_bar = qgis . gui . QgsMessageBar ( self ) CPLUS plugin settings class. Class which manages the CPLUS settings. Initilizes the UI, which can be accessed from the menu drop-down or the QGIS settings. apply apply () This is called on OK click in the QGIS options panel. Source code in src/cplus_plugin/settings.py 66 67 68 69 def apply ( self ) -> None : \"\"\"This is called on OK click in the QGIS options panel.\"\"\" self . save_settings () base_dir_exists base_dir_exists () Checks if the provided base directory exists. A warning messages is presented if the directory does not exist. Returns: Type Description bool Whether the base directory exists Source code in src/cplus_plugin/settings.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 def base_dir_exists ( self ) -> bool : \"\"\"Checks if the provided base directory exists. A warning messages is presented if the directory does not exist. :returns: Whether the base directory exists :rtype: bool \"\"\" # Clears the error messages when doing next check self . message_bar . clearWidgets () folder_found = False base_dir_path = self . folder_data . filePath () if not os . path . exists ( base_dir_path ): # File not found self . message_bar . pushWarning ( \"CPLUS - Base directory not found: \" , base_dir_path ) else : folder_found = True return folder_found closeEvent closeEvent ( event ) When closing the setings. Parameters: Name Type Description Default event QShowEvent Event that has been triggered required Source code in src/cplus_plugin/settings.py 315 316 317 318 319 320 321 322 def closeEvent ( self , event : QShowEvent ) -> None : \"\"\"When closing the setings. :param event: Event that has been triggered :type event: QShowEvent \"\"\" super () . closeEvent ( event ) load_settings load_settings () Loads the settings and displays it in the options UI Source code in src/cplus_plugin/settings.py 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 def load_settings ( self ) -> None : \"\"\"Loads the settings and displays it in the options UI\"\"\" # Analysis configuration settings # Report settings organization = settings_manager . get_value ( Settings . REPORT_ORGANIZATION , default = \"\" ) self . txt_organization . setText ( organization ) email = settings_manager . get_value ( Settings . REPORT_CONTACT_EMAIL , default = \"\" ) self . txt_email . setText ( email ) website = settings_manager . get_value ( Settings . REPORT_WEBSITE , default = \"\" ) self . txt_website . setText ( website ) custom_logo = int ( settings_manager . get_value ( Settings . REPORT_CUSTOM_LOGO , default = True , ) ) self . cb_custom_logo . setCheckState ( custom_logo ) self . logo_file . setEnabled ( custom_logo ) custom_logo_dir = settings_manager . get_value ( Settings . REPORT_LOGO_DIR , default = DEFAULT_LOGO_PATH ) self . logo_file . setFilePath ( custom_logo_dir ) self . update_logo ( custom_logo , custom_logo_dir ) footer = settings_manager . get_value ( Settings . REPORT_FOOTER , default = \"\" ) self . txt_footer . setPlainText ( footer ) disclaimer = settings_manager . get_value ( Settings . REPORT_DISCLAIMER , default = \"\" ) self . txt_disclaimer . setPlainText ( disclaimer ) report_license = settings_manager . get_value ( Settings . REPORT_LICENSE , default = \"\" ) self . txt_license . setText ( report_license ) # Advanced settings base_dir = settings_manager . get_value ( Settings . BASE_DIR , default = \"\" ) self . folder_data . setFilePath ( base_dir ) self . base_dir_exists () # Carbon layers coefficient coefficient = settings_manager . get_value ( Settings . CARBON_COEFFICIENT , default = 0.0 ) self . carbon_coefficient_box . setValue ( float ( coefficient )) # Pathway suitability index pathway_suitability_index = settings_manager . get_value ( Settings . PATHWAY_SUITABILITY_INDEX , default = 0 ) self . suitability_index_box . setValue ( float ( pathway_suitability_index )) logo_file_changed logo_file_changed () Called when the logo file directory changes. Will update the logo preview. Source code in src/cplus_plugin/settings.py 128 129 130 131 132 133 134 135 def logo_file_changed ( self ): \"\"\"Called when the logo file directory changes. Will update the logo preview. \"\"\" custom_logo = self . cb_custom_logo . checkState () custom_logo_path = self . logo_file . filePath () self . update_logo ( custom_logo , custom_logo_path ) logo_file_exists logo_file_exists () Checks if the provided logo directory exists. A warning messages is presented if the file cannot be found. Returns: Type Description bool Whether the logo file exists Source code in src/cplus_plugin/settings.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def logo_file_exists ( self ) -> bool : \"\"\"Checks if the provided logo directory exists. A warning messages is presented if the file cannot be found. :returns: Whether the logo file exists :rtype: bool \"\"\" # Clears the error messages when doing next check self . message_bar . clearWidgets () file_found = False custom_logo_path = self . logo_file . filePath () if not os . path . exists ( custom_logo_path ): # File not found self . message_bar . pushWarning ( \"CPLUS - Custom logo not found: \" , custom_logo_path ) else : file_found = True # File found return file_found logo_state_changed logo_state_changed () Called when the custom logo option is disabled or enabled. Will update the logo preview. Source code in src/cplus_plugin/settings.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 def logo_state_changed ( self ) -> None : \"\"\"Called when the custom logo option is disabled or enabled. Will update the logo preview. \"\"\" custom_logo = self . cb_custom_logo . checkState () custom_logo_path = self . logo_file . filePath () # Enables/disables the file widget for the logo directory if custom_logo : self . logo_file . setEnabled ( True ) else : self . logo_file . setEnabled ( False ) self . update_logo ( custom_logo , custom_logo_path ) on_settings_changed on_settings_changed ( name , value ) Slot raised when settings has been changed. Parameters: Name Type Description Default name str Name of the setting that has changed. required value Any New value for the given settings name. required Source code in src/cplus_plugin/settings.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def on_settings_changed ( self , name : str , value : typing . Any ): \"\"\"Slot raised when settings has been changed. :param name: Name of the setting that has changed. :type name: str :param value: New value for the given settings name. :type value: Any \"\"\" # Create NCS pathway subdirectory if base directory has changed. if name == Settings . BASE_DIR . value : if not value : return FileUtils . create_ncs_pathways_dir ( value ) FileUtils . create_ncs_carbon_dir ( value ) FileUtils . create_pwls_dir ( value ) save_settings save_settings () Saves the settings. Also does error checking for settings (e.g if the custom logo exists). Will present the user with an error message if an issue is found. Source code in src/cplus_plugin/settings.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 def save_settings ( self ) -> None : \"\"\"Saves the settings. Also does error checking for settings (e.g if the custom logo exists). Will present the user with an error message if an issue is found. \"\"\" # Analysis configuration # Report settings organization = self . txt_organization . text () settings_manager . set_value ( Settings . REPORT_ORGANIZATION , organization ) email = self . txt_email . text () settings_manager . set_value ( Settings . REPORT_CONTACT_EMAIL , email ) website = self . txt_website . text () settings_manager . set_value ( Settings . REPORT_WEBSITE , website ) custom_logo = self . cb_custom_logo . checkState () settings_manager . set_value ( Settings . REPORT_CUSTOM_LOGO , custom_logo ) # Checks if the logo file exists if custom logo is enabled if custom_logo : custom_logo_path = self . logo_file . filePath () settings_manager . set_value ( Settings . REPORT_LOGO_DIR , custom_logo_path ) if not os . path . exists ( custom_logo_path ): # File not found, disable custom logo settings_manager . set_value ( Settings . REPORT_CUSTOM_LOGO , False ) iface . messageBar () . pushWarning ( \"CPLUS - Custom logo not found, disabled: \" , custom_logo_path ) footer = self . txt_footer . toPlainText () settings_manager . set_value ( Settings . REPORT_FOOTER , footer ) disclaimer = self . txt_disclaimer . toPlainText () settings_manager . set_value ( Settings . REPORT_DISCLAIMER , disclaimer ) report_license = self . txt_license . text () settings_manager . set_value ( Settings . REPORT_LICENSE , report_license ) # Advanced settings base_dir_path = self . folder_data . filePath () settings_manager . set_value ( Settings . BASE_DIR , base_dir_path ) # Carbon layers coefficient saving coefficient = self . carbon_coefficient_box . value () settings_manager . set_value ( Settings . CARBON_COEFFICIENT , coefficient ) # Pathway suitability index pathway_suitability_index = self . suitability_index_box . value () settings_manager . set_value ( Settings . PATHWAY_SUITABILITY_INDEX , pathway_suitability_index ) # Checks if the provided base directory exists if not os . path . exists ( base_dir_path ): iface . messageBar () . pushCritical ( \"CPLUS - Base directory not found: \" , base_dir_path ) showEvent showEvent ( event ) Show event being called. This will display the plugin settings. The stored/saved settings will be loaded. Parameters: Name Type Description Default event QShowEvent Event that has been triggered required Source code in src/cplus_plugin/settings.py 304 305 306 307 308 309 310 311 312 313 def showEvent ( self , event : QShowEvent ) -> None : \"\"\"Show event being called. This will display the plugin settings. The stored/saved settings will be loaded. :param event: Event that has been triggered :type event: QShowEvent \"\"\" super () . showEvent ( event ) self . load_settings () update_logo update_logo ( custom_logo , logo_dir = DEFAULT_LOGO_PATH ) Updates the logo preview. If the logo is not found, the default logo will be used. Parameters: Name Type Description Default custom_logo bool If a custom logo should be used required logo_dir str The custom logo directory DEFAULT_LOGO_PATH Source code in src/cplus_plugin/settings.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def update_logo ( self , custom_logo , logo_dir = DEFAULT_LOGO_PATH ): \"\"\"Updates the logo preview. If the logo is not found, the default logo will be used. :param custom_logo: If a custom logo should be used :type custom_logo: bool :param logo_dir: The custom logo directory :type logo_dir: str \"\"\" logo_found = False if custom_logo : # If custom logo is active, check if the provided directory exists logo_found = self . logo_file_exists () if custom_logo and logo_found : # If custom logo is enabled and the logo file exists pixmap = QPixmap ( logo_dir ) else : # If custom logo is disabled. The default logo will also be used when the custom logo does not exist pixmap = QPixmap ( DEFAULT_LOGO_PATH ) self . lbl_logo_image . setPixmap ( pixmap )","title":"Settings"},{"location":"developer/api/core/api_settings/#settings","text":"Plugin global settings. Covers the plugin global settings which a user can set and save. The settings will be saved using QgsSettings. Settings can be accessed via the QGIS options, a button on the docking widget, and from the toolbar menu.","title":"Settings"},{"location":"developer/api/core/api_settings/#src.cplus_plugin.settings.CplusOptionsFactory","text":"CplusOptionsFactory () Bases: QgsOptionsWidgetFactory Options factory initializes the CPLUS settings. Class which creates the widget requied for the CPLUS settings. QgsOptionsWidgetFactory is used to accomplish this. QGIS CPLUS Plugin Settings factory. Source code in src/cplus_plugin/settings.py 332 333 334 335 336 def __init__ ( self ) -> None : \"\"\"QGIS CPLUS Plugin Settings factory.\"\"\" super () . __init__ () self . setTitle ( OPTIONS_TITLE )","title":"CplusOptionsFactory"},{"location":"developer/api/core/api_settings/#src.cplus_plugin.settings.CplusOptionsFactory.createWidget","text":"createWidget ( parent ) Creates a widget for CPLUS settings. Parameters: Name Type Description Default parent QWidget Parent widget required Returns: Type Description CplusSettings Widget to be used in the QGIS options Source code in src/cplus_plugin/settings.py 347 348 349 350 351 352 353 354 355 356 357 def createWidget ( self , parent : QWidget ) -> CplusSettings : \"\"\"Creates a widget for CPLUS settings. :param parent: Parent widget :type parent: QWidget :returns: Widget to be used in the QGIS options :rtype: CplusSettings \"\"\" return CplusSettings ( parent )","title":"createWidget()"},{"location":"developer/api/core/api_settings/#src.cplus_plugin.settings.CplusOptionsFactory.icon","text":"icon () Returns the icon which will be used for the CPLUS options tab. Returns: Type Description QIcon An icon object which contains the provided custom icon Source code in src/cplus_plugin/settings.py 338 339 340 341 342 343 344 345 def icon ( self ) -> QIcon : \"\"\"Returns the icon which will be used for the CPLUS options tab. :returns: An icon object which contains the provided custom icon :rtype: QIcon \"\"\" return QIcon ( ICON_PATH )","title":"icon()"},{"location":"developer/api/core/api_settings/#src.cplus_plugin.settings.CplusSettings","text":"CplusSettings ( parent = None ) Bases: Ui_DlgSettings , QgsOptionsPageWidget QGIS CPLUS Plugin Settings dialog. Source code in src/cplus_plugin/settings.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def __init__ ( self , parent = None ) -> None : \"\"\"QGIS CPLUS Plugin Settings dialog.\"\"\" QgsOptionsPageWidget . __init__ ( self , parent ) self . setupUi ( self ) self . message_bar = qgis . gui . QgsMessageBar ( self ) self . layout () . insertWidget ( 0 , self . message_bar ) self . settings = qgis . core . QgsSettings () settings_manager . settings_updated [ str , object ] . connect ( self . on_settings_changed ) # Connections self . cb_custom_logo . stateChanged . connect ( self . logo_state_changed ) self . logo_file . fileChanged . connect ( self . logo_file_changed ) self . folder_data . fileChanged . connect ( self . base_dir_exists )","title":"CplusSettings"},{"location":"developer/api/core/api_settings/#src.cplus_plugin.settings.CplusSettings.message_bar","text":"message_bar = qgis . gui . QgsMessageBar ( self ) CPLUS plugin settings class. Class which manages the CPLUS settings. Initilizes the UI, which can be accessed from the menu drop-down or the QGIS settings.","title":"message_bar"},{"location":"developer/api/core/api_settings/#src.cplus_plugin.settings.CplusSettings.apply","text":"apply () This is called on OK click in the QGIS options panel. Source code in src/cplus_plugin/settings.py 66 67 68 69 def apply ( self ) -> None : \"\"\"This is called on OK click in the QGIS options panel.\"\"\" self . save_settings ()","title":"apply()"},{"location":"developer/api/core/api_settings/#src.cplus_plugin.settings.CplusSettings.base_dir_exists","text":"base_dir_exists () Checks if the provided base directory exists. A warning messages is presented if the directory does not exist. Returns: Type Description bool Whether the base directory exists Source code in src/cplus_plugin/settings.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 def base_dir_exists ( self ) -> bool : \"\"\"Checks if the provided base directory exists. A warning messages is presented if the directory does not exist. :returns: Whether the base directory exists :rtype: bool \"\"\" # Clears the error messages when doing next check self . message_bar . clearWidgets () folder_found = False base_dir_path = self . folder_data . filePath () if not os . path . exists ( base_dir_path ): # File not found self . message_bar . pushWarning ( \"CPLUS - Base directory not found: \" , base_dir_path ) else : folder_found = True return folder_found","title":"base_dir_exists()"},{"location":"developer/api/core/api_settings/#src.cplus_plugin.settings.CplusSettings.closeEvent","text":"closeEvent ( event ) When closing the setings. Parameters: Name Type Description Default event QShowEvent Event that has been triggered required Source code in src/cplus_plugin/settings.py 315 316 317 318 319 320 321 322 def closeEvent ( self , event : QShowEvent ) -> None : \"\"\"When closing the setings. :param event: Event that has been triggered :type event: QShowEvent \"\"\" super () . closeEvent ( event )","title":"closeEvent()"},{"location":"developer/api/core/api_settings/#src.cplus_plugin.settings.CplusSettings.load_settings","text":"load_settings () Loads the settings and displays it in the options UI Source code in src/cplus_plugin/settings.py 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 def load_settings ( self ) -> None : \"\"\"Loads the settings and displays it in the options UI\"\"\" # Analysis configuration settings # Report settings organization = settings_manager . get_value ( Settings . REPORT_ORGANIZATION , default = \"\" ) self . txt_organization . setText ( organization ) email = settings_manager . get_value ( Settings . REPORT_CONTACT_EMAIL , default = \"\" ) self . txt_email . setText ( email ) website = settings_manager . get_value ( Settings . REPORT_WEBSITE , default = \"\" ) self . txt_website . setText ( website ) custom_logo = int ( settings_manager . get_value ( Settings . REPORT_CUSTOM_LOGO , default = True , ) ) self . cb_custom_logo . setCheckState ( custom_logo ) self . logo_file . setEnabled ( custom_logo ) custom_logo_dir = settings_manager . get_value ( Settings . REPORT_LOGO_DIR , default = DEFAULT_LOGO_PATH ) self . logo_file . setFilePath ( custom_logo_dir ) self . update_logo ( custom_logo , custom_logo_dir ) footer = settings_manager . get_value ( Settings . REPORT_FOOTER , default = \"\" ) self . txt_footer . setPlainText ( footer ) disclaimer = settings_manager . get_value ( Settings . REPORT_DISCLAIMER , default = \"\" ) self . txt_disclaimer . setPlainText ( disclaimer ) report_license = settings_manager . get_value ( Settings . REPORT_LICENSE , default = \"\" ) self . txt_license . setText ( report_license ) # Advanced settings base_dir = settings_manager . get_value ( Settings . BASE_DIR , default = \"\" ) self . folder_data . setFilePath ( base_dir ) self . base_dir_exists () # Carbon layers coefficient coefficient = settings_manager . get_value ( Settings . CARBON_COEFFICIENT , default = 0.0 ) self . carbon_coefficient_box . setValue ( float ( coefficient )) # Pathway suitability index pathway_suitability_index = settings_manager . get_value ( Settings . PATHWAY_SUITABILITY_INDEX , default = 0 ) self . suitability_index_box . setValue ( float ( pathway_suitability_index ))","title":"load_settings()"},{"location":"developer/api/core/api_settings/#src.cplus_plugin.settings.CplusSettings.logo_file_changed","text":"logo_file_changed () Called when the logo file directory changes. Will update the logo preview. Source code in src/cplus_plugin/settings.py 128 129 130 131 132 133 134 135 def logo_file_changed ( self ): \"\"\"Called when the logo file directory changes. Will update the logo preview. \"\"\" custom_logo = self . cb_custom_logo . checkState () custom_logo_path = self . logo_file . filePath () self . update_logo ( custom_logo , custom_logo_path )","title":"logo_file_changed()"},{"location":"developer/api/core/api_settings/#src.cplus_plugin.settings.CplusSettings.logo_file_exists","text":"logo_file_exists () Checks if the provided logo directory exists. A warning messages is presented if the file cannot be found. Returns: Type Description bool Whether the logo file exists Source code in src/cplus_plugin/settings.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def logo_file_exists ( self ) -> bool : \"\"\"Checks if the provided logo directory exists. A warning messages is presented if the file cannot be found. :returns: Whether the logo file exists :rtype: bool \"\"\" # Clears the error messages when doing next check self . message_bar . clearWidgets () file_found = False custom_logo_path = self . logo_file . filePath () if not os . path . exists ( custom_logo_path ): # File not found self . message_bar . pushWarning ( \"CPLUS - Custom logo not found: \" , custom_logo_path ) else : file_found = True # File found return file_found","title":"logo_file_exists()"},{"location":"developer/api/core/api_settings/#src.cplus_plugin.settings.CplusSettings.logo_state_changed","text":"logo_state_changed () Called when the custom logo option is disabled or enabled. Will update the logo preview. Source code in src/cplus_plugin/settings.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 def logo_state_changed ( self ) -> None : \"\"\"Called when the custom logo option is disabled or enabled. Will update the logo preview. \"\"\" custom_logo = self . cb_custom_logo . checkState () custom_logo_path = self . logo_file . filePath () # Enables/disables the file widget for the logo directory if custom_logo : self . logo_file . setEnabled ( True ) else : self . logo_file . setEnabled ( False ) self . update_logo ( custom_logo , custom_logo_path )","title":"logo_state_changed()"},{"location":"developer/api/core/api_settings/#src.cplus_plugin.settings.CplusSettings.on_settings_changed","text":"on_settings_changed ( name , value ) Slot raised when settings has been changed. Parameters: Name Type Description Default name str Name of the setting that has changed. required value Any New value for the given settings name. required Source code in src/cplus_plugin/settings.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def on_settings_changed ( self , name : str , value : typing . Any ): \"\"\"Slot raised when settings has been changed. :param name: Name of the setting that has changed. :type name: str :param value: New value for the given settings name. :type value: Any \"\"\" # Create NCS pathway subdirectory if base directory has changed. if name == Settings . BASE_DIR . value : if not value : return FileUtils . create_ncs_pathways_dir ( value ) FileUtils . create_ncs_carbon_dir ( value ) FileUtils . create_pwls_dir ( value )","title":"on_settings_changed()"},{"location":"developer/api/core/api_settings/#src.cplus_plugin.settings.CplusSettings.save_settings","text":"save_settings () Saves the settings. Also does error checking for settings (e.g if the custom logo exists). Will present the user with an error message if an issue is found. Source code in src/cplus_plugin/settings.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 def save_settings ( self ) -> None : \"\"\"Saves the settings. Also does error checking for settings (e.g if the custom logo exists). Will present the user with an error message if an issue is found. \"\"\" # Analysis configuration # Report settings organization = self . txt_organization . text () settings_manager . set_value ( Settings . REPORT_ORGANIZATION , organization ) email = self . txt_email . text () settings_manager . set_value ( Settings . REPORT_CONTACT_EMAIL , email ) website = self . txt_website . text () settings_manager . set_value ( Settings . REPORT_WEBSITE , website ) custom_logo = self . cb_custom_logo . checkState () settings_manager . set_value ( Settings . REPORT_CUSTOM_LOGO , custom_logo ) # Checks if the logo file exists if custom logo is enabled if custom_logo : custom_logo_path = self . logo_file . filePath () settings_manager . set_value ( Settings . REPORT_LOGO_DIR , custom_logo_path ) if not os . path . exists ( custom_logo_path ): # File not found, disable custom logo settings_manager . set_value ( Settings . REPORT_CUSTOM_LOGO , False ) iface . messageBar () . pushWarning ( \"CPLUS - Custom logo not found, disabled: \" , custom_logo_path ) footer = self . txt_footer . toPlainText () settings_manager . set_value ( Settings . REPORT_FOOTER , footer ) disclaimer = self . txt_disclaimer . toPlainText () settings_manager . set_value ( Settings . REPORT_DISCLAIMER , disclaimer ) report_license = self . txt_license . text () settings_manager . set_value ( Settings . REPORT_LICENSE , report_license ) # Advanced settings base_dir_path = self . folder_data . filePath () settings_manager . set_value ( Settings . BASE_DIR , base_dir_path ) # Carbon layers coefficient saving coefficient = self . carbon_coefficient_box . value () settings_manager . set_value ( Settings . CARBON_COEFFICIENT , coefficient ) # Pathway suitability index pathway_suitability_index = self . suitability_index_box . value () settings_manager . set_value ( Settings . PATHWAY_SUITABILITY_INDEX , pathway_suitability_index ) # Checks if the provided base directory exists if not os . path . exists ( base_dir_path ): iface . messageBar () . pushCritical ( \"CPLUS - Base directory not found: \" , base_dir_path )","title":"save_settings()"},{"location":"developer/api/core/api_settings/#src.cplus_plugin.settings.CplusSettings.showEvent","text":"showEvent ( event ) Show event being called. This will display the plugin settings. The stored/saved settings will be loaded. Parameters: Name Type Description Default event QShowEvent Event that has been triggered required Source code in src/cplus_plugin/settings.py 304 305 306 307 308 309 310 311 312 313 def showEvent ( self , event : QShowEvent ) -> None : \"\"\"Show event being called. This will display the plugin settings. The stored/saved settings will be loaded. :param event: Event that has been triggered :type event: QShowEvent \"\"\" super () . showEvent ( event ) self . load_settings ()","title":"showEvent()"},{"location":"developer/api/core/api_settings/#src.cplus_plugin.settings.CplusSettings.update_logo","text":"update_logo ( custom_logo , logo_dir = DEFAULT_LOGO_PATH ) Updates the logo preview. If the logo is not found, the default logo will be used. Parameters: Name Type Description Default custom_logo bool If a custom logo should be used required logo_dir str The custom logo directory DEFAULT_LOGO_PATH Source code in src/cplus_plugin/settings.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def update_logo ( self , custom_logo , logo_dir = DEFAULT_LOGO_PATH ): \"\"\"Updates the logo preview. If the logo is not found, the default logo will be used. :param custom_logo: If a custom logo should be used :type custom_logo: bool :param logo_dir: The custom logo directory :type logo_dir: str \"\"\" logo_found = False if custom_logo : # If custom logo is active, check if the provided directory exists logo_found = self . logo_file_exists () if custom_logo and logo_found : # If custom logo is enabled and the logo file exists pixmap = QPixmap ( logo_dir ) else : # If custom logo is disabled. The default logo will also be used when the custom logo does not exist pixmap = QPixmap ( DEFAULT_LOGO_PATH ) self . lbl_logo_image . setPixmap ( pixmap )","title":"update_logo()"},{"location":"developer/api/core/api_utils/","text":"Utilities Plugin utilities FileUtils Provides functionality for commonly used file-related operations. create_ncs_carbon_dir staticmethod create_ncs_carbon_dir ( base_dir ) Creates an NCS subdirectory for carbon layers under BASE_DIR. Skips creation of the subdirectory if it already exists. Source code in src/cplus_plugin/utils.py 268 269 270 271 272 273 274 275 276 277 278 @staticmethod def create_ncs_carbon_dir ( base_dir : str ): \"\"\"Creates an NCS subdirectory for carbon layers under BASE_DIR. Skips creation of the subdirectory if it already exists. \"\"\" if not Path ( base_dir ) . is_dir (): return ncs_carbon_dir = f \" { base_dir } / { NCS_CARBON_SEGMENT } \" message = tr ( \"Missing parent directory when creating NCS carbon subdirectory.\" ) FileUtils . create_new_dir ( ncs_carbon_dir , message ) create_ncs_pathways_dir staticmethod create_ncs_pathways_dir ( base_dir ) Creates an NCS subdirectory under BASE_DIR. Skips creation of the subdirectory if it already exists. Source code in src/cplus_plugin/utils.py 254 255 256 257 258 259 260 261 262 263 264 265 266 @staticmethod def create_ncs_pathways_dir ( base_dir : str ): \"\"\"Creates an NCS subdirectory under BASE_DIR. Skips creation of the subdirectory if it already exists. \"\"\" if not Path ( base_dir ) . is_dir (): return ncs_pathway_dir = f \" { base_dir } / { NCS_PATHWAY_SEGMENT } \" message = tr ( \"Missing parent directory when creating NCS pathways subdirectory.\" ) FileUtils . create_new_dir ( ncs_pathway_dir , message ) create_new_dir staticmethod create_new_dir ( directory , log_message = '' ) Creates new file directory if it doesn't exist Source code in src/cplus_plugin/utils.py 293 294 295 296 297 298 299 300 301 @staticmethod def create_new_dir ( directory : str , log_message : str = \"\" ): \"\"\"Creates new file directory if it doesn't exist\"\"\" p = Path ( directory ) if not p . exists (): try : p . mkdir () except FileNotFoundError : log ( log_message ) create_pwls_dir create_pwls_dir ( base_dir ) Creates priority weighting layers subdirectory under BASE_DIR. Skips creation of the subdirectory if it already exists. Source code in src/cplus_plugin/utils.py 280 281 282 283 284 285 286 287 288 289 290 291 def create_pwls_dir ( base_dir : str ): \"\"\"Creates priority weighting layers subdirectory under BASE_DIR. Skips creation of the subdirectory if it already exists. \"\"\" if not Path ( base_dir ) . is_dir (): return pwl_dir = f \" { base_dir } / { PRIORITY_LAYERS_SEGMENT } \" message = tr ( \"Missing parent directory when creating priority weighting layers subdirectory.\" ) FileUtils . create_new_dir ( pwl_dir , message ) get_icon staticmethod get_icon ( file_name ) Creates an icon based on the icon name in the 'icons' folder. Parameters: Name Type Description Default file_name str File name which should include the extension. required Returns: Type Description QtGui.QIcon Icon object matching the file name. Source code in src/cplus_plugin/utils.py 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 @staticmethod def get_icon ( file_name : str ) -> QtGui . QIcon : \"\"\"Creates an icon based on the icon name in the 'icons' folder. :param file_name: File name which should include the extension. :type file_name: str :returns: Icon object matching the file name. :rtype: QtGui.QIcon \"\"\" icon_path = os . path . normpath ( f \" { FileUtils . plugin_dir () } /icons/ { file_name } \" ) if not os . path . exists ( icon_path ): return QtGui . QIcon () return QtGui . QIcon ( icon_path ) plugin_dir staticmethod plugin_dir () Returns the root directory of the plugin. Returns: Type Description str Root directory of the plugin. Source code in src/cplus_plugin/utils.py 208 209 210 211 212 213 214 215 @staticmethod def plugin_dir () -> str : \"\"\"Returns the root directory of the plugin. :returns: Root directory of the plugin. :rtype: str \"\"\" return os . path . join ( os . path . dirname ( os . path . realpath ( __file__ ))) report_template_path staticmethod report_template_path ( file_name = None ) Get the absolute path to the template file with the given name. Caller needs to verify that the file actually exists. Parameters: Name Type Description Default file_name str Template file name including the extension. If none is specified then it will use main.qpt as the default template name. None Returns: Type Description str The absolute path to the template file with the given name. Source code in src/cplus_plugin/utils.py 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 @staticmethod def report_template_path ( file_name = None ) -> str : \"\"\"Get the absolute path to the template file with the given name. Caller needs to verify that the file actually exists. :param file_name: Template file name including the extension. If none is specified then it will use `main.qpt` as the default template name. :type file_name: str :returns: The absolute path to the template file with the given name. :rtype: str \"\"\" if file_name is None : file_name = TEMPLATE_NAME absolute_path = f \" { FileUtils . plugin_dir () } /app_data/reports/ { file_name } \" return os . path . normpath ( absolute_path ) calculate_raster_value_area calculate_raster_value_area ( layer , band_number = 1 , feedback = None ) Calculates the area of value pixels for the given band in a raster layer. Please note that this function will run in the main application thread hence for best results, it is recommended to execute it in a background process if part of a bigger workflow. Parameters: Name Type Description Default layer QgsRasterLayer Input layer whose area for value pixels is to be calculated. required band_number int Band number to compute area, default is band one. 1 feedback QgsProcessingFeedback Feedback object for progress during area calculation. None Returns: Type Description float A dictionary containing the pixel value as the key and the corresponding area in hectares as the value for all the pixels in the raster otherwise returns a empty dictionary if the raster is invalid or if it is empty. Source code in src/cplus_plugin/utils.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 def calculate_raster_value_area ( layer : QgsRasterLayer , band_number : int = 1 , feedback : QgsProcessingFeedback = None ) -> dict : \"\"\"Calculates the area of value pixels for the given band in a raster layer. Please note that this function will run in the main application thread hence for best results, it is recommended to execute it in a background process if part of a bigger workflow. :param layer: Input layer whose area for value pixels is to be calculated. :type layer: QgsRasterLayer :param band_number: Band number to compute area, default is band one. :type band_number: int :param feedback: Feedback object for progress during area calculation. :type feedback: QgsProcessingFeedback :returns: A dictionary containing the pixel value as the key and the corresponding area in hectares as the value for all the pixels in the raster otherwise returns a empty dictionary if the raster is invalid or if it is empty. :rtype: float \"\"\" if not layer . isValid (): log ( \"Invalid layer for raster area calculation.\" , info = False ) return {} algorithm_name = \"native:rasterlayeruniquevaluesreport\" params = { \"INPUT\" : layer , \"BAND\" : band_number , \"OUTPUT_TABLE\" : \"TEMPORARY_OUTPUT\" , \"OUTPUT_HTML_FILE\" : \"[Skip output]\" , } algorithm_result = processing . run ( algorithm_name , params , feedback = feedback ) # Get number of pixels with values total_pixel_count = algorithm_result [ \"TOTAL_PIXEL_COUNT\" ] if total_pixel_count == 0 : log ( \"Input layer for raster area calculation is empty.\" , info = False ) return {} output_table = algorithm_result [ \"OUTPUT_TABLE\" ] if output_table is None : log ( \"Unique values raster table could not be retrieved.\" , info = False ) return {} area_calc = QgsDistanceArea () crs = layer . crs () area_calc . setSourceCrs ( crs , QgsCoordinateTransformContext ()) if crs is not None : # Use ellipsoid calculation if available area_calc . setEllipsoid ( crs . ellipsoidAcronym ()) version = Qgis . versionInt () if version < 33000 : unit_type = QgsUnitTypes . AreaUnit . AreaHectares else : unit_type = Qgis . AreaUnit . Hectares pixel_areas = {} features = output_table . getFeatures () for f in features : pixel_value = f . attribute ( 0 ) area = f . attribute ( 2 ) pixel_value_area = area_calc . convertAreaMeasurement ( area , unit_type ) pixel_areas [ int ( pixel_value )] = pixel_value_area return pixel_areas clean_filename clean_filename ( filename ) Creates a safe filename by removing operating system invalid filename characters. Parameters: Name Type Description Default filename str File name required Source code in src/cplus_plugin/utils.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 def clean_filename ( filename ): \"\"\"Creates a safe filename by removing operating system invalid filename characters. :param filename: File name :type filename: str :returns A clean file name :rtype str \"\"\" characters = \" %:/,\\[]<>*?\" for character in characters : if character in filename : filename = filename . replace ( character , \"_\" ) return filename get_report_font get_report_font ( size = 11.0 , bold = False , italic = False ) Uses the default font family name to create a font for use in the report. Parameters: Name Type Description Default size float The font point size, default is 11. 11.0 bold bool True for bold font else False which is the default. False italic bool True for font to be in italics else False which is the default. False Returns: Type Description QtGui.QFont Font to use in a report. Source code in src/cplus_plugin/utils.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 def get_report_font ( size = 11.0 , bold = False , italic = False ) -> QtGui . QFont : \"\"\"Uses the default font family name to create a font for use in the report. :param size: The font point size, default is 11. :type size: float :param bold: True for bold font else False which is the default. :type bold: bool :param italic: True for font to be in italics else False which is the default. :type italic: bool :returns: Font to use in a report. :rtype: QtGui.QFont \"\"\" font_weight = 50 if bold is True : font_weight = 75 return QtGui . QFont ( REPORT_FONT_NAME , int ( size ), font_weight , italic ) log log ( message , name = 'qgis_cplus' , info = True , notify = True ) Logs the message into QGIS logs using qgis_cplus as the default log instance. If notify_user is True, user will be notified about the log. Parameters: Name Type Description Default message str The log message required name str Name of te log instance, qgis_cplus is the default 'qgis_cplus' info bool Whether the message is about info or a warning True notify bool Whether to notify user about the log True Source code in src/cplus_plugin/utils.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def log ( message : str , name : str = \"qgis_cplus\" , info : bool = True , notify : bool = True , ): \"\"\"Logs the message into QGIS logs using qgis_cplus as the default log instance. If notify_user is True, user will be notified about the log. :param message: The log message :type message: str :param name: Name of te log instance, qgis_cplus is the default :type message: str :param info: Whether the message is about info or a warning :type info: bool :param notify: Whether to notify user about the log :type notify: bool \"\"\" level = Qgis . Info if info else Qgis . Warning QgsMessageLog . logMessage ( message , name , level = level , notifyUser = notify , ) open_documentation open_documentation ( url = None ) Opens documentation website in the default browser Parameters: Name Type Description Default url str URL link to documentation site (e.g. gh pages site) None Source code in src/cplus_plugin/utils.py 76 77 78 79 80 81 82 83 84 85 def open_documentation ( url = None ): \"\"\"Opens documentation website in the default browser :param url: URL link to documentation site (e.g. gh pages site) :type url: str \"\"\" url = DOCUMENTATION_SITE if url is None else url result = QtGui . QDesktopServices . openUrl ( QtCore . QUrl ( url )) return result tr tr ( message ) Get the translation for a string using Qt translation API. We implement this ourselves since we do not inherit QObject. Parameters: Name Type Description Default message str, QString String for translation. required Returns: Type Description QString Translated version of message. Source code in src/cplus_plugin/utils.py 30 31 32 33 34 35 36 37 38 39 40 41 def tr ( message ): \"\"\"Get the translation for a string using Qt translation API. We implement this ourselves since we do not inherit QObject. :param message: String for translation. :type message: str, QString :returns: Translated version of message. :rtype: QString \"\"\" # noinspection PyTypeChecker,PyArgumentList,PyCallByClass return QtCore . QCoreApplication . translate ( \"QgisCplus\" , message )","title":"Utilities"},{"location":"developer/api/core/api_utils/#utilities","text":"Plugin utilities","title":"Utilities"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.FileUtils","text":"Provides functionality for commonly used file-related operations.","title":"FileUtils"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.FileUtils.create_ncs_carbon_dir","text":"create_ncs_carbon_dir ( base_dir ) Creates an NCS subdirectory for carbon layers under BASE_DIR. Skips creation of the subdirectory if it already exists. Source code in src/cplus_plugin/utils.py 268 269 270 271 272 273 274 275 276 277 278 @staticmethod def create_ncs_carbon_dir ( base_dir : str ): \"\"\"Creates an NCS subdirectory for carbon layers under BASE_DIR. Skips creation of the subdirectory if it already exists. \"\"\" if not Path ( base_dir ) . is_dir (): return ncs_carbon_dir = f \" { base_dir } / { NCS_CARBON_SEGMENT } \" message = tr ( \"Missing parent directory when creating NCS carbon subdirectory.\" ) FileUtils . create_new_dir ( ncs_carbon_dir , message )","title":"create_ncs_carbon_dir()"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.FileUtils.create_ncs_pathways_dir","text":"create_ncs_pathways_dir ( base_dir ) Creates an NCS subdirectory under BASE_DIR. Skips creation of the subdirectory if it already exists. Source code in src/cplus_plugin/utils.py 254 255 256 257 258 259 260 261 262 263 264 265 266 @staticmethod def create_ncs_pathways_dir ( base_dir : str ): \"\"\"Creates an NCS subdirectory under BASE_DIR. Skips creation of the subdirectory if it already exists. \"\"\" if not Path ( base_dir ) . is_dir (): return ncs_pathway_dir = f \" { base_dir } / { NCS_PATHWAY_SEGMENT } \" message = tr ( \"Missing parent directory when creating NCS pathways subdirectory.\" ) FileUtils . create_new_dir ( ncs_pathway_dir , message )","title":"create_ncs_pathways_dir()"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.FileUtils.create_new_dir","text":"create_new_dir ( directory , log_message = '' ) Creates new file directory if it doesn't exist Source code in src/cplus_plugin/utils.py 293 294 295 296 297 298 299 300 301 @staticmethod def create_new_dir ( directory : str , log_message : str = \"\" ): \"\"\"Creates new file directory if it doesn't exist\"\"\" p = Path ( directory ) if not p . exists (): try : p . mkdir () except FileNotFoundError : log ( log_message )","title":"create_new_dir()"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.FileUtils.create_pwls_dir","text":"create_pwls_dir ( base_dir ) Creates priority weighting layers subdirectory under BASE_DIR. Skips creation of the subdirectory if it already exists. Source code in src/cplus_plugin/utils.py 280 281 282 283 284 285 286 287 288 289 290 291 def create_pwls_dir ( base_dir : str ): \"\"\"Creates priority weighting layers subdirectory under BASE_DIR. Skips creation of the subdirectory if it already exists. \"\"\" if not Path ( base_dir ) . is_dir (): return pwl_dir = f \" { base_dir } / { PRIORITY_LAYERS_SEGMENT } \" message = tr ( \"Missing parent directory when creating priority weighting layers subdirectory.\" ) FileUtils . create_new_dir ( pwl_dir , message )","title":"create_pwls_dir()"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.FileUtils.get_icon","text":"get_icon ( file_name ) Creates an icon based on the icon name in the 'icons' folder. Parameters: Name Type Description Default file_name str File name which should include the extension. required Returns: Type Description QtGui.QIcon Icon object matching the file name. Source code in src/cplus_plugin/utils.py 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 @staticmethod def get_icon ( file_name : str ) -> QtGui . QIcon : \"\"\"Creates an icon based on the icon name in the 'icons' folder. :param file_name: File name which should include the extension. :type file_name: str :returns: Icon object matching the file name. :rtype: QtGui.QIcon \"\"\" icon_path = os . path . normpath ( f \" { FileUtils . plugin_dir () } /icons/ { file_name } \" ) if not os . path . exists ( icon_path ): return QtGui . QIcon () return QtGui . QIcon ( icon_path )","title":"get_icon()"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.FileUtils.plugin_dir","text":"plugin_dir () Returns the root directory of the plugin. Returns: Type Description str Root directory of the plugin. Source code in src/cplus_plugin/utils.py 208 209 210 211 212 213 214 215 @staticmethod def plugin_dir () -> str : \"\"\"Returns the root directory of the plugin. :returns: Root directory of the plugin. :rtype: str \"\"\" return os . path . join ( os . path . dirname ( os . path . realpath ( __file__ )))","title":"plugin_dir()"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.FileUtils.report_template_path","text":"report_template_path ( file_name = None ) Get the absolute path to the template file with the given name. Caller needs to verify that the file actually exists. Parameters: Name Type Description Default file_name str Template file name including the extension. If none is specified then it will use main.qpt as the default template name. None Returns: Type Description str The absolute path to the template file with the given name. Source code in src/cplus_plugin/utils.py 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 @staticmethod def report_template_path ( file_name = None ) -> str : \"\"\"Get the absolute path to the template file with the given name. Caller needs to verify that the file actually exists. :param file_name: Template file name including the extension. If none is specified then it will use `main.qpt` as the default template name. :type file_name: str :returns: The absolute path to the template file with the given name. :rtype: str \"\"\" if file_name is None : file_name = TEMPLATE_NAME absolute_path = f \" { FileUtils . plugin_dir () } /app_data/reports/ { file_name } \" return os . path . normpath ( absolute_path )","title":"report_template_path()"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.calculate_raster_value_area","text":"calculate_raster_value_area ( layer , band_number = 1 , feedback = None ) Calculates the area of value pixels for the given band in a raster layer. Please note that this function will run in the main application thread hence for best results, it is recommended to execute it in a background process if part of a bigger workflow. Parameters: Name Type Description Default layer QgsRasterLayer Input layer whose area for value pixels is to be calculated. required band_number int Band number to compute area, default is band one. 1 feedback QgsProcessingFeedback Feedback object for progress during area calculation. None Returns: Type Description float A dictionary containing the pixel value as the key and the corresponding area in hectares as the value for all the pixels in the raster otherwise returns a empty dictionary if the raster is invalid or if it is empty. Source code in src/cplus_plugin/utils.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 def calculate_raster_value_area ( layer : QgsRasterLayer , band_number : int = 1 , feedback : QgsProcessingFeedback = None ) -> dict : \"\"\"Calculates the area of value pixels for the given band in a raster layer. Please note that this function will run in the main application thread hence for best results, it is recommended to execute it in a background process if part of a bigger workflow. :param layer: Input layer whose area for value pixels is to be calculated. :type layer: QgsRasterLayer :param band_number: Band number to compute area, default is band one. :type band_number: int :param feedback: Feedback object for progress during area calculation. :type feedback: QgsProcessingFeedback :returns: A dictionary containing the pixel value as the key and the corresponding area in hectares as the value for all the pixels in the raster otherwise returns a empty dictionary if the raster is invalid or if it is empty. :rtype: float \"\"\" if not layer . isValid (): log ( \"Invalid layer for raster area calculation.\" , info = False ) return {} algorithm_name = \"native:rasterlayeruniquevaluesreport\" params = { \"INPUT\" : layer , \"BAND\" : band_number , \"OUTPUT_TABLE\" : \"TEMPORARY_OUTPUT\" , \"OUTPUT_HTML_FILE\" : \"[Skip output]\" , } algorithm_result = processing . run ( algorithm_name , params , feedback = feedback ) # Get number of pixels with values total_pixel_count = algorithm_result [ \"TOTAL_PIXEL_COUNT\" ] if total_pixel_count == 0 : log ( \"Input layer for raster area calculation is empty.\" , info = False ) return {} output_table = algorithm_result [ \"OUTPUT_TABLE\" ] if output_table is None : log ( \"Unique values raster table could not be retrieved.\" , info = False ) return {} area_calc = QgsDistanceArea () crs = layer . crs () area_calc . setSourceCrs ( crs , QgsCoordinateTransformContext ()) if crs is not None : # Use ellipsoid calculation if available area_calc . setEllipsoid ( crs . ellipsoidAcronym ()) version = Qgis . versionInt () if version < 33000 : unit_type = QgsUnitTypes . AreaUnit . AreaHectares else : unit_type = Qgis . AreaUnit . Hectares pixel_areas = {} features = output_table . getFeatures () for f in features : pixel_value = f . attribute ( 0 ) area = f . attribute ( 2 ) pixel_value_area = area_calc . convertAreaMeasurement ( area , unit_type ) pixel_areas [ int ( pixel_value )] = pixel_value_area return pixel_areas","title":"calculate_raster_value_area()"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.clean_filename","text":"clean_filename ( filename ) Creates a safe filename by removing operating system invalid filename characters. Parameters: Name Type Description Default filename str File name required Source code in src/cplus_plugin/utils.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 def clean_filename ( filename ): \"\"\"Creates a safe filename by removing operating system invalid filename characters. :param filename: File name :type filename: str :returns A clean file name :rtype str \"\"\" characters = \" %:/,\\[]<>*?\" for character in characters : if character in filename : filename = filename . replace ( character , \"_\" ) return filename","title":"clean_filename()"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.get_report_font","text":"get_report_font ( size = 11.0 , bold = False , italic = False ) Uses the default font family name to create a font for use in the report. Parameters: Name Type Description Default size float The font point size, default is 11. 11.0 bold bool True for bold font else False which is the default. False italic bool True for font to be in italics else False which is the default. False Returns: Type Description QtGui.QFont Font to use in a report. Source code in src/cplus_plugin/utils.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 def get_report_font ( size = 11.0 , bold = False , italic = False ) -> QtGui . QFont : \"\"\"Uses the default font family name to create a font for use in the report. :param size: The font point size, default is 11. :type size: float :param bold: True for bold font else False which is the default. :type bold: bool :param italic: True for font to be in italics else False which is the default. :type italic: bool :returns: Font to use in a report. :rtype: QtGui.QFont \"\"\" font_weight = 50 if bold is True : font_weight = 75 return QtGui . QFont ( REPORT_FONT_NAME , int ( size ), font_weight , italic )","title":"get_report_font()"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.log","text":"log ( message , name = 'qgis_cplus' , info = True , notify = True ) Logs the message into QGIS logs using qgis_cplus as the default log instance. If notify_user is True, user will be notified about the log. Parameters: Name Type Description Default message str The log message required name str Name of te log instance, qgis_cplus is the default 'qgis_cplus' info bool Whether the message is about info or a warning True notify bool Whether to notify user about the log True Source code in src/cplus_plugin/utils.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def log ( message : str , name : str = \"qgis_cplus\" , info : bool = True , notify : bool = True , ): \"\"\"Logs the message into QGIS logs using qgis_cplus as the default log instance. If notify_user is True, user will be notified about the log. :param message: The log message :type message: str :param name: Name of te log instance, qgis_cplus is the default :type message: str :param info: Whether the message is about info or a warning :type info: bool :param notify: Whether to notify user about the log :type notify: bool \"\"\" level = Qgis . Info if info else Qgis . Warning QgsMessageLog . logMessage ( message , name , level = level , notifyUser = notify , )","title":"log()"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.open_documentation","text":"open_documentation ( url = None ) Opens documentation website in the default browser Parameters: Name Type Description Default url str URL link to documentation site (e.g. gh pages site) None Source code in src/cplus_plugin/utils.py 76 77 78 79 80 81 82 83 84 85 def open_documentation ( url = None ): \"\"\"Opens documentation website in the default browser :param url: URL link to documentation site (e.g. gh pages site) :type url: str \"\"\" url = DOCUMENTATION_SITE if url is None else url result = QtGui . QDesktopServices . openUrl ( QtCore . QUrl ( url )) return result","title":"open_documentation()"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.tr","text":"tr ( message ) Get the translation for a string using Qt translation API. We implement this ourselves since we do not inherit QObject. Parameters: Name Type Description Default message str, QString String for translation. required Returns: Type Description QString Translated version of message. Source code in src/cplus_plugin/utils.py 30 31 32 33 34 35 36 37 38 39 40 41 def tr ( message ): \"\"\"Get the translation for a string using Qt translation API. We implement this ourselves since we do not inherit QObject. :param message: String for translation. :type message: str, QString :returns: Translated version of message. :rtype: QString \"\"\" # noinspection PyTypeChecker,PyArgumentList,PyCallByClass return QtCore . QCoreApplication . translate ( \"QgisCplus\" , message )","title":"tr()"},{"location":"developer/api/gui/api_carbon_layer_model/","text":"Carbon Layer Model MVC model for carbon layer paths. CarbonLayerItem CarbonLayerItem ( layer_path ) Bases: QStandardItem Represents a single carbon layer path. Source code in src/cplus_plugin/gui/carbon_item_model.py 19 20 21 22 23 24 def __init__ ( self , layer_path : str ): super () . __init__ () self . _layer_path = layer_path self . _is_valid = True self . update ( self . _layer_path ) is_valid property is_valid Returns the validity status of the carbon layer path. The path could be invalid if it does not exist or if the corresponding map layer is invalid. Returns: Type Description bool True if valid, else False. layer_path property layer_path Returns the path to the carbon layer. Returns: Type Description str Path to the carbon layer. type type () Returns the type of the standard item. Returns: Type Description int Type identifier of the carbob item. Source code in src/cplus_plugin/gui/carbon_item_model.py 71 72 73 74 75 76 77 def type ( self ) -> int : \"\"\"Returns the type of the standard item. :returns: Type identifier of the carbob item. :rtype: int \"\"\" return QtGui . QStandardItem . UserType + 5 update update ( layer_path ) Update the UI properties. Source code in src/cplus_plugin/gui/carbon_item_model.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def update ( self , layer_path : str ): \"\"\"Update the UI properties.\"\"\" self . _layer_path = str ( os . path . normpath ( layer_path )) p = Path ( self . _layer_path ) self . setText ( p . name ) self . setToolTip ( self . _layer_path ) # Check validity if p . exists (): layer = QgsRasterLayer ( layer_path ) if layer . isValid (): self . _is_valid = True self . setIcon ( QtGui . QIcon ()) else : self . _is_valid = False error_icon = FileUtils . get_icon ( \"mIndicatorLayerError.svg\" ) self . setIcon ( error_icon ) self . setToolTip ( tr ( \"Carbon layer is not invalid.\" )) else : self . _is_valid = False error_icon = FileUtils . get_icon ( \"mIndicatorLayerError.svg\" ) self . setIcon ( error_icon ) self . setToolTip ( tr ( \"File path is invalid.\" )) CarbonLayerModel CarbonLayerModel ( parent = None , carbon_paths = None ) Bases: QStandardItemModel View model for carbon layers. Source code in src/cplus_plugin/gui/carbon_item_model.py 83 84 85 86 87 88 89 90 91 def __init__ ( self , parent = None , carbon_paths : typing . Union [ typing . List [ str ], None ] = None ): super () . __init__ ( parent ) self . setColumnCount ( 1 ) if carbon_paths is not None : for cp in carbon_paths : self . add_carbon_layer ( cp ) add_carbon_layer add_carbon_layer ( layer_path ) Adds a carbon layer to the model. Parameters: Name Type Description Default layer_path str Carbon layer path. required Returns: Type Description bool True if the carbon layer was successfully added, else False if there is an existing item with the same path. Source code in src/cplus_plugin/gui/carbon_item_model.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 def add_carbon_layer ( self , layer_path : str ) -> bool : \"\"\"Adds a carbon layer to the model. :param layer_path: Carbon layer path. :type layer_path: str :returns: True if the carbon layer was successfully added, else False if there is an existing item with the same path. \"\"\" if self . contains_layer_path ( layer_path ): return False carbon_item = CarbonLayerItem ( layer_path ) self . appendRow ( carbon_item ) return True carbon_layer_index carbon_layer_index ( layer_path ) Get the model index for the given layer path. Parameters: Name Type Description Default layer_path str Carbon layer path. required Returns: Type Description QtCore.QModelIndex The index corresponding to the given layer path else an invalid index if not found. Source code in src/cplus_plugin/gui/carbon_item_model.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 def carbon_layer_index ( self , layer_path : str ) -> QtCore . QModelIndex : \"\"\"Get the model index for the given layer path. :param layer_path: Carbon layer path. :type layer_path: str :returns: The index corresponding to the given layer path else an invalid index if not found. :rtype: QtCore.QModelIndex \"\"\" norm_path = str ( os . path . normpath ( layer_path )) matching_index = None for r in range ( self . rowCount ()): index = self . index ( r , 0 ) if not index . isValid (): continue item = self . itemFromIndex ( index ) if item . layer_path == norm_path : matching_index = index break if matching_index is None : return QtCore . QModelIndex () return matching_index carbon_paths carbon_paths ( valid_only = False ) Gets all the carbon paths in the model. Parameters: Name Type Description Default valid_only bool Only return the carbon paths that are valid. False Returns: Type Description list A collection of carbon paths in the model. Source code in src/cplus_plugin/gui/carbon_item_model.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 def carbon_paths ( self , valid_only : bool = False ) -> list : \"\"\"Gets all the carbon paths in the model. :param valid_only: Only return the carbon paths that are valid. :type valid_only: bool :returns: A collection of carbon paths in the model. :rtype: list \"\"\" carbon_paths = [] for r in range ( self . rowCount ()): index = self . index ( r , 0 ) item = self . itemFromIndex ( index ) if valid_only : if item . is_valid : carbon_paths . append ( item . layer_path ) else : carbon_paths . append ( item . layer_path ) return carbon_paths contains_layer_path contains_layer_path ( layer_path ) Checks if the specified layer path exists in the model. Parameters: Name Type Description Default layer_path str Carbon layer path. required Returns: Type Description bool True if the path exists, else False. Source code in src/cplus_plugin/gui/carbon_item_model.py 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def contains_layer_path ( self , layer_path : str ) -> bool : \"\"\"Checks if the specified layer path exists in the model. :param layer_path: Carbon layer path. :type layer_path: str :returns: True if the path exists, else False. :rtype: bool \"\"\" carbon_idx = self . carbon_layer_index ( layer_path ) if carbon_idx . isValid (): return True return False update_carbon_path update_carbon_path ( index , layer_path ) Update the carbon path at the given position specified by the index. Parameters: Name Type Description Default index QModelIndex Location to modify the carbon path. required layer_path str Carbon layer path. required Returns: Type Description bool True if the path was successfully updated else False if there is no carbon item at the given location. Source code in src/cplus_plugin/gui/carbon_item_model.py 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 def update_carbon_path ( self , index : QtCore . QModelIndex , layer_path : str ) -> bool : \"\"\"Update the carbon path at the given position specified by the index. :param index: Location to modify the carbon path. :type index: QtCore.QModelIndex :param layer_path: Carbon layer path. :type layer_path: str :returns: True if the path was successfully updated else False if there is no carbon item at the given location. :rtype: bool \"\"\" if not index . isValid (): return False item = self . itemFromIndex ( index ) if item is None : return False item . update ( layer_path ) return True","title":"Carbon item model"},{"location":"developer/api/gui/api_carbon_layer_model/#carbon-layer-model","text":"MVC model for carbon layer paths.","title":"Carbon Layer Model"},{"location":"developer/api/gui/api_carbon_layer_model/#src.cplus_plugin.gui.carbon_item_model.CarbonLayerItem","text":"CarbonLayerItem ( layer_path ) Bases: QStandardItem Represents a single carbon layer path. Source code in src/cplus_plugin/gui/carbon_item_model.py 19 20 21 22 23 24 def __init__ ( self , layer_path : str ): super () . __init__ () self . _layer_path = layer_path self . _is_valid = True self . update ( self . _layer_path )","title":"CarbonLayerItem"},{"location":"developer/api/gui/api_carbon_layer_model/#src.cplus_plugin.gui.carbon_item_model.CarbonLayerItem.is_valid","text":"is_valid Returns the validity status of the carbon layer path. The path could be invalid if it does not exist or if the corresponding map layer is invalid. Returns: Type Description bool True if valid, else False.","title":"is_valid"},{"location":"developer/api/gui/api_carbon_layer_model/#src.cplus_plugin.gui.carbon_item_model.CarbonLayerItem.layer_path","text":"layer_path Returns the path to the carbon layer. Returns: Type Description str Path to the carbon layer.","title":"layer_path"},{"location":"developer/api/gui/api_carbon_layer_model/#src.cplus_plugin.gui.carbon_item_model.CarbonLayerItem.type","text":"type () Returns the type of the standard item. Returns: Type Description int Type identifier of the carbob item. Source code in src/cplus_plugin/gui/carbon_item_model.py 71 72 73 74 75 76 77 def type ( self ) -> int : \"\"\"Returns the type of the standard item. :returns: Type identifier of the carbob item. :rtype: int \"\"\" return QtGui . QStandardItem . UserType + 5","title":"type()"},{"location":"developer/api/gui/api_carbon_layer_model/#src.cplus_plugin.gui.carbon_item_model.CarbonLayerItem.update","text":"update ( layer_path ) Update the UI properties. Source code in src/cplus_plugin/gui/carbon_item_model.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def update ( self , layer_path : str ): \"\"\"Update the UI properties.\"\"\" self . _layer_path = str ( os . path . normpath ( layer_path )) p = Path ( self . _layer_path ) self . setText ( p . name ) self . setToolTip ( self . _layer_path ) # Check validity if p . exists (): layer = QgsRasterLayer ( layer_path ) if layer . isValid (): self . _is_valid = True self . setIcon ( QtGui . QIcon ()) else : self . _is_valid = False error_icon = FileUtils . get_icon ( \"mIndicatorLayerError.svg\" ) self . setIcon ( error_icon ) self . setToolTip ( tr ( \"Carbon layer is not invalid.\" )) else : self . _is_valid = False error_icon = FileUtils . get_icon ( \"mIndicatorLayerError.svg\" ) self . setIcon ( error_icon ) self . setToolTip ( tr ( \"File path is invalid.\" ))","title":"update()"},{"location":"developer/api/gui/api_carbon_layer_model/#src.cplus_plugin.gui.carbon_item_model.CarbonLayerModel","text":"CarbonLayerModel ( parent = None , carbon_paths = None ) Bases: QStandardItemModel View model for carbon layers. Source code in src/cplus_plugin/gui/carbon_item_model.py 83 84 85 86 87 88 89 90 91 def __init__ ( self , parent = None , carbon_paths : typing . Union [ typing . List [ str ], None ] = None ): super () . __init__ ( parent ) self . setColumnCount ( 1 ) if carbon_paths is not None : for cp in carbon_paths : self . add_carbon_layer ( cp )","title":"CarbonLayerModel"},{"location":"developer/api/gui/api_carbon_layer_model/#src.cplus_plugin.gui.carbon_item_model.CarbonLayerModel.add_carbon_layer","text":"add_carbon_layer ( layer_path ) Adds a carbon layer to the model. Parameters: Name Type Description Default layer_path str Carbon layer path. required Returns: Type Description bool True if the carbon layer was successfully added, else False if there is an existing item with the same path. Source code in src/cplus_plugin/gui/carbon_item_model.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 def add_carbon_layer ( self , layer_path : str ) -> bool : \"\"\"Adds a carbon layer to the model. :param layer_path: Carbon layer path. :type layer_path: str :returns: True if the carbon layer was successfully added, else False if there is an existing item with the same path. \"\"\" if self . contains_layer_path ( layer_path ): return False carbon_item = CarbonLayerItem ( layer_path ) self . appendRow ( carbon_item ) return True","title":"add_carbon_layer()"},{"location":"developer/api/gui/api_carbon_layer_model/#src.cplus_plugin.gui.carbon_item_model.CarbonLayerModel.carbon_layer_index","text":"carbon_layer_index ( layer_path ) Get the model index for the given layer path. Parameters: Name Type Description Default layer_path str Carbon layer path. required Returns: Type Description QtCore.QModelIndex The index corresponding to the given layer path else an invalid index if not found. Source code in src/cplus_plugin/gui/carbon_item_model.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 def carbon_layer_index ( self , layer_path : str ) -> QtCore . QModelIndex : \"\"\"Get the model index for the given layer path. :param layer_path: Carbon layer path. :type layer_path: str :returns: The index corresponding to the given layer path else an invalid index if not found. :rtype: QtCore.QModelIndex \"\"\" norm_path = str ( os . path . normpath ( layer_path )) matching_index = None for r in range ( self . rowCount ()): index = self . index ( r , 0 ) if not index . isValid (): continue item = self . itemFromIndex ( index ) if item . layer_path == norm_path : matching_index = index break if matching_index is None : return QtCore . QModelIndex () return matching_index","title":"carbon_layer_index()"},{"location":"developer/api/gui/api_carbon_layer_model/#src.cplus_plugin.gui.carbon_item_model.CarbonLayerModel.carbon_paths","text":"carbon_paths ( valid_only = False ) Gets all the carbon paths in the model. Parameters: Name Type Description Default valid_only bool Only return the carbon paths that are valid. False Returns: Type Description list A collection of carbon paths in the model. Source code in src/cplus_plugin/gui/carbon_item_model.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 def carbon_paths ( self , valid_only : bool = False ) -> list : \"\"\"Gets all the carbon paths in the model. :param valid_only: Only return the carbon paths that are valid. :type valid_only: bool :returns: A collection of carbon paths in the model. :rtype: list \"\"\" carbon_paths = [] for r in range ( self . rowCount ()): index = self . index ( r , 0 ) item = self . itemFromIndex ( index ) if valid_only : if item . is_valid : carbon_paths . append ( item . layer_path ) else : carbon_paths . append ( item . layer_path ) return carbon_paths","title":"carbon_paths()"},{"location":"developer/api/gui/api_carbon_layer_model/#src.cplus_plugin.gui.carbon_item_model.CarbonLayerModel.contains_layer_path","text":"contains_layer_path ( layer_path ) Checks if the specified layer path exists in the model. Parameters: Name Type Description Default layer_path str Carbon layer path. required Returns: Type Description bool True if the path exists, else False. Source code in src/cplus_plugin/gui/carbon_item_model.py 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def contains_layer_path ( self , layer_path : str ) -> bool : \"\"\"Checks if the specified layer path exists in the model. :param layer_path: Carbon layer path. :type layer_path: str :returns: True if the path exists, else False. :rtype: bool \"\"\" carbon_idx = self . carbon_layer_index ( layer_path ) if carbon_idx . isValid (): return True return False","title":"contains_layer_path()"},{"location":"developer/api/gui/api_carbon_layer_model/#src.cplus_plugin.gui.carbon_item_model.CarbonLayerModel.update_carbon_path","text":"update_carbon_path ( index , layer_path ) Update the carbon path at the given position specified by the index. Parameters: Name Type Description Default index QModelIndex Location to modify the carbon path. required layer_path str Carbon layer path. required Returns: Type Description bool True if the path was successfully updated else False if there is no carbon item at the given location. Source code in src/cplus_plugin/gui/carbon_item_model.py 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 def update_carbon_path ( self , index : QtCore . QModelIndex , layer_path : str ) -> bool : \"\"\"Update the carbon path at the given position specified by the index. :param index: Location to modify the carbon path. :type index: QtCore.QModelIndex :param layer_path: Carbon layer path. :type layer_path: str :returns: True if the path was successfully updated else False if there is no carbon item at the given location. :rtype: bool \"\"\" if not index . isValid (): return False item = self . itemFromIndex ( index ) if item is None : return False item . update ( layer_path ) return True","title":"update_carbon_path()"},{"location":"developer/api/gui/api_component_items/","text":"Component item model Contains item models for view widgets such as NCS pathway or IM views. ComponentItemModel ComponentItemModel ( parent = None ) Bases: QStandardItemModel View model for ModelComponent objects. Source code in src/cplus_plugin/gui/component_item_model.py 575 576 577 578 579 def __init__ ( self , parent = None ): super () . __init__ ( parent ) self . setColumnCount ( 1 ) self . _uuid_row_idx = {} add_component_item add_component_item ( component_item , position =- 1 ) Adds a model component item to the view model. Parameters: Name Type Description Default component_item ModelComponentItem Model component item to be added to the view model. required position int Reference row to insert the item. -1 Returns: Type Description bool True if the component item was successfully added, else False if there is an existing component item with the same UUID. Source code in src/cplus_plugin/gui/component_item_model.py 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 def add_component_item ( self , component_item : ModelComponentItem , position =- 1 ) -> bool : \"\"\"Adds a model component item to the view model. :param component_item: Model component item to be added to the view model. :type component_item: ModelComponentItem :param position: Reference row to insert the item. :type position: int :returns: True if the component item was successfully added, else False if there is an existing component item with the same UUID. :rtype: bool \"\"\" idx = position if position == - 1 : idx = self . rowCount () if self . contains_item ( str ( component_item . uuid )): return False self . insertRow ( idx , component_item ) self . _re_index_rows () return True component_item_by_uuid component_item_by_uuid ( uuid_str ) Retrieves a ModelComponentItem based on a matching UUID. Parameters: Name Type Description Default uuid_str str UUID of the model item. required Returns: Type Description ModelComponentItem Component item matching the given UUID or None if not found. Source code in src/cplus_plugin/gui/component_item_model.py 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 def component_item_by_uuid ( self , uuid_str : str ) -> typing . Union [ ModelComponentItemType , None ]: \"\"\"Retrieves a ModelComponentItem based on a matching UUID. :param uuid_str: UUID of the model item. :type uuid_str: str :returns: Component item matching the given UUID or None if not found. :rtype: ModelComponentItem \"\"\" if uuid_str not in self . _uuid_row_idx : return None row = self . _uuid_row_idx [ uuid_str ] return self . item ( row ) contains_item contains_item ( item_uuid ) Checks if the model contains an item with the given UUID. Parameters: Name Type Description Default item_uuid str UUID of the model item. required Returns: Type Description bool True if there is an existing item else False. Source code in src/cplus_plugin/gui/component_item_model.py 610 611 612 613 614 615 616 617 618 619 def contains_item ( self , item_uuid : str ) -> bool : \"\"\"Checks if the model contains an item with the given UUID. :param item_uuid: UUID of the model item. :type item_uuid: str :returns: True if there is an existing item else False. :rtype: bool \"\"\" return True if self . component_item_by_uuid ( item_uuid ) is not None else False index_by_uuid index_by_uuid ( uuid_str ) Get the QModelIndex object for the component item matching the given UUID identifier. Parameters: Name Type Description Default uuid_str str UUID of the model item. required Returns: Type Description QtCore.QModelIndex QModelIndex for the component item matching the given UUID or an invalid QModelIndex if not found. Source code in src/cplus_plugin/gui/component_item_model.py 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 def index_by_uuid ( self , uuid_str ) -> QtCore . QModelIndex : \"\"\"Get the QModelIndex object for the component item matching the given UUID identifier. :param uuid_str: UUID of the model item. :type uuid_str: str :returns: QModelIndex for the component item matching the given UUID or an invalid QModelIndex if not found. :rtype: QtCore.QModelIndex \"\"\" if uuid_str not in self . _uuid_row_idx : return QtCore . QModelIndex () row = self . _uuid_row_idx [ uuid_str ] return self . index ( row , 0 ) model_component_items model_component_items () Returns all model component items in the model. Returns: Type Description list Model component items in the model. Source code in src/cplus_plugin/gui/component_item_model.py 684 685 686 687 688 689 690 691 692 def model_component_items ( self ) -> typing . List [ ModelComponentItem ]: \"\"\"Returns all model component items in the model. :returns: Model component items in the model. :rtype: list \"\"\" rows = self . rowCount () return [ self . item ( r ) for r in range ( rows )] model_components model_components () Returns a collection of all model component objects in the model. Returns: Type Description list A collection of all model component objects. Source code in src/cplus_plugin/gui/component_item_model.py 674 675 676 677 678 679 680 681 682 def model_components ( self ) -> typing . List [ BaseModelComponentType ]: \"\"\"Returns a collection of all model component objects in the model. :returns: A collection of all model component objects. :rtype: list \"\"\" rows = self . rowCount () return [ self . item ( r ) . model_component for r in range ( rows )] remove_component_item remove_component_item ( uuid_str ) Removes a ModelComponentItem based on a matching UUID. Parameters: Name Type Description Default uuid_str str UUID of the model item to be removed. required Returns: Type Description bool True if the component item was successfully removed, else False if there was not matching UUID. Source code in src/cplus_plugin/gui/component_item_model.py 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 def remove_component_item ( self , uuid_str : str ) -> bool : \"\"\"Removes a ModelComponentItem based on a matching UUID. :param uuid_str: UUID of the model item to be removed. :type uuid_str: str :returns: True if the component item was successfully removed, else False if there was not matching UUID. :rtype: bool \"\"\" if not self . contains_item ( uuid_str ): return False if uuid_str not in self . _uuid_row_idx : return False self . removeRows ( self . _uuid_row_idx [ uuid_str ], 1 ) del self . _uuid_row_idx [ uuid_str ] self . _re_index_rows () return True update_item update_item ( item ) Update an existing ModelComponentItem if it exists in the model. Parameters: Name Type Description Default item ModelComponentItemType An updated instance of the ModelComponentItem. required Returns: Type Description bool True if the item was successfully updated, else False if there was no matching item found in the model. Source code in src/cplus_plugin/gui/component_item_model.py 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 def update_item ( self , item : ModelComponentItemType ) -> bool : \"\"\"Update an existing ModelComponentItem if it exists in the model. :param item: An updated instance of the ModelComponentItem. :type item: ModelComponentItem :returns: True if the item was successfully updated, else False if there was no matching item found in the model. :rtype: bool \"\"\" if not self . contains_item ( item . uuid ): return False item . update ( item . model_component ) return True IMItemModel Bases: ComponentItemModel View model for implementation model. add_implementation_model add_implementation_model ( implementation_model , layer = None ) Add an ImplementationModel object to the model. Parameters: Name Type Description Default implementation_model ImplementationModel ImplementationModel object to be added to the view. required layer QgsMapLayer Map layer for the implementation model. None Returns: Type Description bool True if ImplementationModel object was added successfully, else False. Source code in src/cplus_plugin/gui/component_item_model.py 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 def add_implementation_model ( self , implementation_model : ImplementationModel , layer : QgsMapLayer = None ) -> bool : \"\"\"Add an ImplementationModel object to the model. :param implementation_model: ImplementationModel object to be added to the view. :type implementation_model: ImplementationModel :param layer: Map layer for the implementation model. :type layer: QgsMapLayer :returns: True if ImplementationModel object was added successfully, else False. :rtype: bool \"\"\" # Check if we can retrieve the layer from the path if layer is None : if implementation_model . path : layer = implementation_model . to_map_layer () implementation_model_item = ImplementationModelItem . create ( implementation_model ) result = self . add_component_item ( implementation_model_item ) if layer : status = self . set_model_layer ( implementation_model_item , layer ) if not status : result = False else : # Add NCS pathways. If there are underlying NCS pathway objects then # clone them, remove then re-insert so that the underlying NCS pathways can # have the unique UUID in the IM item. if result : cloned_implementation_model = clone_implementation_model ( implementation_model ) cloned_ncs_pathways = cloned_implementation_model . pathways # Remove pathways in the IM implementation_model . pathways = [] # Now add the NCSs afresh for ncs in cloned_ncs_pathways : ncs_item = NcsPathwayItem . create ( ncs ) self . add_ncs_pathway ( ncs_item , implementation_model_item ) return result add_ncs_pathway add_ncs_pathway ( ncs_item , target_model_item ) Adds an NCS pathway item to the model. Parameters: Name Type Description Default ncs_item NcsPathwayItem NCS pathway item to the collection. required target_model_item ImplementationModelItem Target implementation model for the NCS item. required Returns: Type Description bool True if the NCS pathway item was successfully added, else False if there underlying NCS pathway object was invalid, there is an existing item with the same UUID or if there is already a map layer defined for the implementation model. Source code in src/cplus_plugin/gui/component_item_model.py 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 def add_ncs_pathway ( self , ncs_item : NcsPathwayItem , target_model_item : ImplementationModelItem ) -> bool : \"\"\"Adds an NCS pathway item to the model. :param ncs_item: NCS pathway item to the collection. :type ncs_item: NcsPathwayItem :param target_model_item: Target implementation model for the NCS item. :type target_model_item: ImplementationModelItem :returns: True if the NCS pathway item was successfully added, else False if there underlying NCS pathway object was invalid, there is an existing item with the same UUID or if there is already a map layer defined for the implementation model. \"\"\" idx = target_model_item . index () if not idx . isValid (): return False if not isinstance ( target_model_item , LayerComponentItem ): return False # If there is an existing layer then return if target_model_item . layer : return False clone_ncs_item = ncs_item . clone () status = target_model_item . add_ncs_pathway_item ( clone_ncs_item ) if not status : return False bottom_idx = target_model_item . bottom_ncs_item_index () reference_row = max ( bottom_idx . row (), idx . row ()) self . add_component_item ( clone_ncs_item , reference_row + 1 ) self . im_pathways_updated . emit ( target_model_item ) return True dropMimeData dropMimeData ( data , action , row , column , parent ) Implements behaviour for handling data supplied by drag and drop operation. Parameters: Name Type Description Default data QMimeData Object containing data from the drag operation. required action DropAction Type of the drag and drop operation. required row int Row location of dropped data. required column int Column location of dropped data. required parent QModelIndex Index location for target item where the operation ended. required Returns: Type Description bool True if the data and action can be handled by the model, else False. Source code in src/cplus_plugin/gui/component_item_model.py 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 def dropMimeData ( self , data : QtCore . QMimeData , action : QtCore . Qt . DropAction , row : int , column : int , parent : QtCore . QModelIndex , ) -> bool : \"\"\"Implements behaviour for handling data supplied by drag and drop operation. :param data: Object containing data from the drag operation. :type data: QtCore.QMimeData :param action: Type of the drag and drop operation. :type action: QtCore.Qt.DropAction :param row: Row location of dropped data. :type row: int :param column: Column location of dropped data. :type column: int :param parent: Index location for target item where the operation ended. :type parent: QtCore.QModelIndex :returns: True if the data and action can be handled by the model, else False. :rtype: bool \"\"\" if action == QtCore . Qt . IgnoreAction : return True if not data . hasFormat ( NCS_MIME_TYPE ): return False encoded_data = data . data ( NCS_MIME_TYPE ) data_stream = QtCore . QDataStream ( encoded_data , QtCore . QIODevice . ReadOnly ) ncs_items = [] while not data_stream . atEnd (): byte_data = QtCore . QByteArray () data_stream >> byte_data item_data = json . loads ( byte_data . data ()) ncs_pathway = create_ncs_pathway ( item_data ) ncs_item = NcsPathwayItem ( ncs_pathway ) ncs_items . append ( ncs_item ) # Get reference ImplementationModel item if parent . isValid (): model_item = self . itemFromIndex ( parent ) else : row_count = self . rowCount () model_item = self . item ( row_count - 1 ) if model_item is None or isinstance ( model_item , LayerItem ): return False if model_item . type () == NCS_PATHWAY_TYPE : target_im_item = model_item . parent else : target_im_item = model_item # Add NCS items to model. status = True for item in ncs_items : status = self . add_ncs_pathway ( item , target_im_item ) return status model_items model_items () Returns all ImplementationModelItem objects in the model. Returns: Type Description list All implementation model items in the model. Source code in src/cplus_plugin/gui/component_item_model.py 1109 1110 1111 1112 1113 1114 1115 1116 1117 def model_items ( self ) -> typing . List [ ImplementationModelItem ]: \"\"\"Returns all ImplementationModelItem objects in the model. :returns: All implementation model items in the model. :rtype: list \"\"\" component_items = self . model_component_items () return [ ci for ci in component_items if ci . type () == IMPLEMENTATION_MODEL_TYPE ] models models () Returns implementation model objects in the model. Returns: Type Description list All implementation model objects in the model. Source code in src/cplus_plugin/gui/component_item_model.py 1101 1102 1103 1104 1105 1106 1107 def models ( self ) -> typing . List [ ImplementationModel ]: \"\"\"Returns implementation model objects in the model. :returns: All implementation model objects in the model. :rtype: list \"\"\" return [ model_item . implementation_model for model_item in self . model_items ()] remove_implementation_model remove_implementation_model ( uuid_str ) Remove an implementation model item from the model. param uuid: UUID of the implementation model item to be removed. Returns: Type Description bool True if the implementation model item as successfully removed, else False if there was not matching UUID. Source code in src/cplus_plugin/gui/component_item_model.py 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 def remove_implementation_model ( self , uuid_str : str ) -> bool : \"\"\"Remove an implementation model item from the model. param uuid: UUID of the implementation model item to be removed. :type uuid_str: str :returns: True if the implementation model item as successfully removed, else False if there was not matching UUID. :rtype: bool \"\"\" implementation_model_item = self . component_item_by_uuid ( uuid_str ) if implementation_model_item is None : return False if len ( implementation_model_item . ncs_items ) > 0 : ncs_items = implementation_model_item . ncs_items for item in ncs_items : self . remove_component_item ( item . uuid ) else : # Layer item self . remove_layer ( implementation_model_item ) return self . remove_component_item ( uuid_str ) remove_layer remove_layer ( implementation_model_item ) Removes the layer reference from the underlying implementation model. Parameters: Name Type Description Default implementation_model_item ImplementationModelItem Implementation model item whose layer is to be removed. required Source code in src/cplus_plugin/gui/component_item_model.py 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 def remove_layer ( self , implementation_model_item : ImplementationModelItem ): \"\"\"Removes the layer reference from the underlying implementation model. :param implementation_model_item: Implementation model item whose layer is to be removed. :type implementation_model_item: ImplementationModelItem \"\"\" if implementation_model_item . layer is None : return if not self . contains_item ( implementation_model_item . uuid ): return # Remove item in model item_idx = self . index_by_uuid ( implementation_model_item . uuid ) layer_row = item_idx . row () + 1 self . removeRows ( layer_row , 1 ) # Remove underlying layer reference implementation_model_item . clear_layer () remove_ncs_pathway_item remove_ncs_pathway_item ( ncs_uuid , parent ) Remove an NCS pathway item from the model. param uuid: UUID of the NCS pathway item to be removed. Parameters: Name Type Description Default parent ImplementationModelItem Reference implementation model item that is the parent to the NCS pathway item. required Returns: Type Description bool True if the NCS pathway item has been successfully removed, else False if there was no matching UUID. Source code in src/cplus_plugin/gui/component_item_model.py 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 def remove_ncs_pathway_item ( self , ncs_uuid : str , parent : ImplementationModelItem ) -> bool : \"\"\"Remove an NCS pathway item from the model. param uuid: UUID of the NCS pathway item to be removed. :type ncs_uuid: str :param parent: Reference implementation model item that is the parent to the NCS pathway item. :type parent: ImplementationModelItem :returns: True if the NCS pathway item has been successfully removed, else False if there was no matching UUID. :rtype: bool \"\"\" status = parent . remove_ncs_pathway_item ( ncs_uuid ) if not status : return False self . im_pathways_updated . emit ( parent ) return self . remove_component_item ( ncs_uuid ) set_model_layer set_model_layer ( implementation_model_item , layer , display_name = '' ) Set the layer for the given implementation model item. Parameters: Name Type Description Default implementation_model_item ImplementationModelItem Implementation model item whose layer is to be specified. required layer QgsMapLayer Map layer to be set for the implementation model. required display_name str Display name for the layer node. If not specified then the name from the map layer is used. '' Returns: Type Description bool True if the layer was successfully set for the implementation model, else False if the layer is invalid, if there are already existing NCS pathways in the implementation model or if the item is not in the model. Source code in src/cplus_plugin/gui/component_item_model.py 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 def set_model_layer ( self , implementation_model_item : ImplementationModelItem , layer : QgsMapLayer , display_name : str = \"\" , ) -> bool : \"\"\"Set the layer for the given implementation model item. :param implementation_model_item: Implementation model item whose layer is to be specified. :type implementation_model_item: ImplementationModelItem :param layer: Map layer to be set for the implementation model. :type layer: QgsMapLayer :param display_name: Display name for the layer node. If not specified then the name from the map layer is used. :type display_name: str :returns: True if the layer was successfully set for the implementation model, else False if the layer is invalid, if there are already existing NCS pathways in the implementation model or if the item is not in the model. :rtype: bool \"\"\" if len ( implementation_model_item . ncs_items ) > 0 : return False if not self . contains_item ( implementation_model_item . uuid ): return False if not implementation_model_item . set_layer ( layer ): return False if not display_name : display_name = layer . name () icon = FileUtils . get_icon ( \"mIconRaster.svg\" ) item = LayerItem ( icon , display_name ) item . setToolTip ( display_name ) item . setData ( implementation_model_item ) item_idx = self . index_by_uuid ( implementation_model_item . uuid ) layer_row = item_idx . row () + 1 self . insertRow ( layer_row , item ) return True update_implementation_model update_implementation_model ( implementation_model , layer = None ) Updates the implementation model item in the model. Parameters: Name Type Description Default implementation_model ImplementationModel implementation_model object whose corresponding item is to be updated. required layer QgsMapLayer Map layer to be updated for the implementation if specified. None Returns: Type Description bool Returns True if the operation was successful else False if the matching item was not found in the model. Source code in src/cplus_plugin/gui/component_item_model.py 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 def update_implementation_model ( self , implementation_model : ImplementationModel , layer : QgsMapLayer = None ) -> bool : \"\"\"Updates the implementation model item in the model. :param implementation_model: implementation_model object whose corresponding item is to be updated. :type implementation_model: ImplementationModel :param layer: Map layer to be updated for the implementation if specified. :type layer: QgsMapLayer :returns: Returns True if the operation was successful else False if the matching item was not found in the model. \"\"\" item = self . component_item_by_uuid ( str ( implementation_model . uuid )) if item is None : return False status = self . update_item ( item ) if not status : return False # Update layer information self . remove_layer ( item ) if layer : layer_status = self . set_model_layer ( item , layer ) if not layer_status : return False return True update_ncs_pathway_items update_ncs_pathway_items ( ncs_pathway ) Update NCS pathway items matching the given NCS pathway model. If the NCS pathway model is not valid then the NCS pathway items in the implementation model item will not be updated. Returns: Type Description bool True if matching NCS pathway items have been updated, else False. Source code in src/cplus_plugin/gui/component_item_model.py 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 def update_ncs_pathway_items ( self , ncs_pathway : NcsPathway ) -> bool : \"\"\"Update NCS pathway items matching the given NCS pathway model. If the NCS pathway model is not valid then the NCS pathway items in the implementation model item will not be updated. :returns: True if matching NCS pathway items have been updated, else False. :rtype: bool \"\"\" if not ncs_pathway . is_valid (): return False for im_item in self . model_items (): ncs_item_for_original = im_item . ncs_item_from_original_pathway ( ncs_pathway ) if ncs_item_for_original is None : continue item_pathway = ncs_item_for_original . ncs_pathway # Copy attribute values excluding the UUID copy_layer_component_attributes ( item_pathway , ncs_pathway ) ncs_item_for_original . update ( item_pathway ) return True ImplementationModelItem ImplementationModelItem ( implementation_model ) Bases: LayerComponentItem Standard item for an implementation model object. Source code in src/cplus_plugin/gui/component_item_model.py 292 293 294 295 296 297 298 299 300 301 302 303 304 def __init__ ( self , implementation_model : ImplementationModel ): super () . __init__ ( implementation_model ) self . _implementation_model = implementation_model font = self . font () font . setBold ( True ) self . setFont ( font ) self . _ncs_items = [] # Remap pathway uuids so that there are no duplicate # pathways under each implementation model. self . _uuid_remap = {} implementation_model property implementation_model Returns an instance of the underlying ImplementationModel object. Returns: Type Description ImplementationModel The underlying ImplementationModel object. layer_item property layer_item Returns the view item for the layer. Returns: Type Description QtGui.QStandardItem Returns the view item for the map layer else False if no layer has been specified for the model. ncs_items property ncs_items Returns a collection of NcsPathwayItem in this implementation model. Returns: Type Description list Collection of NcsPathwayItem objects in this implementation model. ncs_pathways property ncs_pathways Returns a collection of NcsPathway objects. Returns: Type Description list Collection of NcsPathway objects linked to the underlying ImplementationModel object. original_ncs_pathways property original_ncs_pathways Returns a collection of NcsPathway objects but with their original UUIDs. These are used for persisting the NCsPathway objects related to the underlying IM object. Returns: Type Description list Collection of NcsPathway objects with their original UUIDs linked to the underlying ImplementationModel object. add_ncs_pathway_item add_ncs_pathway_item ( ncs_item ) Adds an NCS pathway item to this implementation model item. If the item already contains a layer, then the add operation will not be successful. Parameters: Name Type Description Default ncs_item NcsPathwayItem NCS pathway item to the collection. required Returns: Type Description bool True if the NCS pathway item was successfully added, else False if there underlying NCS pathway object was invalid, there is an existing item with the same UUID or if the layer property had already been set. Source code in src/cplus_plugin/gui/component_item_model.py 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 def add_ncs_pathway_item ( self , ncs_item : NcsPathwayItem ) -> bool : \"\"\"Adds an NCS pathway item to this implementation model item. If the item already contains a layer, then the add operation will not be successful. :param ncs_item: NCS pathway item to the collection. :type ncs_item: NcsPathwayItem :returns: True if the NCS pathway item was successfully added, else False if there underlying NCS pathway object was invalid, there is an existing item with the same UUID or if the layer property had already been set. \"\"\" if self . layer : return False old_uuid = ncs_item . uuid new_uuid = uuid4 () ncs_item . ncs_pathway . uuid = new_uuid if old_uuid in self . _uuid_remap : return False if self . contains_ncs_item ( ncs_item . uuid ): return False if not ncs_item . is_valid (): return False if self . _implementation_model . contains_pathway ( ncs_item . uuid ): return False if not self . _implementation_model . add_ncs_pathway ( ncs_item . ncs_pathway ): return False self . _ncs_items . append ( ncs_item ) ncs_item . _parent = self self . _uuid_remap [ old_uuid ] = str ( new_uuid ) return True bottom_ncs_item_index bottom_ncs_item_index () Returns the model index of the bottom-most NcsPathwayItem under this implementation model item. Returns: Type Description QModelIndex Model index of the bottom-most NcsPathwayItem. Source code in src/cplus_plugin/gui/component_item_model.py 510 511 512 513 514 515 516 517 518 519 520 521 522 def bottom_ncs_item_index ( self ) -> typing . Union [ QtCore . QModelIndex , None ]: \"\"\"Returns the model index of the bottom-most NcsPathwayItem under this implementation model item. :returns: Model index of the bottom-most NcsPathwayItem. :rtype: QModelIndex \"\"\" if len ( self . _ncs_items ) == 0 : return None bottom_ncs_item = max ( self . _ncs_items , key = lambda n : n . index () . row ()) return bottom_ncs_item . index () clear_layer clear_layer () Clears the layer reference in the model component. Source code in src/cplus_plugin/gui/component_item_model.py 400 401 402 def clear_layer ( self ): \"\"\"Clears the layer reference in the model component.\"\"\" self . _implementation_model . clear_layer () clone clone () Creates a cloned version of this item. The cloned IM will contain pathways with the original UUID. The UUID of the IM will not change. Source code in src/cplus_plugin/gui/component_item_model.py 543 544 545 546 547 548 549 550 551 552 553 554 555 def clone ( self ) -> \"ImplementationModelItem\" : \"\"\"Creates a cloned version of this item. The cloned IM will contain pathways with the original UUID. The UUID of the IM will not change. \"\"\" implementation_model = clone_implementation_model ( self . implementation_model , ) # Use NCS pathways with original UUIDs implementation_model . pathways = self . original_ncs_pathways return ImplementationModelItem ( implementation_model ) contains_ncs_item contains_ncs_item ( item_uuid ) Checks whether this item contains an NcsPathway item with the given UUID. Parameters: Name Type Description Default item_uuid str UUID of the NcsPathway item to search for. required Returns: Type Description bool True if there is an NcsPathwayItem matching the given UUID, else False. Source code in src/cplus_plugin/gui/component_item_model.py 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 def contains_ncs_item ( self , item_uuid : str ) -> bool : \"\"\"Checks whether this item contains an NcsPathway item with the given UUID. :param item_uuid: UUID of the NcsPathway item to search for. :type item_uuid: str :returns: True if there is an NcsPathwayItem matching the given UUID, else False. :rtype: bool \"\"\" if self . ncs_item_by_uuid ( item_uuid ) is None : return False return True create staticmethod create ( implementation_model ) Creates an instance of the ImplementationModelItem from the model object. Returns: Type Description ImplementationModel An instance of the ImplementationModelItem item to be used in a standard model. Source code in src/cplus_plugin/gui/component_item_model.py 532 533 534 535 536 537 538 539 540 541 @staticmethod def create ( implementation_model : ImplementationModel ) -> \"ImplementationModelItem\" : \"\"\"Creates an instance of the ImplementationModelItem from the model object. :returns: An instance of the ImplementationModelItem item to be used in a standard model. :rtype: ImplementationModel \"\"\" return ImplementationModelItem ( implementation_model ) ncs_item_by_uuid ncs_item_by_uuid ( ncs_uuid ) Returns an NcsPathway item matching the given UUID. Parameters: Name Type Description Default ncs_uuid str UUID of the NcsPathway item to retrieve. required Returns: Type Description NcsPathwayItem NcsPathwayItem matching the given UUID, else None if not found. Source code in src/cplus_plugin/gui/component_item_model.py 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 def ncs_item_by_uuid ( self , ncs_uuid : str ) -> typing . Union [ NcsPathwayItem , None ]: \"\"\"Returns an NcsPathway item matching the given UUID. :param ncs_uuid: UUID of the NcsPathway item to retrieve. :type ncs_uuid: str :returns: NcsPathwayItem matching the given UUID, else None if not found. :rtype: NcsPathwayItem \"\"\" ncs_items = [ n for n in self . _ncs_items if n . uuid == ncs_uuid ] if len ( ncs_items ) == 0 : return None return ncs_items [ 0 ] ncs_item_from_original_pathway ncs_item_from_original_pathway ( ncs_pathway ) Retrieves the NCS item corresponding to the original NCS pathway i.e. before it is added to this implementation model item. Parameters: Name Type Description Default ncs_pathway NcsPathway Original NCS pathway data model. required Returns: Type Description Union [ NcsPathwayItem , None] The matching NCS pathway item in this implementation model item, else None if there is no matching item. Source code in src/cplus_plugin/gui/component_item_model.py 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 def ncs_item_from_original_pathway ( self , ncs_pathway : NcsPathway ) -> typing . Union [ NcsPathwayItem , None ]: \"\"\"Retrieves the NCS item corresponding to the original NCS pathway i.e. before it is added to this implementation model item. :param ncs_pathway: Original NCS pathway data model. :type ncs_pathway: NcsPathway :returns: The matching NCS pathway item in this implementation model item, else None if there is no matching item. \"\"\" ncs_uuid = str ( ncs_pathway . uuid ) if ncs_uuid not in self . _uuid_remap : return None new_uuid = self . _uuid_remap [ ncs_uuid ] return self . ncs_item_by_uuid ( new_uuid ) remove_ncs_pathway_item remove_ncs_pathway_item ( item_uuid ) Removes the NcsPathwayItem matching the given UUID. Parameters: Name Type Description Default item_uuid str The UUID of the NcsPathwayItem to remove. required Returns: Type Description bool True if the item was successfully removed, else False. Source code in src/cplus_plugin/gui/component_item_model.py 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 def remove_ncs_pathway_item ( self , item_uuid : str ) -> bool : \"\"\"Removes the NcsPathwayItem matching the given UUID. :param item_uuid: The UUID of the NcsPathwayItem to remove. :type item_uuid: str :returns: True if the item was successfully removed, else False. :rtype: bool \"\"\" if not self . contains_ncs_item ( item_uuid ): return False idxs = [ i for i , n in enumerate ( self . _ncs_items ) if n . uuid == item_uuid ] if len ( idxs ) == 0 : return False item = self . _ncs_items . pop ( idxs [ 0 ]) item . _parent = None del item self . _implementation_model . remove_ncs_pathway ( item_uuid ) old_uuids = [ k for k , v in self . _uuid_remap . items () if v == item_uuid ] if len ( old_uuids ) > 0 : del self . _uuid_remap [ old_uuids [ 0 ]] return True type type () Returns the type of the standard item. Returns: Type Description int Type identifier of the standard item. Source code in src/cplus_plugin/gui/component_item_model.py 524 525 526 527 528 529 530 def type ( self ) -> int : \"\"\"Returns the type of the standard item. :returns: Type identifier of the standard item. :rtype: int \"\"\" return IMPLEMENTATION_MODEL_TYPE LayerComponentItem LayerComponentItem ( model_component ) Bases: ModelComponentItem Base class view item for layer-based component items. Source code in src/cplus_plugin/gui/component_item_model.py 130 131 132 133 def __init__ ( self , model_component : LayerModelComponent ): if not isinstance ( model_component , LayerModelComponent ): raise TypeError ( \"'model_component' not of type LayerModelComponent\" ) super () . __init__ ( model_component ) layer property layer Returns the map layer from the underlying model component object. Returns: Type Description QgsMapLayer Map layer corresponding from the underlying model component. clone abstractmethod clone () Creates a deep copied version of the model item. Returns: Type Description ModelComponentItem Cloned version of the model item containing all the properties as the source. Source code in src/cplus_plugin/gui/component_item_model.py 204 205 206 207 208 209 210 211 212 @abstractmethod def clone ( self ) -> \"ModelComponentItemType\" : \"\"\"Creates a deep copied version of the model item. :returns: Cloned version of the model item containing all the properties as the source. :rtype: ModelComponentItem \"\"\" pass create abstractmethod staticmethod create ( model_component ) Factory method for creating an instance of a model item. This is an abstract method that needs to be implemented by subclasses. Parameters: Name Type Description Default model_component BaseModelComponent Source model component for creating the corresponding item. required Returns: Type Description ModelComponentItem Model component item for use in a standard item model. Source code in src/cplus_plugin/gui/component_item_model.py 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 @staticmethod @abstractmethod def create ( model_component : BaseModelComponent ) -> \"ModelComponentItem\" : \"\"\"Factory method for creating an instance of a model item. This is an abstract method that needs to be implemented by subclasses. :param model_component: Source model component for creating the corresponding item. :type model_component: BaseModelComponent :returns: Model component item for use in a standard item model. :rtype: ModelComponentItem \"\"\" pass is_valid is_valid () Checks whether the map layer of the underlying model component object is valid. Returns: Type Description bool True if the map layer is valid, else False if map layer is invalid or of None type. Source code in src/cplus_plugin/gui/component_item_model.py 135 136 137 138 139 140 141 142 143 144 145 146 def is_valid ( self ) -> bool : \"\"\"Checks whether the map layer of the underlying model component object is valid. :returns: True if the map layer is valid, else False if map layer is invalid or of None type. :rtype: bool \"\"\" if self . _model_component is None : return False return self . _model_component . is_valid () set_layer set_layer ( layer ) Set the map layer for the component item. It sets the :py:attr: ~path attribute of the underlying data model. Parameters: Name Type Description Default layer QgsMapLayer Map layer for the component item. required Returns: Type Description bool Returns True if the layer was successfully set, else False if the layer is invalid. Source code in src/cplus_plugin/gui/component_item_model.py 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 def set_layer ( self , layer : QgsMapLayer ) -> bool : \"\"\"Set the map layer for the component item. It sets the :py:attr:`~path` attribute of the underlying data model. :param layer: Map layer for the component item. :type layer: QgsMapLayer :returns: Returns True if the layer was successfully set, else False if the layer is invalid. :rtype: bool \"\"\" if not layer : return False if not layer . isValid (): return False path = layer . source () self . _model_component . path = path if isinstance ( layer , QgsRasterLayer ): self . _model_component . layer_type = LayerType . RASTER elif isinstance ( layer , QgsVectorLayer ): self . _model_component . layer_type = LayerType . VECTOR return True LayerItem Bases: QStandardItem Contains a custom identifier for an item used to define a layer for an implementation model. type type () Returns the type of the standard item. Returns: Type Description int Type identifier of the standard item. Source code in src/cplus_plugin/gui/component_item_model.py 563 564 565 566 567 568 569 def type ( self ) -> int : \"\"\"Returns the type of the standard item. :returns: Type identifier of the standard item. :rtype: int \"\"\" return LAYER_ITEM_TYPE ModelComponentItem ModelComponentItem ( model_component ) Bases: QStandardItem Base standard item for a BaseModelComponent object. Source code in src/cplus_plugin/gui/component_item_model.py 44 45 46 47 48 49 50 def __init__ ( self , model_component : BaseModelComponent ): super () . __init__ ( model_component . name ) self . setToolTip ( model_component . name ) self . _model_component = model_component if self . _model_component is not None : self . update ( self . _model_component ) description property description Returns the description of the item. Returns: Type Description str Description of the item. model_component property model_component Returns an instance of the underlying model component object. Returns: Type Description BaseModelComponent Instance of underlying model component object. uuid property uuid Returns the UUID of the item. Returns: Type Description str UUID string of the item. clone abstractmethod clone () Creates a deep copied version of the model item. Returns: Type Description ModelComponentItem Cloned version of the model item containing all the properties as the source. Source code in src/cplus_plugin/gui/component_item_model.py 111 112 113 114 115 116 117 118 119 @abstractmethod def clone ( self ) -> \"ModelComponentItemType\" : \"\"\"Creates a deep copied version of the model item. :returns: Cloned version of the model item containing all the properties as the source. :rtype: ModelComponentItem \"\"\" pass create abstractmethod staticmethod create ( model_component ) Factory method for creating an instance of a model item. This is an abstract method that needs to be implemented by subclasses. Parameters: Name Type Description Default model_component BaseModelComponent Source model component for creating the corresponding item. required Returns: Type Description ModelComponentItem Model component item for use in a standard item model. Source code in src/cplus_plugin/gui/component_item_model.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 @staticmethod @abstractmethod def create ( model_component : BaseModelComponent ) -> \"ModelComponentItem\" : \"\"\"Factory method for creating an instance of a model item. This is an abstract method that needs to be implemented by subclasses. :param model_component: Source model component for creating the corresponding item. :type model_component: BaseModelComponent :returns: Model component item for use in a standard item model. :rtype: ModelComponentItem \"\"\" pass update update ( model_component ) Update the component-related properties of the item. Source code in src/cplus_plugin/gui/component_item_model.py 52 53 54 55 56 57 58 59 def update ( self , model_component : BaseModelComponent ): \"\"\"Update the component-related properties of the item.\"\"\" if model_component is None : return self . _model_component = model_component self . setText ( model_component . name ) self . setToolTip ( model_component . name ) NcsPathwayItem NcsPathwayItem ( ncs ) Bases: LayerComponentItem Standard item for an NCS pathway object. Source code in src/cplus_plugin/gui/component_item_model.py 218 219 220 221 def __init__ ( self , ncs : NcsPathway ): super () . __init__ ( ncs ) self . _ncs_pathway = ncs self . _parent = None ncs_pathway property ncs_pathway Returns an instance of the underlying NcsPathway object. Returns: Type Description NcsPathway The underlying NcsPathway model object. parent property parent Returns the parent ImplementationModelItem if specified. Returns: Type Description ImplementationModelItem Returns the parent item if set when this item is mapped to an ImplementationModelItem. clone clone () Creates a cloned version of this item. Source code in src/cplus_plugin/gui/component_item_model.py 260 261 262 263 264 def clone ( self ) -> \"NcsPathwayItem\" : \"\"\"Creates a cloned version of this item.\"\"\" ncs = clone_ncs_pathway ( self . ncs_pathway ) return NcsPathwayItem ( ncs ) create staticmethod create ( ncs ) Creates an instance of the NcsPathwayItem from the model object. Returns: Type Description NcsPathwayItem An instance of the NcsPathway item to be used in a standard model. Source code in src/cplus_plugin/gui/component_item_model.py 250 251 252 253 254 255 256 257 258 @staticmethod def create ( ncs : NcsPathway ) -> \"NcsPathwayItem\" : \"\"\"Creates an instance of the NcsPathwayItem from the model object. :returns: An instance of the NcsPathway item to be used in a standard model. :rtype: NcsPathwayItem \"\"\" return NcsPathwayItem ( ncs ) is_carbon_valid is_carbon_valid () Returns the validity of the carbon layers in the underlying NCSPathway model object. Returns: Type Description bool True if the carbon layers are valid, else False. Source code in src/cplus_plugin/gui/component_item_model.py 278 279 280 281 282 283 284 285 286 def is_carbon_valid ( self ) -> bool : \"\"\"Returns the validity of the carbon layers in the underlying NCSPathway model object. :returns: True if the carbon layers are valid, else False. :rtype: bool \"\"\" return self . ncs_pathway . is_carbon_valid () json_data json_data () Creates a mapping of NCS pathway property names and their corresponding values. Returns: Type Description str JSON representation of property name-value pairs for an NCS pathway object. Source code in src/cplus_plugin/gui/component_item_model.py 266 267 268 269 270 271 272 273 274 275 276 def json_data ( self ) -> str : \"\"\"Creates a mapping of NCS pathway property names and their corresponding values. :returns: JSON representation of property name-value pairs for an NCS pathway object. :rtype: str \"\"\" ncs_attrs = ncs_pathway_to_dict ( self . _ncs_pathway ) return json . dumps ( ncs_attrs ) type type () Returns the type of the standard item. Returns: Type Description int Type identifier of the standard item. Source code in src/cplus_plugin/gui/component_item_model.py 242 243 244 245 246 247 248 def type ( self ) -> int : \"\"\"Returns the type of the standard item. :returns: Type identifier of the standard item. :rtype: int \"\"\" return NCS_PATHWAY_TYPE NcsPathwayItemModel Bases: ComponentItemModel View model for NCS pathways. add_ncs_pathway add_ncs_pathway ( ncs ) Add an NCS pathway object to the model. Parameters: Name Type Description Default ncs NcsPathway NCS pathway object to the added to the view. required Returns: Type Description bool True if the NCS pathway object was added successfully, else False if the NcsPathway object is invalid. Source code in src/cplus_plugin/gui/component_item_model.py 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 def add_ncs_pathway ( self , ncs : NcsPathway ) -> bool : \"\"\"Add an NCS pathway object to the model. :param ncs: NCS pathway object to the added to the view. :type ncs: NcsPathway :returns: True if the NCS pathway object was added successfully, else False if the NcsPathway object is invalid. :rtype: bool \"\"\" ncs_item = NcsPathwayItem . create ( ncs ) self . _update_display ( ncs_item ) status = self . add_component_item ( ncs_item ) self . sort ( 0 ) self . _re_index_rows () return status mimeData mimeData ( indexes ) Serializes the NCS items corresponding to the specified indexes. Parameters: Name Type Description Default indexes List [ QModelIndex ] NCS items stored in the specified indexes. required Returns: Type Description QtCore.QMimeData Mime object containing serialized NCS items. Source code in src/cplus_plugin/gui/component_item_model.py 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 def mimeData ( self , indexes : typing . List [ QtCore . QModelIndex ]) -> QtCore . QMimeData : \"\"\"Serializes the NCS items corresponding to the specified indexes. :param indexes: NCS items stored in the specified indexes. :type indexes: list :returns: Mime object containing serialized NCS items. :rtype: QtCore.QMimeData \"\"\" mime_data = QtCore . QMimeData () item_data = QtCore . QByteArray () data_stream = QtCore . QDataStream ( item_data , QtCore . QIODevice . WriteOnly ) for idx in indexes : if not idx . isValid (): continue ncs_item = self . itemFromIndex ( idx ) if ncs_item is None : continue ncs_data = QtCore . QByteArray () ncs_data . append ( ncs_item . json_data ()) data_stream << ncs_data mime_data . setData ( NCS_MIME_TYPE , item_data ) return mime_data mimeTypes mimeTypes () Returns supported MIME types that can be used to describe a list of model indexes for NCS pathway items. Returns: Type Description list MIME type for NCS pathway items which is JSON string but MIME type is the default datalist type for Qt since it does not allow custom types. Source code in src/cplus_plugin/gui/component_item_model.py 839 840 841 842 843 844 845 846 847 848 def mimeTypes ( self ) -> typing . List [ str ]: \"\"\"Returns supported MIME types that can be used to describe a list of model indexes for NCS pathway items. :returns: MIME type for NCS pathway items which is JSON string but MIME type is the default datalist type for Qt since it does not allow custom types. :rtype: list \"\"\" return [ NCS_MIME_TYPE ] pathways pathways ( valid_only = False ) Returns NCS pathway objects in the model. Parameters: Name Type Description Default valid_only bool Whether to only return NCS pathway objects that are valid. False Returns: Type Description list All NCS pathway objects in the model (default), else only those NCS pathway objects that are valid if valid_only is True. Source code in src/cplus_plugin/gui/component_item_model.py 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 def pathways ( self , valid_only : bool = False ) -> typing . List [ NcsPathway ]: \"\"\"Returns NCS pathway objects in the model. :param valid_only: Whether to only return NCS pathway objects that are valid. :type valid_only: bool :returns: All NCS pathway objects in the model (default), else only those NCS pathway objects that are valid if valid_only is True. :rtype: list \"\"\" ncs_pathways = self . model_components () if valid_only : return [ p for p in ncs_pathways if p . is_valid ()] return ncs_pathways remove_ncs_pathway remove_ncs_pathway ( ncs_uuid ) Remove an NCS pathway item from the model. param uuid: UUID of the NCS pathway item to be removed. Returns: Type Description bool True if the NCS pathway item as successfully removed, else False if there was not matching UUID. Source code in src/cplus_plugin/gui/component_item_model.py 817 818 819 820 821 822 823 824 825 826 827 def remove_ncs_pathway ( self , ncs_uuid : str ) -> bool : \"\"\"Remove an NCS pathway item from the model. param uuid: UUID of the NCS pathway item to be removed. :type ncs_uuid: str :returns: True if the NCS pathway item as successfully removed, else False if there was not matching UUID. :rtype: bool \"\"\" return self . remove_component_item ( ncs_uuid ) supportedDropActions supportedDropActions () Configure the model to only support copying items in a drag-and-drop operation. Returns: Type Description QtCore.Qt.DropActions Supported drag-and-drop action for NCS pathway items. Source code in src/cplus_plugin/gui/component_item_model.py 829 830 831 832 833 834 835 836 837 def supportedDropActions ( self ) -> QtCore . Qt . DropActions : \"\"\"Configure the model to only support copying items in a drag-and-drop operation. :returns: Supported drag-and-drop action for NCS pathway items. :rtype: QtCore.Qt.DropActions \"\"\" return QtCore . Qt . CopyAction update_ncs_pathway update_ncs_pathway ( ncs ) Updates the NCS pathway item in the model. Parameters: Name Type Description Default ncs NcsPathway NcsPathway whose corresponding item is to be updated. required Returns: Type Description bool Returns True if the operation was successful else False if the matching item was not found in the model. Source code in src/cplus_plugin/gui/component_item_model.py 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 def update_ncs_pathway ( self , ncs : NcsPathway ) -> bool : \"\"\"Updates the NCS pathway item in the model. :param ncs: NcsPathway whose corresponding item is to be updated. :type ncs: NcsPathway :returns: Returns True if the operation was successful else False if the matching item was not found in the model. \"\"\" item = self . component_item_by_uuid ( str ( ncs . uuid )) if item is None : return False status = self . update_item ( item ) if not status : return False self . _update_display ( item ) self . sort ( 0 ) self . _re_index_rows () return True","title":"Component item model"},{"location":"developer/api/gui/api_component_items/#component-item-model","text":"Contains item models for view widgets such as NCS pathway or IM views.","title":"Component item model"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ComponentItemModel","text":"ComponentItemModel ( parent = None ) Bases: QStandardItemModel View model for ModelComponent objects. Source code in src/cplus_plugin/gui/component_item_model.py 575 576 577 578 579 def __init__ ( self , parent = None ): super () . __init__ ( parent ) self . setColumnCount ( 1 ) self . _uuid_row_idx = {}","title":"ComponentItemModel"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ComponentItemModel.add_component_item","text":"add_component_item ( component_item , position =- 1 ) Adds a model component item to the view model. Parameters: Name Type Description Default component_item ModelComponentItem Model component item to be added to the view model. required position int Reference row to insert the item. -1 Returns: Type Description bool True if the component item was successfully added, else False if there is an existing component item with the same UUID. Source code in src/cplus_plugin/gui/component_item_model.py 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 def add_component_item ( self , component_item : ModelComponentItem , position =- 1 ) -> bool : \"\"\"Adds a model component item to the view model. :param component_item: Model component item to be added to the view model. :type component_item: ModelComponentItem :param position: Reference row to insert the item. :type position: int :returns: True if the component item was successfully added, else False if there is an existing component item with the same UUID. :rtype: bool \"\"\" idx = position if position == - 1 : idx = self . rowCount () if self . contains_item ( str ( component_item . uuid )): return False self . insertRow ( idx , component_item ) self . _re_index_rows () return True","title":"add_component_item()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ComponentItemModel.component_item_by_uuid","text":"component_item_by_uuid ( uuid_str ) Retrieves a ModelComponentItem based on a matching UUID. Parameters: Name Type Description Default uuid_str str UUID of the model item. required Returns: Type Description ModelComponentItem Component item matching the given UUID or None if not found. Source code in src/cplus_plugin/gui/component_item_model.py 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 def component_item_by_uuid ( self , uuid_str : str ) -> typing . Union [ ModelComponentItemType , None ]: \"\"\"Retrieves a ModelComponentItem based on a matching UUID. :param uuid_str: UUID of the model item. :type uuid_str: str :returns: Component item matching the given UUID or None if not found. :rtype: ModelComponentItem \"\"\" if uuid_str not in self . _uuid_row_idx : return None row = self . _uuid_row_idx [ uuid_str ] return self . item ( row )","title":"component_item_by_uuid()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ComponentItemModel.contains_item","text":"contains_item ( item_uuid ) Checks if the model contains an item with the given UUID. Parameters: Name Type Description Default item_uuid str UUID of the model item. required Returns: Type Description bool True if there is an existing item else False. Source code in src/cplus_plugin/gui/component_item_model.py 610 611 612 613 614 615 616 617 618 619 def contains_item ( self , item_uuid : str ) -> bool : \"\"\"Checks if the model contains an item with the given UUID. :param item_uuid: UUID of the model item. :type item_uuid: str :returns: True if there is an existing item else False. :rtype: bool \"\"\" return True if self . component_item_by_uuid ( item_uuid ) is not None else False","title":"contains_item()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ComponentItemModel.index_by_uuid","text":"index_by_uuid ( uuid_str ) Get the QModelIndex object for the component item matching the given UUID identifier. Parameters: Name Type Description Default uuid_str str UUID of the model item. required Returns: Type Description QtCore.QModelIndex QModelIndex for the component item matching the given UUID or an invalid QModelIndex if not found. Source code in src/cplus_plugin/gui/component_item_model.py 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 def index_by_uuid ( self , uuid_str ) -> QtCore . QModelIndex : \"\"\"Get the QModelIndex object for the component item matching the given UUID identifier. :param uuid_str: UUID of the model item. :type uuid_str: str :returns: QModelIndex for the component item matching the given UUID or an invalid QModelIndex if not found. :rtype: QtCore.QModelIndex \"\"\" if uuid_str not in self . _uuid_row_idx : return QtCore . QModelIndex () row = self . _uuid_row_idx [ uuid_str ] return self . index ( row , 0 )","title":"index_by_uuid()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ComponentItemModel.model_component_items","text":"model_component_items () Returns all model component items in the model. Returns: Type Description list Model component items in the model. Source code in src/cplus_plugin/gui/component_item_model.py 684 685 686 687 688 689 690 691 692 def model_component_items ( self ) -> typing . List [ ModelComponentItem ]: \"\"\"Returns all model component items in the model. :returns: Model component items in the model. :rtype: list \"\"\" rows = self . rowCount () return [ self . item ( r ) for r in range ( rows )]","title":"model_component_items()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ComponentItemModel.model_components","text":"model_components () Returns a collection of all model component objects in the model. Returns: Type Description list A collection of all model component objects. Source code in src/cplus_plugin/gui/component_item_model.py 674 675 676 677 678 679 680 681 682 def model_components ( self ) -> typing . List [ BaseModelComponentType ]: \"\"\"Returns a collection of all model component objects in the model. :returns: A collection of all model component objects. :rtype: list \"\"\" rows = self . rowCount () return [ self . item ( r ) . model_component for r in range ( rows )]","title":"model_components()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ComponentItemModel.remove_component_item","text":"remove_component_item ( uuid_str ) Removes a ModelComponentItem based on a matching UUID. Parameters: Name Type Description Default uuid_str str UUID of the model item to be removed. required Returns: Type Description bool True if the component item was successfully removed, else False if there was not matching UUID. Source code in src/cplus_plugin/gui/component_item_model.py 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 def remove_component_item ( self , uuid_str : str ) -> bool : \"\"\"Removes a ModelComponentItem based on a matching UUID. :param uuid_str: UUID of the model item to be removed. :type uuid_str: str :returns: True if the component item was successfully removed, else False if there was not matching UUID. :rtype: bool \"\"\" if not self . contains_item ( uuid_str ): return False if uuid_str not in self . _uuid_row_idx : return False self . removeRows ( self . _uuid_row_idx [ uuid_str ], 1 ) del self . _uuid_row_idx [ uuid_str ] self . _re_index_rows () return True","title":"remove_component_item()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ComponentItemModel.update_item","text":"update_item ( item ) Update an existing ModelComponentItem if it exists in the model. Parameters: Name Type Description Default item ModelComponentItemType An updated instance of the ModelComponentItem. required Returns: Type Description bool True if the item was successfully updated, else False if there was no matching item found in the model. Source code in src/cplus_plugin/gui/component_item_model.py 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 def update_item ( self , item : ModelComponentItemType ) -> bool : \"\"\"Update an existing ModelComponentItem if it exists in the model. :param item: An updated instance of the ModelComponentItem. :type item: ModelComponentItem :returns: True if the item was successfully updated, else False if there was no matching item found in the model. :rtype: bool \"\"\" if not self . contains_item ( item . uuid ): return False item . update ( item . model_component ) return True","title":"update_item()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.IMItemModel","text":"Bases: ComponentItemModel View model for implementation model.","title":"IMItemModel"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.IMItemModel.add_implementation_model","text":"add_implementation_model ( implementation_model , layer = None ) Add an ImplementationModel object to the model. Parameters: Name Type Description Default implementation_model ImplementationModel ImplementationModel object to be added to the view. required layer QgsMapLayer Map layer for the implementation model. None Returns: Type Description bool True if ImplementationModel object was added successfully, else False. Source code in src/cplus_plugin/gui/component_item_model.py 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 def add_implementation_model ( self , implementation_model : ImplementationModel , layer : QgsMapLayer = None ) -> bool : \"\"\"Add an ImplementationModel object to the model. :param implementation_model: ImplementationModel object to be added to the view. :type implementation_model: ImplementationModel :param layer: Map layer for the implementation model. :type layer: QgsMapLayer :returns: True if ImplementationModel object was added successfully, else False. :rtype: bool \"\"\" # Check if we can retrieve the layer from the path if layer is None : if implementation_model . path : layer = implementation_model . to_map_layer () implementation_model_item = ImplementationModelItem . create ( implementation_model ) result = self . add_component_item ( implementation_model_item ) if layer : status = self . set_model_layer ( implementation_model_item , layer ) if not status : result = False else : # Add NCS pathways. If there are underlying NCS pathway objects then # clone them, remove then re-insert so that the underlying NCS pathways can # have the unique UUID in the IM item. if result : cloned_implementation_model = clone_implementation_model ( implementation_model ) cloned_ncs_pathways = cloned_implementation_model . pathways # Remove pathways in the IM implementation_model . pathways = [] # Now add the NCSs afresh for ncs in cloned_ncs_pathways : ncs_item = NcsPathwayItem . create ( ncs ) self . add_ncs_pathway ( ncs_item , implementation_model_item ) return result","title":"add_implementation_model()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.IMItemModel.add_ncs_pathway","text":"add_ncs_pathway ( ncs_item , target_model_item ) Adds an NCS pathway item to the model. Parameters: Name Type Description Default ncs_item NcsPathwayItem NCS pathway item to the collection. required target_model_item ImplementationModelItem Target implementation model for the NCS item. required Returns: Type Description bool True if the NCS pathway item was successfully added, else False if there underlying NCS pathway object was invalid, there is an existing item with the same UUID or if there is already a map layer defined for the implementation model. Source code in src/cplus_plugin/gui/component_item_model.py 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 def add_ncs_pathway ( self , ncs_item : NcsPathwayItem , target_model_item : ImplementationModelItem ) -> bool : \"\"\"Adds an NCS pathway item to the model. :param ncs_item: NCS pathway item to the collection. :type ncs_item: NcsPathwayItem :param target_model_item: Target implementation model for the NCS item. :type target_model_item: ImplementationModelItem :returns: True if the NCS pathway item was successfully added, else False if there underlying NCS pathway object was invalid, there is an existing item with the same UUID or if there is already a map layer defined for the implementation model. \"\"\" idx = target_model_item . index () if not idx . isValid (): return False if not isinstance ( target_model_item , LayerComponentItem ): return False # If there is an existing layer then return if target_model_item . layer : return False clone_ncs_item = ncs_item . clone () status = target_model_item . add_ncs_pathway_item ( clone_ncs_item ) if not status : return False bottom_idx = target_model_item . bottom_ncs_item_index () reference_row = max ( bottom_idx . row (), idx . row ()) self . add_component_item ( clone_ncs_item , reference_row + 1 ) self . im_pathways_updated . emit ( target_model_item ) return True","title":"add_ncs_pathway()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.IMItemModel.dropMimeData","text":"dropMimeData ( data , action , row , column , parent ) Implements behaviour for handling data supplied by drag and drop operation. Parameters: Name Type Description Default data QMimeData Object containing data from the drag operation. required action DropAction Type of the drag and drop operation. required row int Row location of dropped data. required column int Column location of dropped data. required parent QModelIndex Index location for target item where the operation ended. required Returns: Type Description bool True if the data and action can be handled by the model, else False. Source code in src/cplus_plugin/gui/component_item_model.py 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 def dropMimeData ( self , data : QtCore . QMimeData , action : QtCore . Qt . DropAction , row : int , column : int , parent : QtCore . QModelIndex , ) -> bool : \"\"\"Implements behaviour for handling data supplied by drag and drop operation. :param data: Object containing data from the drag operation. :type data: QtCore.QMimeData :param action: Type of the drag and drop operation. :type action: QtCore.Qt.DropAction :param row: Row location of dropped data. :type row: int :param column: Column location of dropped data. :type column: int :param parent: Index location for target item where the operation ended. :type parent: QtCore.QModelIndex :returns: True if the data and action can be handled by the model, else False. :rtype: bool \"\"\" if action == QtCore . Qt . IgnoreAction : return True if not data . hasFormat ( NCS_MIME_TYPE ): return False encoded_data = data . data ( NCS_MIME_TYPE ) data_stream = QtCore . QDataStream ( encoded_data , QtCore . QIODevice . ReadOnly ) ncs_items = [] while not data_stream . atEnd (): byte_data = QtCore . QByteArray () data_stream >> byte_data item_data = json . loads ( byte_data . data ()) ncs_pathway = create_ncs_pathway ( item_data ) ncs_item = NcsPathwayItem ( ncs_pathway ) ncs_items . append ( ncs_item ) # Get reference ImplementationModel item if parent . isValid (): model_item = self . itemFromIndex ( parent ) else : row_count = self . rowCount () model_item = self . item ( row_count - 1 ) if model_item is None or isinstance ( model_item , LayerItem ): return False if model_item . type () == NCS_PATHWAY_TYPE : target_im_item = model_item . parent else : target_im_item = model_item # Add NCS items to model. status = True for item in ncs_items : status = self . add_ncs_pathway ( item , target_im_item ) return status","title":"dropMimeData()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.IMItemModel.model_items","text":"model_items () Returns all ImplementationModelItem objects in the model. Returns: Type Description list All implementation model items in the model. Source code in src/cplus_plugin/gui/component_item_model.py 1109 1110 1111 1112 1113 1114 1115 1116 1117 def model_items ( self ) -> typing . List [ ImplementationModelItem ]: \"\"\"Returns all ImplementationModelItem objects in the model. :returns: All implementation model items in the model. :rtype: list \"\"\" component_items = self . model_component_items () return [ ci for ci in component_items if ci . type () == IMPLEMENTATION_MODEL_TYPE ]","title":"model_items()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.IMItemModel.models","text":"models () Returns implementation model objects in the model. Returns: Type Description list All implementation model objects in the model. Source code in src/cplus_plugin/gui/component_item_model.py 1101 1102 1103 1104 1105 1106 1107 def models ( self ) -> typing . List [ ImplementationModel ]: \"\"\"Returns implementation model objects in the model. :returns: All implementation model objects in the model. :rtype: list \"\"\" return [ model_item . implementation_model for model_item in self . model_items ()]","title":"models()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.IMItemModel.remove_implementation_model","text":"remove_implementation_model ( uuid_str ) Remove an implementation model item from the model. param uuid: UUID of the implementation model item to be removed. Returns: Type Description bool True if the implementation model item as successfully removed, else False if there was not matching UUID. Source code in src/cplus_plugin/gui/component_item_model.py 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 def remove_implementation_model ( self , uuid_str : str ) -> bool : \"\"\"Remove an implementation model item from the model. param uuid: UUID of the implementation model item to be removed. :type uuid_str: str :returns: True if the implementation model item as successfully removed, else False if there was not matching UUID. :rtype: bool \"\"\" implementation_model_item = self . component_item_by_uuid ( uuid_str ) if implementation_model_item is None : return False if len ( implementation_model_item . ncs_items ) > 0 : ncs_items = implementation_model_item . ncs_items for item in ncs_items : self . remove_component_item ( item . uuid ) else : # Layer item self . remove_layer ( implementation_model_item ) return self . remove_component_item ( uuid_str )","title":"remove_implementation_model()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.IMItemModel.remove_layer","text":"remove_layer ( implementation_model_item ) Removes the layer reference from the underlying implementation model. Parameters: Name Type Description Default implementation_model_item ImplementationModelItem Implementation model item whose layer is to be removed. required Source code in src/cplus_plugin/gui/component_item_model.py 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 def remove_layer ( self , implementation_model_item : ImplementationModelItem ): \"\"\"Removes the layer reference from the underlying implementation model. :param implementation_model_item: Implementation model item whose layer is to be removed. :type implementation_model_item: ImplementationModelItem \"\"\" if implementation_model_item . layer is None : return if not self . contains_item ( implementation_model_item . uuid ): return # Remove item in model item_idx = self . index_by_uuid ( implementation_model_item . uuid ) layer_row = item_idx . row () + 1 self . removeRows ( layer_row , 1 ) # Remove underlying layer reference implementation_model_item . clear_layer ()","title":"remove_layer()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.IMItemModel.remove_ncs_pathway_item","text":"remove_ncs_pathway_item ( ncs_uuid , parent ) Remove an NCS pathway item from the model. param uuid: UUID of the NCS pathway item to be removed. Parameters: Name Type Description Default parent ImplementationModelItem Reference implementation model item that is the parent to the NCS pathway item. required Returns: Type Description bool True if the NCS pathway item has been successfully removed, else False if there was no matching UUID. Source code in src/cplus_plugin/gui/component_item_model.py 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 def remove_ncs_pathway_item ( self , ncs_uuid : str , parent : ImplementationModelItem ) -> bool : \"\"\"Remove an NCS pathway item from the model. param uuid: UUID of the NCS pathway item to be removed. :type ncs_uuid: str :param parent: Reference implementation model item that is the parent to the NCS pathway item. :type parent: ImplementationModelItem :returns: True if the NCS pathway item has been successfully removed, else False if there was no matching UUID. :rtype: bool \"\"\" status = parent . remove_ncs_pathway_item ( ncs_uuid ) if not status : return False self . im_pathways_updated . emit ( parent ) return self . remove_component_item ( ncs_uuid )","title":"remove_ncs_pathway_item()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.IMItemModel.set_model_layer","text":"set_model_layer ( implementation_model_item , layer , display_name = '' ) Set the layer for the given implementation model item. Parameters: Name Type Description Default implementation_model_item ImplementationModelItem Implementation model item whose layer is to be specified. required layer QgsMapLayer Map layer to be set for the implementation model. required display_name str Display name for the layer node. If not specified then the name from the map layer is used. '' Returns: Type Description bool True if the layer was successfully set for the implementation model, else False if the layer is invalid, if there are already existing NCS pathways in the implementation model or if the item is not in the model. Source code in src/cplus_plugin/gui/component_item_model.py 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 def set_model_layer ( self , implementation_model_item : ImplementationModelItem , layer : QgsMapLayer , display_name : str = \"\" , ) -> bool : \"\"\"Set the layer for the given implementation model item. :param implementation_model_item: Implementation model item whose layer is to be specified. :type implementation_model_item: ImplementationModelItem :param layer: Map layer to be set for the implementation model. :type layer: QgsMapLayer :param display_name: Display name for the layer node. If not specified then the name from the map layer is used. :type display_name: str :returns: True if the layer was successfully set for the implementation model, else False if the layer is invalid, if there are already existing NCS pathways in the implementation model or if the item is not in the model. :rtype: bool \"\"\" if len ( implementation_model_item . ncs_items ) > 0 : return False if not self . contains_item ( implementation_model_item . uuid ): return False if not implementation_model_item . set_layer ( layer ): return False if not display_name : display_name = layer . name () icon = FileUtils . get_icon ( \"mIconRaster.svg\" ) item = LayerItem ( icon , display_name ) item . setToolTip ( display_name ) item . setData ( implementation_model_item ) item_idx = self . index_by_uuid ( implementation_model_item . uuid ) layer_row = item_idx . row () + 1 self . insertRow ( layer_row , item ) return True","title":"set_model_layer()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.IMItemModel.update_implementation_model","text":"update_implementation_model ( implementation_model , layer = None ) Updates the implementation model item in the model. Parameters: Name Type Description Default implementation_model ImplementationModel implementation_model object whose corresponding item is to be updated. required layer QgsMapLayer Map layer to be updated for the implementation if specified. None Returns: Type Description bool Returns True if the operation was successful else False if the matching item was not found in the model. Source code in src/cplus_plugin/gui/component_item_model.py 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 def update_implementation_model ( self , implementation_model : ImplementationModel , layer : QgsMapLayer = None ) -> bool : \"\"\"Updates the implementation model item in the model. :param implementation_model: implementation_model object whose corresponding item is to be updated. :type implementation_model: ImplementationModel :param layer: Map layer to be updated for the implementation if specified. :type layer: QgsMapLayer :returns: Returns True if the operation was successful else False if the matching item was not found in the model. \"\"\" item = self . component_item_by_uuid ( str ( implementation_model . uuid )) if item is None : return False status = self . update_item ( item ) if not status : return False # Update layer information self . remove_layer ( item ) if layer : layer_status = self . set_model_layer ( item , layer ) if not layer_status : return False return True","title":"update_implementation_model()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.IMItemModel.update_ncs_pathway_items","text":"update_ncs_pathway_items ( ncs_pathway ) Update NCS pathway items matching the given NCS pathway model. If the NCS pathway model is not valid then the NCS pathway items in the implementation model item will not be updated. Returns: Type Description bool True if matching NCS pathway items have been updated, else False. Source code in src/cplus_plugin/gui/component_item_model.py 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 def update_ncs_pathway_items ( self , ncs_pathway : NcsPathway ) -> bool : \"\"\"Update NCS pathway items matching the given NCS pathway model. If the NCS pathway model is not valid then the NCS pathway items in the implementation model item will not be updated. :returns: True if matching NCS pathway items have been updated, else False. :rtype: bool \"\"\" if not ncs_pathway . is_valid (): return False for im_item in self . model_items (): ncs_item_for_original = im_item . ncs_item_from_original_pathway ( ncs_pathway ) if ncs_item_for_original is None : continue item_pathway = ncs_item_for_original . ncs_pathway # Copy attribute values excluding the UUID copy_layer_component_attributes ( item_pathway , ncs_pathway ) ncs_item_for_original . update ( item_pathway ) return True","title":"update_ncs_pathway_items()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ImplementationModelItem","text":"ImplementationModelItem ( implementation_model ) Bases: LayerComponentItem Standard item for an implementation model object. Source code in src/cplus_plugin/gui/component_item_model.py 292 293 294 295 296 297 298 299 300 301 302 303 304 def __init__ ( self , implementation_model : ImplementationModel ): super () . __init__ ( implementation_model ) self . _implementation_model = implementation_model font = self . font () font . setBold ( True ) self . setFont ( font ) self . _ncs_items = [] # Remap pathway uuids so that there are no duplicate # pathways under each implementation model. self . _uuid_remap = {}","title":"ImplementationModelItem"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ImplementationModelItem.implementation_model","text":"implementation_model Returns an instance of the underlying ImplementationModel object. Returns: Type Description ImplementationModel The underlying ImplementationModel object.","title":"implementation_model"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ImplementationModelItem.layer_item","text":"layer_item Returns the view item for the layer. Returns: Type Description QtGui.QStandardItem Returns the view item for the map layer else False if no layer has been specified for the model.","title":"layer_item"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ImplementationModelItem.ncs_items","text":"ncs_items Returns a collection of NcsPathwayItem in this implementation model. Returns: Type Description list Collection of NcsPathwayItem objects in this implementation model.","title":"ncs_items"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ImplementationModelItem.ncs_pathways","text":"ncs_pathways Returns a collection of NcsPathway objects. Returns: Type Description list Collection of NcsPathway objects linked to the underlying ImplementationModel object.","title":"ncs_pathways"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ImplementationModelItem.original_ncs_pathways","text":"original_ncs_pathways Returns a collection of NcsPathway objects but with their original UUIDs. These are used for persisting the NCsPathway objects related to the underlying IM object. Returns: Type Description list Collection of NcsPathway objects with their original UUIDs linked to the underlying ImplementationModel object.","title":"original_ncs_pathways"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ImplementationModelItem.add_ncs_pathway_item","text":"add_ncs_pathway_item ( ncs_item ) Adds an NCS pathway item to this implementation model item. If the item already contains a layer, then the add operation will not be successful. Parameters: Name Type Description Default ncs_item NcsPathwayItem NCS pathway item to the collection. required Returns: Type Description bool True if the NCS pathway item was successfully added, else False if there underlying NCS pathway object was invalid, there is an existing item with the same UUID or if the layer property had already been set. Source code in src/cplus_plugin/gui/component_item_model.py 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 def add_ncs_pathway_item ( self , ncs_item : NcsPathwayItem ) -> bool : \"\"\"Adds an NCS pathway item to this implementation model item. If the item already contains a layer, then the add operation will not be successful. :param ncs_item: NCS pathway item to the collection. :type ncs_item: NcsPathwayItem :returns: True if the NCS pathway item was successfully added, else False if there underlying NCS pathway object was invalid, there is an existing item with the same UUID or if the layer property had already been set. \"\"\" if self . layer : return False old_uuid = ncs_item . uuid new_uuid = uuid4 () ncs_item . ncs_pathway . uuid = new_uuid if old_uuid in self . _uuid_remap : return False if self . contains_ncs_item ( ncs_item . uuid ): return False if not ncs_item . is_valid (): return False if self . _implementation_model . contains_pathway ( ncs_item . uuid ): return False if not self . _implementation_model . add_ncs_pathway ( ncs_item . ncs_pathway ): return False self . _ncs_items . append ( ncs_item ) ncs_item . _parent = self self . _uuid_remap [ old_uuid ] = str ( new_uuid ) return True","title":"add_ncs_pathway_item()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ImplementationModelItem.bottom_ncs_item_index","text":"bottom_ncs_item_index () Returns the model index of the bottom-most NcsPathwayItem under this implementation model item. Returns: Type Description QModelIndex Model index of the bottom-most NcsPathwayItem. Source code in src/cplus_plugin/gui/component_item_model.py 510 511 512 513 514 515 516 517 518 519 520 521 522 def bottom_ncs_item_index ( self ) -> typing . Union [ QtCore . QModelIndex , None ]: \"\"\"Returns the model index of the bottom-most NcsPathwayItem under this implementation model item. :returns: Model index of the bottom-most NcsPathwayItem. :rtype: QModelIndex \"\"\" if len ( self . _ncs_items ) == 0 : return None bottom_ncs_item = max ( self . _ncs_items , key = lambda n : n . index () . row ()) return bottom_ncs_item . index ()","title":"bottom_ncs_item_index()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ImplementationModelItem.clear_layer","text":"clear_layer () Clears the layer reference in the model component. Source code in src/cplus_plugin/gui/component_item_model.py 400 401 402 def clear_layer ( self ): \"\"\"Clears the layer reference in the model component.\"\"\" self . _implementation_model . clear_layer ()","title":"clear_layer()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ImplementationModelItem.clone","text":"clone () Creates a cloned version of this item. The cloned IM will contain pathways with the original UUID. The UUID of the IM will not change. Source code in src/cplus_plugin/gui/component_item_model.py 543 544 545 546 547 548 549 550 551 552 553 554 555 def clone ( self ) -> \"ImplementationModelItem\" : \"\"\"Creates a cloned version of this item. The cloned IM will contain pathways with the original UUID. The UUID of the IM will not change. \"\"\" implementation_model = clone_implementation_model ( self . implementation_model , ) # Use NCS pathways with original UUIDs implementation_model . pathways = self . original_ncs_pathways return ImplementationModelItem ( implementation_model )","title":"clone()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ImplementationModelItem.contains_ncs_item","text":"contains_ncs_item ( item_uuid ) Checks whether this item contains an NcsPathway item with the given UUID. Parameters: Name Type Description Default item_uuid str UUID of the NcsPathway item to search for. required Returns: Type Description bool True if there is an NcsPathwayItem matching the given UUID, else False. Source code in src/cplus_plugin/gui/component_item_model.py 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 def contains_ncs_item ( self , item_uuid : str ) -> bool : \"\"\"Checks whether this item contains an NcsPathway item with the given UUID. :param item_uuid: UUID of the NcsPathway item to search for. :type item_uuid: str :returns: True if there is an NcsPathwayItem matching the given UUID, else False. :rtype: bool \"\"\" if self . ncs_item_by_uuid ( item_uuid ) is None : return False return True","title":"contains_ncs_item()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ImplementationModelItem.create","text":"create ( implementation_model ) Creates an instance of the ImplementationModelItem from the model object. Returns: Type Description ImplementationModel An instance of the ImplementationModelItem item to be used in a standard model. Source code in src/cplus_plugin/gui/component_item_model.py 532 533 534 535 536 537 538 539 540 541 @staticmethod def create ( implementation_model : ImplementationModel ) -> \"ImplementationModelItem\" : \"\"\"Creates an instance of the ImplementationModelItem from the model object. :returns: An instance of the ImplementationModelItem item to be used in a standard model. :rtype: ImplementationModel \"\"\" return ImplementationModelItem ( implementation_model )","title":"create()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ImplementationModelItem.ncs_item_by_uuid","text":"ncs_item_by_uuid ( ncs_uuid ) Returns an NcsPathway item matching the given UUID. Parameters: Name Type Description Default ncs_uuid str UUID of the NcsPathway item to retrieve. required Returns: Type Description NcsPathwayItem NcsPathwayItem matching the given UUID, else None if not found. Source code in src/cplus_plugin/gui/component_item_model.py 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 def ncs_item_by_uuid ( self , ncs_uuid : str ) -> typing . Union [ NcsPathwayItem , None ]: \"\"\"Returns an NcsPathway item matching the given UUID. :param ncs_uuid: UUID of the NcsPathway item to retrieve. :type ncs_uuid: str :returns: NcsPathwayItem matching the given UUID, else None if not found. :rtype: NcsPathwayItem \"\"\" ncs_items = [ n for n in self . _ncs_items if n . uuid == ncs_uuid ] if len ( ncs_items ) == 0 : return None return ncs_items [ 0 ]","title":"ncs_item_by_uuid()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ImplementationModelItem.ncs_item_from_original_pathway","text":"ncs_item_from_original_pathway ( ncs_pathway ) Retrieves the NCS item corresponding to the original NCS pathway i.e. before it is added to this implementation model item. Parameters: Name Type Description Default ncs_pathway NcsPathway Original NCS pathway data model. required Returns: Type Description Union [ NcsPathwayItem , None] The matching NCS pathway item in this implementation model item, else None if there is no matching item. Source code in src/cplus_plugin/gui/component_item_model.py 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 def ncs_item_from_original_pathway ( self , ncs_pathway : NcsPathway ) -> typing . Union [ NcsPathwayItem , None ]: \"\"\"Retrieves the NCS item corresponding to the original NCS pathway i.e. before it is added to this implementation model item. :param ncs_pathway: Original NCS pathway data model. :type ncs_pathway: NcsPathway :returns: The matching NCS pathway item in this implementation model item, else None if there is no matching item. \"\"\" ncs_uuid = str ( ncs_pathway . uuid ) if ncs_uuid not in self . _uuid_remap : return None new_uuid = self . _uuid_remap [ ncs_uuid ] return self . ncs_item_by_uuid ( new_uuid )","title":"ncs_item_from_original_pathway()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ImplementationModelItem.remove_ncs_pathway_item","text":"remove_ncs_pathway_item ( item_uuid ) Removes the NcsPathwayItem matching the given UUID. Parameters: Name Type Description Default item_uuid str The UUID of the NcsPathwayItem to remove. required Returns: Type Description bool True if the item was successfully removed, else False. Source code in src/cplus_plugin/gui/component_item_model.py 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 def remove_ncs_pathway_item ( self , item_uuid : str ) -> bool : \"\"\"Removes the NcsPathwayItem matching the given UUID. :param item_uuid: The UUID of the NcsPathwayItem to remove. :type item_uuid: str :returns: True if the item was successfully removed, else False. :rtype: bool \"\"\" if not self . contains_ncs_item ( item_uuid ): return False idxs = [ i for i , n in enumerate ( self . _ncs_items ) if n . uuid == item_uuid ] if len ( idxs ) == 0 : return False item = self . _ncs_items . pop ( idxs [ 0 ]) item . _parent = None del item self . _implementation_model . remove_ncs_pathway ( item_uuid ) old_uuids = [ k for k , v in self . _uuid_remap . items () if v == item_uuid ] if len ( old_uuids ) > 0 : del self . _uuid_remap [ old_uuids [ 0 ]] return True","title":"remove_ncs_pathway_item()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ImplementationModelItem.type","text":"type () Returns the type of the standard item. Returns: Type Description int Type identifier of the standard item. Source code in src/cplus_plugin/gui/component_item_model.py 524 525 526 527 528 529 530 def type ( self ) -> int : \"\"\"Returns the type of the standard item. :returns: Type identifier of the standard item. :rtype: int \"\"\" return IMPLEMENTATION_MODEL_TYPE","title":"type()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.LayerComponentItem","text":"LayerComponentItem ( model_component ) Bases: ModelComponentItem Base class view item for layer-based component items. Source code in src/cplus_plugin/gui/component_item_model.py 130 131 132 133 def __init__ ( self , model_component : LayerModelComponent ): if not isinstance ( model_component , LayerModelComponent ): raise TypeError ( \"'model_component' not of type LayerModelComponent\" ) super () . __init__ ( model_component )","title":"LayerComponentItem"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.LayerComponentItem.layer","text":"layer Returns the map layer from the underlying model component object. Returns: Type Description QgsMapLayer Map layer corresponding from the underlying model component.","title":"layer"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.LayerComponentItem.clone","text":"clone () Creates a deep copied version of the model item. Returns: Type Description ModelComponentItem Cloned version of the model item containing all the properties as the source. Source code in src/cplus_plugin/gui/component_item_model.py 204 205 206 207 208 209 210 211 212 @abstractmethod def clone ( self ) -> \"ModelComponentItemType\" : \"\"\"Creates a deep copied version of the model item. :returns: Cloned version of the model item containing all the properties as the source. :rtype: ModelComponentItem \"\"\" pass","title":"clone()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.LayerComponentItem.create","text":"create ( model_component ) Factory method for creating an instance of a model item. This is an abstract method that needs to be implemented by subclasses. Parameters: Name Type Description Default model_component BaseModelComponent Source model component for creating the corresponding item. required Returns: Type Description ModelComponentItem Model component item for use in a standard item model. Source code in src/cplus_plugin/gui/component_item_model.py 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 @staticmethod @abstractmethod def create ( model_component : BaseModelComponent ) -> \"ModelComponentItem\" : \"\"\"Factory method for creating an instance of a model item. This is an abstract method that needs to be implemented by subclasses. :param model_component: Source model component for creating the corresponding item. :type model_component: BaseModelComponent :returns: Model component item for use in a standard item model. :rtype: ModelComponentItem \"\"\" pass","title":"create()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.LayerComponentItem.is_valid","text":"is_valid () Checks whether the map layer of the underlying model component object is valid. Returns: Type Description bool True if the map layer is valid, else False if map layer is invalid or of None type. Source code in src/cplus_plugin/gui/component_item_model.py 135 136 137 138 139 140 141 142 143 144 145 146 def is_valid ( self ) -> bool : \"\"\"Checks whether the map layer of the underlying model component object is valid. :returns: True if the map layer is valid, else False if map layer is invalid or of None type. :rtype: bool \"\"\" if self . _model_component is None : return False return self . _model_component . is_valid ()","title":"is_valid()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.LayerComponentItem.set_layer","text":"set_layer ( layer ) Set the map layer for the component item. It sets the :py:attr: ~path attribute of the underlying data model. Parameters: Name Type Description Default layer QgsMapLayer Map layer for the component item. required Returns: Type Description bool Returns True if the layer was successfully set, else False if the layer is invalid. Source code in src/cplus_plugin/gui/component_item_model.py 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 def set_layer ( self , layer : QgsMapLayer ) -> bool : \"\"\"Set the map layer for the component item. It sets the :py:attr:`~path` attribute of the underlying data model. :param layer: Map layer for the component item. :type layer: QgsMapLayer :returns: Returns True if the layer was successfully set, else False if the layer is invalid. :rtype: bool \"\"\" if not layer : return False if not layer . isValid (): return False path = layer . source () self . _model_component . path = path if isinstance ( layer , QgsRasterLayer ): self . _model_component . layer_type = LayerType . RASTER elif isinstance ( layer , QgsVectorLayer ): self . _model_component . layer_type = LayerType . VECTOR return True","title":"set_layer()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.LayerItem","text":"Bases: QStandardItem Contains a custom identifier for an item used to define a layer for an implementation model.","title":"LayerItem"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.LayerItem.type","text":"type () Returns the type of the standard item. Returns: Type Description int Type identifier of the standard item. Source code in src/cplus_plugin/gui/component_item_model.py 563 564 565 566 567 568 569 def type ( self ) -> int : \"\"\"Returns the type of the standard item. :returns: Type identifier of the standard item. :rtype: int \"\"\" return LAYER_ITEM_TYPE","title":"type()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ModelComponentItem","text":"ModelComponentItem ( model_component ) Bases: QStandardItem Base standard item for a BaseModelComponent object. Source code in src/cplus_plugin/gui/component_item_model.py 44 45 46 47 48 49 50 def __init__ ( self , model_component : BaseModelComponent ): super () . __init__ ( model_component . name ) self . setToolTip ( model_component . name ) self . _model_component = model_component if self . _model_component is not None : self . update ( self . _model_component )","title":"ModelComponentItem"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ModelComponentItem.description","text":"description Returns the description of the item. Returns: Type Description str Description of the item.","title":"description"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ModelComponentItem.model_component","text":"model_component Returns an instance of the underlying model component object. Returns: Type Description BaseModelComponent Instance of underlying model component object.","title":"model_component"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ModelComponentItem.uuid","text":"uuid Returns the UUID of the item. Returns: Type Description str UUID string of the item.","title":"uuid"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ModelComponentItem.clone","text":"clone () Creates a deep copied version of the model item. Returns: Type Description ModelComponentItem Cloned version of the model item containing all the properties as the source. Source code in src/cplus_plugin/gui/component_item_model.py 111 112 113 114 115 116 117 118 119 @abstractmethod def clone ( self ) -> \"ModelComponentItemType\" : \"\"\"Creates a deep copied version of the model item. :returns: Cloned version of the model item containing all the properties as the source. :rtype: ModelComponentItem \"\"\" pass","title":"clone()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ModelComponentItem.create","text":"create ( model_component ) Factory method for creating an instance of a model item. This is an abstract method that needs to be implemented by subclasses. Parameters: Name Type Description Default model_component BaseModelComponent Source model component for creating the corresponding item. required Returns: Type Description ModelComponentItem Model component item for use in a standard item model. Source code in src/cplus_plugin/gui/component_item_model.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 @staticmethod @abstractmethod def create ( model_component : BaseModelComponent ) -> \"ModelComponentItem\" : \"\"\"Factory method for creating an instance of a model item. This is an abstract method that needs to be implemented by subclasses. :param model_component: Source model component for creating the corresponding item. :type model_component: BaseModelComponent :returns: Model component item for use in a standard item model. :rtype: ModelComponentItem \"\"\" pass","title":"create()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ModelComponentItem.update","text":"update ( model_component ) Update the component-related properties of the item. Source code in src/cplus_plugin/gui/component_item_model.py 52 53 54 55 56 57 58 59 def update ( self , model_component : BaseModelComponent ): \"\"\"Update the component-related properties of the item.\"\"\" if model_component is None : return self . _model_component = model_component self . setText ( model_component . name ) self . setToolTip ( model_component . name )","title":"update()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItem","text":"NcsPathwayItem ( ncs ) Bases: LayerComponentItem Standard item for an NCS pathway object. Source code in src/cplus_plugin/gui/component_item_model.py 218 219 220 221 def __init__ ( self , ncs : NcsPathway ): super () . __init__ ( ncs ) self . _ncs_pathway = ncs self . _parent = None","title":"NcsPathwayItem"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItem.ncs_pathway","text":"ncs_pathway Returns an instance of the underlying NcsPathway object. Returns: Type Description NcsPathway The underlying NcsPathway model object.","title":"ncs_pathway"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItem.parent","text":"parent Returns the parent ImplementationModelItem if specified. Returns: Type Description ImplementationModelItem Returns the parent item if set when this item is mapped to an ImplementationModelItem.","title":"parent"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItem.clone","text":"clone () Creates a cloned version of this item. Source code in src/cplus_plugin/gui/component_item_model.py 260 261 262 263 264 def clone ( self ) -> \"NcsPathwayItem\" : \"\"\"Creates a cloned version of this item.\"\"\" ncs = clone_ncs_pathway ( self . ncs_pathway ) return NcsPathwayItem ( ncs )","title":"clone()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItem.create","text":"create ( ncs ) Creates an instance of the NcsPathwayItem from the model object. Returns: Type Description NcsPathwayItem An instance of the NcsPathway item to be used in a standard model. Source code in src/cplus_plugin/gui/component_item_model.py 250 251 252 253 254 255 256 257 258 @staticmethod def create ( ncs : NcsPathway ) -> \"NcsPathwayItem\" : \"\"\"Creates an instance of the NcsPathwayItem from the model object. :returns: An instance of the NcsPathway item to be used in a standard model. :rtype: NcsPathwayItem \"\"\" return NcsPathwayItem ( ncs )","title":"create()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItem.is_carbon_valid","text":"is_carbon_valid () Returns the validity of the carbon layers in the underlying NCSPathway model object. Returns: Type Description bool True if the carbon layers are valid, else False. Source code in src/cplus_plugin/gui/component_item_model.py 278 279 280 281 282 283 284 285 286 def is_carbon_valid ( self ) -> bool : \"\"\"Returns the validity of the carbon layers in the underlying NCSPathway model object. :returns: True if the carbon layers are valid, else False. :rtype: bool \"\"\" return self . ncs_pathway . is_carbon_valid ()","title":"is_carbon_valid()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItem.json_data","text":"json_data () Creates a mapping of NCS pathway property names and their corresponding values. Returns: Type Description str JSON representation of property name-value pairs for an NCS pathway object. Source code in src/cplus_plugin/gui/component_item_model.py 266 267 268 269 270 271 272 273 274 275 276 def json_data ( self ) -> str : \"\"\"Creates a mapping of NCS pathway property names and their corresponding values. :returns: JSON representation of property name-value pairs for an NCS pathway object. :rtype: str \"\"\" ncs_attrs = ncs_pathway_to_dict ( self . _ncs_pathway ) return json . dumps ( ncs_attrs )","title":"json_data()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItem.type","text":"type () Returns the type of the standard item. Returns: Type Description int Type identifier of the standard item. Source code in src/cplus_plugin/gui/component_item_model.py 242 243 244 245 246 247 248 def type ( self ) -> int : \"\"\"Returns the type of the standard item. :returns: Type identifier of the standard item. :rtype: int \"\"\" return NCS_PATHWAY_TYPE","title":"type()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItemModel","text":"Bases: ComponentItemModel View model for NCS pathways.","title":"NcsPathwayItemModel"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItemModel.add_ncs_pathway","text":"add_ncs_pathway ( ncs ) Add an NCS pathway object to the model. Parameters: Name Type Description Default ncs NcsPathway NCS pathway object to the added to the view. required Returns: Type Description bool True if the NCS pathway object was added successfully, else False if the NcsPathway object is invalid. Source code in src/cplus_plugin/gui/component_item_model.py 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 def add_ncs_pathway ( self , ncs : NcsPathway ) -> bool : \"\"\"Add an NCS pathway object to the model. :param ncs: NCS pathway object to the added to the view. :type ncs: NcsPathway :returns: True if the NCS pathway object was added successfully, else False if the NcsPathway object is invalid. :rtype: bool \"\"\" ncs_item = NcsPathwayItem . create ( ncs ) self . _update_display ( ncs_item ) status = self . add_component_item ( ncs_item ) self . sort ( 0 ) self . _re_index_rows () return status","title":"add_ncs_pathway()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItemModel.mimeData","text":"mimeData ( indexes ) Serializes the NCS items corresponding to the specified indexes. Parameters: Name Type Description Default indexes List [ QModelIndex ] NCS items stored in the specified indexes. required Returns: Type Description QtCore.QMimeData Mime object containing serialized NCS items. Source code in src/cplus_plugin/gui/component_item_model.py 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 def mimeData ( self , indexes : typing . List [ QtCore . QModelIndex ]) -> QtCore . QMimeData : \"\"\"Serializes the NCS items corresponding to the specified indexes. :param indexes: NCS items stored in the specified indexes. :type indexes: list :returns: Mime object containing serialized NCS items. :rtype: QtCore.QMimeData \"\"\" mime_data = QtCore . QMimeData () item_data = QtCore . QByteArray () data_stream = QtCore . QDataStream ( item_data , QtCore . QIODevice . WriteOnly ) for idx in indexes : if not idx . isValid (): continue ncs_item = self . itemFromIndex ( idx ) if ncs_item is None : continue ncs_data = QtCore . QByteArray () ncs_data . append ( ncs_item . json_data ()) data_stream << ncs_data mime_data . setData ( NCS_MIME_TYPE , item_data ) return mime_data","title":"mimeData()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItemModel.mimeTypes","text":"mimeTypes () Returns supported MIME types that can be used to describe a list of model indexes for NCS pathway items. Returns: Type Description list MIME type for NCS pathway items which is JSON string but MIME type is the default datalist type for Qt since it does not allow custom types. Source code in src/cplus_plugin/gui/component_item_model.py 839 840 841 842 843 844 845 846 847 848 def mimeTypes ( self ) -> typing . List [ str ]: \"\"\"Returns supported MIME types that can be used to describe a list of model indexes for NCS pathway items. :returns: MIME type for NCS pathway items which is JSON string but MIME type is the default datalist type for Qt since it does not allow custom types. :rtype: list \"\"\" return [ NCS_MIME_TYPE ]","title":"mimeTypes()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItemModel.pathways","text":"pathways ( valid_only = False ) Returns NCS pathway objects in the model. Parameters: Name Type Description Default valid_only bool Whether to only return NCS pathway objects that are valid. False Returns: Type Description list All NCS pathway objects in the model (default), else only those NCS pathway objects that are valid if valid_only is True. Source code in src/cplus_plugin/gui/component_item_model.py 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 def pathways ( self , valid_only : bool = False ) -> typing . List [ NcsPathway ]: \"\"\"Returns NCS pathway objects in the model. :param valid_only: Whether to only return NCS pathway objects that are valid. :type valid_only: bool :returns: All NCS pathway objects in the model (default), else only those NCS pathway objects that are valid if valid_only is True. :rtype: list \"\"\" ncs_pathways = self . model_components () if valid_only : return [ p for p in ncs_pathways if p . is_valid ()] return ncs_pathways","title":"pathways()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItemModel.remove_ncs_pathway","text":"remove_ncs_pathway ( ncs_uuid ) Remove an NCS pathway item from the model. param uuid: UUID of the NCS pathway item to be removed. Returns: Type Description bool True if the NCS pathway item as successfully removed, else False if there was not matching UUID. Source code in src/cplus_plugin/gui/component_item_model.py 817 818 819 820 821 822 823 824 825 826 827 def remove_ncs_pathway ( self , ncs_uuid : str ) -> bool : \"\"\"Remove an NCS pathway item from the model. param uuid: UUID of the NCS pathway item to be removed. :type ncs_uuid: str :returns: True if the NCS pathway item as successfully removed, else False if there was not matching UUID. :rtype: bool \"\"\" return self . remove_component_item ( ncs_uuid )","title":"remove_ncs_pathway()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItemModel.supportedDropActions","text":"supportedDropActions () Configure the model to only support copying items in a drag-and-drop operation. Returns: Type Description QtCore.Qt.DropActions Supported drag-and-drop action for NCS pathway items. Source code in src/cplus_plugin/gui/component_item_model.py 829 830 831 832 833 834 835 836 837 def supportedDropActions ( self ) -> QtCore . Qt . DropActions : \"\"\"Configure the model to only support copying items in a drag-and-drop operation. :returns: Supported drag-and-drop action for NCS pathway items. :rtype: QtCore.Qt.DropActions \"\"\" return QtCore . Qt . CopyAction","title":"supportedDropActions()"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItemModel.update_ncs_pathway","text":"update_ncs_pathway ( ncs ) Updates the NCS pathway item in the model. Parameters: Name Type Description Default ncs NcsPathway NcsPathway whose corresponding item is to be updated. required Returns: Type Description bool Returns True if the operation was successful else False if the matching item was not found in the model. Source code in src/cplus_plugin/gui/component_item_model.py 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 def update_ncs_pathway ( self , ncs : NcsPathway ) -> bool : \"\"\"Updates the NCS pathway item in the model. :param ncs: NcsPathway whose corresponding item is to be updated. :type ncs: NcsPathway :returns: Returns True if the operation was successful else False if the matching item was not found in the model. \"\"\" item = self . component_item_by_uuid ( str ( ncs . uuid )) if item is None : return False status = self . update_item ( item ) if not status : return False self . _update_display ( item ) self . sort ( 0 ) self . _re_index_rows () return True","title":"update_ncs_pathway()"},{"location":"developer/api/gui/api_gui_main/","text":"GUI main The plugin main window class. QgisCplusMain QgisCplusMain ( iface , parent = None ) Bases: QDockWidget , WidgetUi Main plugin UI Source code in src/cplus_plugin/gui/qgis_cplus_main.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 def __init__ ( self , iface , parent = None , ): super () . __init__ ( parent ) self . setupUi ( self ) self . iface = iface self . progress_dialog = None self . task = None self . processing_cancelled = False # Insert widget for step 2 self . implementation_model_widget = ImplementationModelContainerWidget ( self ) self . tab_widget . insertTab ( 1 , self . implementation_model_widget , self . tr ( \"Step 2\" ) ) self . tab_widget . currentChanged . connect ( self . on_tab_step_changed ) self . prepare_input () # Step 3, priority weighting layers initialization self . priority_groups_widgets = {} self . initialize_priority_layers () self . position_feedback = QgsProcessingFeedback () self . processing_context = QgsProcessingContext () self . scenario_result = None self . analysis_finished . connect ( self . post_analysis ) # Report manager self . report_manager = report_manager self . report_manager . generate_started . connect ( self . on_report_running ) self . report_manager . generate_completed . connect ( self . on_report_finished ) self . reporting_feedback : typing . Union [ QgsFeedback , None ] = None add_priority_layer add_priority_layer () Adds a new priority layer into the plugin, then updates the priority list to show the new added priority layer. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 506 507 508 509 510 511 512 def add_priority_layer ( self ): \"\"\"Adds a new priority layer into the plugin, then updates the priority list to show the new added priority layer. \"\"\" layer_dialog = PriorityLayerDialog () layer_dialog . exec_ () self . update_priority_layers ( update_groups = False ) add_priority_layer_group add_priority_layer_group ( target_group = None , priority_layer = None ) Adds priority layer from the weighting layers into a priority group If no target_group or priority_layer is passed then the current selected group or priority layer from their respective list will be used. Checks if priority layer is already in the target group and if so no addition is done. Once the addition is done, the respective priority layer plugin settings are updated to store the new information. Parameters: Name Type Description Default target_group dict Priority group where layer will be added to None priority_layer dict Priority weighting layer to be added None Source code in src/cplus_plugin/gui/qgis_cplus_main.py 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 def add_priority_layer_group ( self , target_group = None , priority_layer = None ): \"\"\"Adds priority layer from the weighting layers into a priority group If no target_group or priority_layer is passed then the current selected group or priority layer from their respective list will be used. Checks if priority layer is already in the target group and if so no addition is done. Once the addition is done, the respective priority layer plugin settings are updated to store the new information. :param target_group: Priority group where layer will be added to :type target_group: dict :param priority_layer: Priority weighting layer to be added :type priority_layer: dict \"\"\" selected_priority_layers = ( priority_layer or self . priority_layers_list . selectedItems () ) selected_priority_layers = ( [ selected_priority_layers ] if not isinstance ( selected_priority_layers , list ) else selected_priority_layers ) selected_group = target_group or self . priority_groups_list . currentItem () for selected_priority_layer in selected_priority_layers : if ( selected_group is not None and selected_group . parent () is None ) and selected_priority_layer is not None : children = selected_group . takeChildren () item_found = False text = selected_priority_layer . data ( QtCore . Qt . DisplayRole ) for child in children : if child . text ( 0 ) == text : item_found = True break selected_group . addChildren ( children ) if not item_found : selected_group . setExpanded ( True ) item = QtWidgets . QTreeWidgetItem ( selected_group ) item . setText ( 0 , text ) group_widget = self . priority_groups_list . itemWidget ( selected_group , 0 ) layer_id = selected_priority_layer . data ( QtCore . Qt . UserRole ) priority_layer = settings_manager . get_priority_layer ( layer_id ) target_group_name = ( group_widget . group . get ( \"name\" ) if group_widget . group else None ) groups = priority_layer . get ( \"groups\" ) new_groups = [] group_found = False for group in groups : if target_group_name == group [ \"name\" ]: group_found = True new_group = settings_manager . find_group_by_name ( target_group_name ) else : new_group = group new_groups . append ( new_group ) if not group_found : searched_group = settings_manager . find_group_by_name ( target_group_name ) new_groups . append ( searched_group ) priority_layer [ \"groups\" ] = new_groups settings_manager . save_priority_layer ( priority_layer ) cancel_processing_task cancel_processing_task () Cancels the current processing task. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1817 1818 1819 1820 1821 1822 1823 1824 1825 1826 1827 1828 1829 1830 1831 1832 1833 def cancel_processing_task ( self ): \"\"\"Cancels the current processing task.\"\"\" self . processing_cancelled = True # Analysis processing tasks try : if self . task : self . task . cancel () except Exception as e : log ( f \"Problem cancelling task, { e } \" ) # Report generating task try : if self . reporting_feedback : self . reporting_feedback . cancel () except Exception as e : log ( f \"Problem cancelling report generating task, { e } \" ) edit_priority_layer edit_priority_layer () Edits the current selected priority layer and updates the layer box list. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 def edit_priority_layer ( self ): \"\"\"Edits the current selected priority layer and updates the layer box list.\"\"\" if self . priority_layers_list . currentItem () is None : self . show_message ( tr ( \"Select first the priority weighting layer from the layers list.\" ), Qgis . Critical , ) return current_text = self . priority_layers_list . currentItem () . data ( QtCore . Qt . DisplayRole ) if current_text == \"\" : self . show_message ( tr ( \"Could not fetch the selected priority layer for editing.\" ), Qgis . Critical , ) return layer = settings_manager . find_layer_by_name ( current_text ) layer_dialog = PriorityLayerDialog ( layer ) layer_dialog . exec_ () group_value_changed group_value_changed ( group_name , group_value ) Slot to handle priority group widget changes. Parameters: Name Type Description Default group_name str Group name required group_value int Group value required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 def group_value_changed ( self , group_name , group_value ): \"\"\"Slot to handle priority group widget changes. :param group_name: Group name :type group_name: str :param group_value: Group value :type group_value: int \"\"\" group = settings_manager . find_group_by_name ( group_name ) group [ \"value\" ] = group_value settings_manager . save_priority_group ( group ) for index in range ( self . priority_groups_list . topLevelItemCount ()): item = self . priority_groups_list . topLevelItem ( index ) for child_index in range ( item . childCount ()): child = item . child ( child_index ) layer = settings_manager . find_layer_by_name ( child . text ( 0 )) new_groups = [] for group in layer . get ( \"groups\" ): if group . get ( \"name\" ) == group_name : group [ \"value\" ] = group_value new_groups . append ( group ) layer [ \"groups\" ] = new_groups settings_manager . save_priority_layer ( layer ) initialize_priority_layers initialize_priority_layers () Prepares the priority weighted layers UI with the defaults. Gets the store priority layers from plugin settings and populates them into the QListWidget as QListWidgetItems then fetches the priority groups and adds them to the QTreeWidget as QTreeWidgetItems with their corresponding priority layers as their child items. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 def initialize_priority_layers ( self ): \"\"\"Prepares the priority weighted layers UI with the defaults. Gets the store priority layers from plugin settings and populates them into the QListWidget as QListWidgetItems then fetches the priority groups and adds them to the QTreeWidget as QTreeWidgetItems with their corresponding priority layers as their child items. \"\"\" self . priority_layers_list . clear () for layer in settings_manager . get_priority_layers (): item = QtWidgets . QListWidgetItem () item . setData ( QtCore . Qt . DisplayRole , layer . get ( \"name\" )) item . setData ( QtCore . Qt . UserRole , layer . get ( \"uuid\" )) self . priority_layers_list . addItem ( item ) list_items = [] items_only = [] stored_priority_groups = settings_manager . get_priority_groups () self . priority_groups_list . clear () for group in stored_priority_groups : group_widget = PriorityGroupWidget ( group , ) group_widget . input_value_changed . connect ( self . group_value_changed ) group_widget . slider_value_changed . connect ( self . group_value_changed ) self . priority_groups_widgets [ group [ \"name\" ]] = group_widget pw_layers = settings_manager . find_layers_by_group ( group [ \"name\" ]) item = QtWidgets . QTreeWidgetItem () item . setSizeHint ( 0 , group_widget . sizeHint ()) item . setExpanded ( True ) # Add priority layers into the group as a child items. item . setExpanded ( True ) if len ( pw_layers ) > 0 else None for layer in pw_layers : if item . parent () is None : layer_item = QtWidgets . QTreeWidgetItem ( item ) layer_item . setText ( 0 , layer . get ( \"name\" )) list_items . append (( item , group_widget )) items_only . append ( item ) self . priority_groups_list . addTopLevelItems ( items_only ) for item in list_items : self . priority_groups_list . setItemWidget ( item [ 0 ], 0 , item [ 1 ]) main_task main_task () Serves as a QgsTask function for the main task that contains smaller sub-tasks running the actual processing calculations. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 872 873 874 875 876 877 def main_task ( self ): \"\"\"Serves as a QgsTask function for the main task that contains smaller sub-tasks running the actual processing calculations. \"\"\" log ( \"Running from main task.\" ) model_analysis_done model_analysis_done ( model_index , model , models , extent , priority_layers_groups , success , output ) Slot that handles post calculations for the models layers Parameters: Name Type Description Default model_index int List index of the target model required model ImplementationModel Target implementation model required priority_layers_groups dict Used priority layers groups and their values required success bool Whether the scenario analysis was successful required output dict Analysis output results required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 def model_analysis_done ( self , model_index , model , models , extent , priority_layers_groups , success , output , ): \"\"\"Slot that handles post calculations for the models layers :param model_index: List index of the target model :type model_index: int :param model: Target implementation model :type model: ImplementationModel :param model: List of the selected implementation models :type model: typing.List[ImplementationModel] :param priority_layers_groups: Used priority layers groups and their values :type priority_layers_groups: dict :param success: Whether the scenario analysis was successful :type success: bool :param output: Analysis output results :type output: dict \"\"\" if output is not None and output . get ( \"OUTPUT\" ) is not None : model . path = output . get ( \"OUTPUT\" ) if model_index == len ( models ) - 1 : self . run_normalization_analysis ( models , priority_layers_groups , extent ) move_layer_to_group move_layer_to_group ( layer , group ) Moves a layer open in QGIS to another group. Parameters: Name Type Description Default layer QgsRasterLayer Raster layer to move required group QgsLayerTreeGroup Group to which the raster should be moved required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1856 1857 1858 1859 1860 1861 1862 1863 1864 1865 1866 1867 1868 1869 1870 1871 def move_layer_to_group ( self , layer , group ) -> None : \"\"\"Moves a layer open in QGIS to another group. :param layer: Raster layer to move :type layer: QgsRasterLayer :param group: Group to which the raster should be moved :type group: QgsLayerTreeGroup \"\"\" if layer : instance_root = QgsProject . instance () . layerTreeRoot () layer = instance_root . findLayer ( layer . id ()) layer_clone = layer . clone () parent = layer . parent () group . insertChildNode ( 0 , layer_clone ) # Add to top of group parent . removeChildNode ( layer ) normalization_analysis_done normalization_analysis_done ( model_index , model , models , extent , priority_layers_groups , success , output ) Slot that handles normalized models layers. Parameters: Name Type Description Default model_index int List index of the target model required model ImplementationModel Target implementation model required models List of the selected implementation models required success bool Whether the scenario analysis was successful required output dict Analysis output results required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 def normalization_analysis_done ( self , model_index , model , models , extent , priority_layers_groups , success , output , ): \"\"\"Slot that handles normalized models layers. :param model_index: List index of the target model :type model_index: int :param model: Target implementation model :type model: ImplementationModel :param models: List of the selected implementation models :type modesls: typing.List[ImplementationModel] :param success: Whether the scenario analysis was successful :type success: bool :param output: Analysis output results :type output: dict \"\"\" if output is not None and output . get ( \"OUTPUT\" ) is not None : model . path = output . get ( \"OUTPUT\" ) if model_index == len ( models ) - 1 : self . run_priority_analysis ( models , priority_layers_groups , extent ) on_report_finished on_report_finished ( scenario_id ) Slot raised when report task has finished. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2199 2200 2201 2202 2203 2204 2205 2206 2207 def on_report_finished ( self , scenario_id : str ): \"\"\"Slot raised when report task has finished.\"\"\" if not self . report_job_is_for_current_scenario ( scenario_id ): return self . progress_dialog . set_report_complete () self . progress_dialog . change_status_message ( tr ( \"Report generation complete\" ), tr ( \"scenario\" ) ) on_report_running on_report_running ( scenario_id ) Slot raised when report task has started. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2168 2169 2170 2171 2172 2173 2174 2175 2176 2177 def on_report_running ( self , scenario_id : str ): \"\"\"Slot raised when report task has started.\"\"\" if not self . report_job_is_for_current_scenario ( scenario_id ): return self . progress_dialog . update_progress_bar ( 0 ) self . progress_dialog . report_running = True self . progress_dialog . change_status_message ( tr ( \"Generating report\" ), tr ( \"scenario\" ) ) on_reporting_progress_changed on_reporting_progress_changed ( progress ) Slot raised when the reporting progress has changed. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2195 2196 2197 def on_reporting_progress_changed ( self , progress : float ): \"\"\"Slot raised when the reporting progress has changed.\"\"\" self . progress_dialog . update_progress_bar ( progress ) on_tab_step_changed on_tab_step_changed ( index ) Slot raised when the current tab changes. Parameters: Name Type Description Default index int Zero-based index position of new current tab required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2119 2120 2121 2122 2123 2124 2125 2126 2127 2128 2129 2130 2131 2132 2133 2134 2135 2136 2137 2138 def on_tab_step_changed ( self , index : int ): \"\"\"Slot raised when the current tab changes. :param index: Zero-based index position of new current tab :type index: int \"\"\" if index == 1 : self . implementation_model_widget . load () elif index == 2 : # Validate NCS pathway - implementation model mapping valid = self . implementation_model_widget . is_valid () if not valid : msg = self . tr ( \"Define one or more NCS pathways/map layers for at least one implementation model.\" ) self . show_message ( msg ) self . tab_widget . setCurrentIndex ( 1 ) else : self . message_bar . clearWidgets () open_help open_help () Opens the user documentation for the plugin in a browser Source code in src/cplus_plugin/gui/qgis_cplus_main.py 502 503 504 def open_help ( self ): \"\"\"Opens the user documentation for the plugin in a browser\"\"\" open_documentation ( USER_DOCUMENTATION_SITE ) open_settings open_settings () Options the CPLUS settings in the QGIS options dialog. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2140 2141 2142 def open_settings ( self ): \"\"\"Options the CPLUS settings in the QGIS options dialog.\"\"\" self . iface . showOptionsDialog ( currentPage = OPTIONS_TITLE ) pathways_analysis_done pathways_analysis_done ( pathway_count , models , extent , priority_layers_groups , pathways , pathway , last_pathway , success , output ) Slot that handles post calculations for the models pathways and carbon layers. Parameters: Name Type Description Default model_index int List index of the target model required pathway NCSPathway Target pathway required models typing.List[ImplementationModel] List of the selected implementation models required priority_layers_groups dict Used priority layers groups and their values required last_pathway bool Whether the pathway is the last from the models pathway list required success bool Whether the scenario analysis was successful required output dict Analysis output results required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 def pathways_analysis_done ( self , pathway_count , models , extent , priority_layers_groups , pathways , pathway , last_pathway , success , output , ): \"\"\"Slot that handles post calculations for the models pathways and carbon layers. :param model_index: List index of the target model :type model_index: int :param pathway: Target pathway :type pathway: NCSPathway :param models: List of the selected implementation models :type models: typing.List[ImplementationModel] :param priority_layers_groups: Used priority layers groups and their values :type priority_layers_groups: dict :param last_pathway: Whether the pathway is the last from the models pathway list :type last_pathway: bool :param success: Whether the scenario analysis was successful :type success: bool :param output: Analysis output results :type output: dict \"\"\" if output is not None and output . get ( \"OUTPUT\" ) is not None : pathway . path = output . get ( \"OUTPUT\" ) if ( pathway_count == len ( pathways ) - 1 ) and last_pathway : self . run_pathways_normalization ( models , priority_layers_groups , extent ) pathways_normalization_done pathways_normalization_done ( pathway_count , models , extent , priority_layers_groups , pathways , pathway , last_pathway , success , output ) Slot that handles normalized pathways layers. Parameters: Name Type Description Default model_index int List index of the target model required pathway NCSPathway Target pathway required models typing.List[ImplementationModel] List of the selected implementation models required priority_layers_groups dict Used priority layers groups and their values required last_pathway bool Whether the pathway is the last from the models pathway list required success bool Whether the scenario analysis was successful required output dict Analysis output results required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 def pathways_normalization_done ( self , pathway_count , models , extent , priority_layers_groups , pathways , pathway , last_pathway , success , output , ): \"\"\"Slot that handles normalized pathways layers. :param model_index: List index of the target model :type model_index: int :param pathway: Target pathway :type pathway: NCSPathway :param models: List of the selected implementation models :type models: typing.List[ImplementationModel] :param priority_layers_groups: Used priority layers groups and their values :type priority_layers_groups: dict :param last_pathway: Whether the pathway is the last from the models pathway list :type last_pathway: bool :param success: Whether the scenario analysis was successful :type success: bool :param output: Analysis output results :type output: dict \"\"\" if output is not None and output . get ( \"OUTPUT\" ) is not None : pathway . path = output . get ( \"OUTPUT\" ) if ( pathway_count == len ( pathways ) - 1 ) and last_pathway : self . run_models_analysis ( models , priority_layers_groups , extent ) post_analysis post_analysis ( scenario_result ) Handles analysis outputs from the final analysis results. Adds the resulting scenario raster to the canvas with styling. Adds each of the implementation models to the canvas with styling. Adds each IMs pathways to the canvas. Parameters: Name Type Description Default scenario_result ScenarioResult ScenarioResult of output results required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1873 1874 1875 1876 1877 1878 1879 1880 1881 1882 1883 1884 1885 1886 1887 1888 1889 1890 1891 1892 1893 1894 1895 1896 1897 1898 1899 1900 1901 1902 1903 1904 1905 1906 1907 1908 1909 1910 1911 1912 1913 1914 1915 1916 1917 1918 1919 1920 1921 1922 1923 1924 1925 1926 1927 1928 1929 1930 1931 1932 1933 1934 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023 2024 2025 2026 2027 2028 def post_analysis ( self , scenario_result ): \"\"\"Handles analysis outputs from the final analysis results. Adds the resulting scenario raster to the canvas with styling. Adds each of the implementation models to the canvas with styling. Adds each IMs pathways to the canvas. :param scenario_result: ScenarioResult of output results :type scenario_result: ScenarioResult \"\"\" # If the processing were stopped, no file will be added if not self . processing_cancelled : raster = scenario_result . analysis_output [ \"OUTPUT\" ] im_weighted_dir = os . path . dirname ( raster ) + \"/weighted_ims/\" list_weighted_ims = ( os . listdir ( im_weighted_dir ) if os . path . exists ( im_weighted_dir ) else [] ) scenario_name = scenario_result . scenario . name qgis_instance = QgsProject . instance () instance_root = qgis_instance . layerTreeRoot () # Check if there are other groups for the scenario # and assign a suffix. counter = 1 group_name = scenario_name # Control to prevent infinite loop max_limit = 100 while True and counter <= max_limit : scenario_grp = instance_root . findGroup ( group_name ) if scenario_grp is None : break group_name = f \" { scenario_name } { counter !s} \" counter += 1 # Groups scenario_group = instance_root . insertGroup ( 0 , group_name ) im_group = scenario_group . addGroup ( tr ( IM_GROUP_LAYER_NAME )) im_weighted_group = ( scenario_group . addGroup ( tr ( IM_WEIGHTED_GROUP_NAME )) if os . path . exists ( im_weighted_dir ) else None ) pathways_group = scenario_group . addGroup ( tr ( NCS_PATHWAYS_GROUP_LAYER_NAME )) # Group settings im_group . setExpanded ( False ) im_weighted_group . setExpanded ( False ) if im_weighted_group else None pathways_group . setExpanded ( False ) pathways_group . setItemVisibilityCheckedRecursive ( False ) # Add scenario result layer to the canvas with styling layer_file = scenario_result . analysis_output . get ( \"OUTPUT\" ) layer_name = ( f \" { SCENARIO_OUTPUT_LAYER_NAME } _\" f ' { datetime . datetime . now () . strftime ( \"%Y_%m_ %d _%H_%M_%S\" ) } ' ) scenario_result . output_layer_name = layer_name layer = QgsRasterLayer ( layer_file , layer_name , QGIS_GDAL_PROVIDER ) layer . loadNamedStyle ( LAYER_STYLES [ \"scenario_result\" ]) scenario_layer = qgis_instance . addMapLayer ( layer ) \"\"\"A workaround to add a layer to a group. Adding it using group.insertChildNode or group.addLayer causes issues, but adding to the root is fine. This approach adds it to the root, and then moves it to the group. \"\"\" self . move_layer_to_group ( scenario_layer , scenario_group ) coefficient = settings_manager . get_value ( Settings . CARBON_COEFFICIENT , default = 0.0 ) # Add implementation models and pathways list_models = scenario_result . scenario . models im_index = 0 for im in list_models : im_name = im . name im_layer = QgsRasterLayer ( im . path , im . name ) list_pathways = im . pathways # Add IM layer with styling, if available if im_layer : if float ( coefficient ) > 0 : # Style with range 0 to 2 style_to_use = LAYER_STYLES [ \"carbon\" ][ im_name ] else : # Style with range 0 to 1 style_to_use = LAYER_STYLES [ \"normal\" ][ im_name ] im_layer . loadNamedStyle ( style_to_use ) added_im_layer = qgis_instance . addMapLayer ( im_layer ) self . move_layer_to_group ( added_im_layer , im_group ) # Add IM pathways if len ( list_pathways ) > 0 : # im_pathway_group = pathways_group.addGroup(im_name) im_pathway_group = pathways_group . insertGroup ( im_index , im_name ) im_pathway_group . setExpanded ( False ) pw_index = 0 for pathway in list_pathways : try : # pathway_name = pathway.name pathway_layer = pathway . to_map_layer () added_pw_layer = qgis_instance . addMapLayer ( pathway_layer ) self . move_layer_to_group ( added_pw_layer , im_pathway_group ) pw_index = pw_index + 1 except Exception as err : self . show_message ( tr ( \"An error occurred loading a pathway, \" \"check logs for more information\" ), level = Qgis . Info , ) log ( tr ( \"An error occurred loading a pathway, \" 'scenario analysis, error message \" {} \"' . format ( err ) ) ) im_index = im_index + 1 for weighted_im in list_weighted_ims : if not weighted_im . endswith ( \".tif\" ): continue weighted_im_name = weighted_im [: len ( weighted_im ) - 9 ] if float ( coefficient ) > 0 : # Style with range 0 to 2 style_to_use = LAYER_STYLES_WEIGHTED [ \"carbon\" ][ weighted_im_name ] else : # Style with range 0 to 1 style_to_use = LAYER_STYLES_WEIGHTED [ \"normal\" ][ weighted_im_name ] im_weighted_layer = QgsRasterLayer ( im_weighted_dir + weighted_im , weighted_im_name , QGIS_GDAL_PROVIDER ) im_weighted_layer . loadNamedStyle ( style_to_use ) added_im_weighted_layer = qgis_instance . addMapLayer ( im_weighted_layer ) self . move_layer_to_group ( added_im_weighted_layer , im_weighted_group ) # Initiate report generation self . run_report () else : # Reinitializes variables if processing were cancelled by the user # Not doing this breaks the processing if a user tries to run # the processing after cancelling or if the processing fails self . position_feedback = QgsProcessingFeedback () self . processing_context = QgsProcessingContext () prepare_extent_box prepare_extent_box () Configure the spatial extent box with the initial settings. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2097 2098 2099 2100 2101 2102 2103 2104 2105 2106 2107 2108 2109 2110 2111 2112 2113 2114 2115 2116 2117 def prepare_extent_box ( self ): \"\"\"Configure the spatial extent box with the initial settings.\"\"\" self . extent_box . setOutputCrs ( QgsCoordinateReferenceSystem ( \"EPSG:4326\" )) map_canvas = iface . mapCanvas () self . extent_box . setCurrentExtent ( map_canvas . mapSettings () . destinationCrs () . bounds (), map_canvas . mapSettings () . destinationCrs (), ) self . extent_box . setOutputExtentFromCurrent () self . extent_box . setMapCanvas ( map_canvas ) extent_list = PILOT_AREA_EXTENT [ \"coordinates\" ] default_extent = QgsRectangle ( extent_list [ 0 ], extent_list [ 2 ], extent_list [ 1 ], extent_list [ 3 ] ) self . extent_box . setOutputExtentFromUser ( default_extent , QgsCoordinateReferenceSystem ( \"EPSG:4326\" ), ) prepare_input prepare_input () Initializes plugin input widgets Source code in src/cplus_plugin/gui/qgis_cplus_main.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 def prepare_input ( self ): \"\"\"Initializes plugin input widgets\"\"\" self . prepare_extent_box () self . grid_layout = QtWidgets . QGridLayout () self . message_bar = QgsMessageBar () self . prepare_message_bar () self . progress_dialog = None self . scenario_directory = None self . help_btn . clicked . connect ( self . open_help ) self . pilot_area_btn . clicked . connect ( self . zoom_pilot_area ) self . run_scenario_btn . clicked . connect ( self . run_analysis ) self . options_btn . clicked . connect ( self . open_settings ) self . restore_scenario () self . scenario_name . textChanged . connect ( self . save_scenario ) self . scenario_description . textChanged . connect ( self . save_scenario ) self . extent_box . extentChanged . connect ( self . save_scenario ) icon_pixmap = QtGui . QPixmap ( ICON_PATH ) self . icon_la . setPixmap ( icon_pixmap ) add_layer_icon = QtGui . QIcon ( ADD_LAYER_ICON_PATH ) self . layer_add_btn . setIcon ( add_layer_icon ) remove_layer_icon = QtGui . QIcon ( REMOVE_LAYER_ICON_PATH ) self . layer_remove_btn . setIcon ( remove_layer_icon ) self . layer_add_btn . clicked . connect ( self . add_priority_layer_group ) self . layer_remove_btn . clicked . connect ( self . remove_priority_layer_group ) # Priority layers buttons self . add_pwl_btn . setIcon ( FileUtils . get_icon ( \"symbologyAdd.svg\" )) self . edit_pwl_btn . setIcon ( FileUtils . get_icon ( \"mActionToggleEditing.svg\" )) self . remove_pwl_btn . setIcon ( FileUtils . get_icon ( \"symbologyRemove.svg\" )) self . add_pwl_btn . clicked . connect ( self . add_priority_layer ) self . edit_pwl_btn . clicked . connect ( self . edit_priority_layer ) self . remove_pwl_btn . clicked . connect ( self . remove_priority_layer ) # Add priority groups list into the groups frame self . priority_groups_list = CustomTreeWidget () self . priority_groups_list . setHeaderHidden ( True ) self . priority_groups_list . setDragEnabled ( True ) self . priority_groups_list . setDragDropOverwriteMode ( True ) self . priority_groups_list . viewport () . setAcceptDrops ( True ) self . priority_groups_list . setDragDropMode ( QtWidgets . QAbstractItemView . DropOnly ) self . priority_groups_list . child_dragged_dropped . connect ( self . priority_groups_update ) layout = QtWidgets . QVBoxLayout () layout . setSpacing ( 0 ) layout . setContentsMargins ( 0 , 0 , 0 , 0 ) layout . addWidget ( self . priority_groups_list ) self . priority_groups_frame . setLayout ( layout ) # Scenario analysis variables self . analysis_scenario_name = None self . analysis_scenario_description = None self . analysis_extent = None self . analysis_implementation_models = None self . analysis_priority_layers_groups = [] prepare_message_bar prepare_message_bar () Initializes the widget message bar settings Source code in src/cplus_plugin/gui/qgis_cplus_main.py 567 568 569 570 571 572 573 574 575 def prepare_message_bar ( self ): \"\"\"Initializes the widget message bar settings\"\"\" self . message_bar . setSizePolicy ( QtWidgets . QSizePolicy . Minimum , QtWidgets . QSizePolicy . Fixed ) self . grid_layout . addWidget ( self . message_bar , 0 , 0 , 1 , 1 , alignment = QtCore . Qt . AlignTop ) self . dock_widget_contents . layout () . insertLayout ( 0 , self . grid_layout ) priority_groups_update priority_groups_update ( target_item , selected_items ) Updates the priority groups list item with the passed selected layer items. Parameters: Name Type Description Default target_item QTreeWidgetItem The priority group tree widget item that is to be updated required selected_items list Priority layers items from the list widget required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def priority_groups_update ( self , target_item , selected_items ): \"\"\"Updates the priority groups list item with the passed selected layer items. :param target_item: The priority group tree widget item that is to be updated :type target_item: QTreeWidgetItem :param selected_items: Priority layers items from the list widget :type selected_items: list \"\"\" self . priority_groups_list . setCurrentItem ( target_item ) for item in selected_items : self . add_priority_layer_group ( target_item , item ) priority_layers_analysis_done priority_layers_analysis_done ( model_index , model , models , success , output ) Slot that handles post calculations for the models priority layers Parameters: Name Type Description Default model_index int List index of the target model required model ImplementationModel Target implementation model required models typing.List[ImplementationModel] List of the selected implementation models required success bool Whether the scenario analysis was successful required output dict Analysis output results required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1791 1792 1793 1794 1795 1796 1797 1798 1799 1800 1801 1802 1803 1804 1805 1806 1807 1808 1809 1810 1811 1812 1813 1814 1815 def priority_layers_analysis_done ( self , model_index , model , models , success , output ): \"\"\"Slot that handles post calculations for the models priority layers :param model_index: List index of the target model :type model_index: int :param model: Target implementation model :type model: ImplementationModel :param models: List of the selected implementation models :type models: typing.List[ImplementationModel] :param success: Whether the scenario analysis was successful :type success: bool :param output: Analysis output results :type output: dict \"\"\" if output is not None and output . get ( \"OUTPUT\" ) is not None : model . path = output . get ( \"OUTPUT\" ) if model_index == len ( models ) - 1 : self . run_highest_position_analysis () remove_priority_layer remove_priority_layer () Removes the current active priority layer. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 def remove_priority_layer ( self ): \"\"\"Removes the current active priority layer.\"\"\" if self . priority_layers_list . currentItem () is None : self . show_message ( tr ( \"Select first the priority \" \"weighting layer from the layers list.\" ), Qgis . Critical , ) return current_text = self . priority_layers_list . currentItem () . data ( QtCore . Qt . DisplayRole ) if current_text == \"\" : self . show_message ( tr ( \"Could not fetch the selected priority layer for editing.\" ), Qgis . Critical , ) return layer = settings_manager . find_layer_by_name ( current_text ) reply = QtWidgets . QMessageBox . warning ( self , tr ( \"QGIS CPLUS PLUGIN\" ), tr ( 'Remove the priority layer \" {} \"?' ) . format ( current_text ), QtWidgets . QMessageBox . Yes , QtWidgets . QMessageBox . No , ) if reply == QtWidgets . QMessageBox . Yes : settings_manager . delete_priority_layer ( layer . get ( \"uuid\" )) self . update_priority_layers ( update_groups = False ) remove_priority_layer_group remove_priority_layer_group () Remove the current select priority layer from the current priority group. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 def remove_priority_layer_group ( self ): \"\"\"Remove the current select priority layer from the current priority group.\"\"\" selected_group = self . priority_groups_list . currentItem () parent_item = selected_group . parent () if selected_group is not None else None if parent_item : priority_layer = settings_manager . find_layer_by_name ( selected_group . text ( 0 )) group_widget = self . priority_groups_list . itemWidget ( parent_item , 0 ) groups = priority_layer . get ( \"groups\" ) new_groups = [] for group in groups : if group . get ( \"name\" ) == group_widget . group . get ( \"name\" ): continue new_groups . append ( group ) priority_layer [ \"groups\" ] = new_groups settings_manager . save_priority_layer ( priority_layer ) parent_item . removeChild ( selected_group ) report_job_is_for_current_scenario report_job_is_for_current_scenario ( scenario_id ) Checks if the given scenario identifier is for the current scenario result. This is to ensure that signals raised by the report manager refer to the current scenario result object and not for old jobs. Parameters: Name Type Description Default scenario_id str Scenario identifier usually from a signal raised by the report manager. required Returns: Type Description bool True if the scenario identifier matches the current scenario object in the results, else False. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2209 2210 2211 2212 2213 2214 2215 2216 2217 2218 2219 2220 2221 2222 2223 2224 2225 2226 2227 2228 2229 2230 2231 2232 2233 2234 def report_job_is_for_current_scenario ( self , scenario_id : str ) -> bool : \"\"\"Checks if the given scenario identifier is for the current scenario result. This is to ensure that signals raised by the report manager refer to the current scenario result object and not for old jobs. :param scenario_id: Scenario identifier usually from a signal raised by the report manager. :type scenario_id: str :returns: True if the scenario identifier matches the current scenario object in the results, else False. :rtype: bool \"\"\" if self . scenario_result is None : return False current_scenario = self . scenario_result . scenario if current_scenario is None : return False if str ( current_scenario . uuid ) == scenario_id : return True return False reset_reporting_feedback reset_reporting_feedback () Creates a new reporting feedback object and reconnects the signals. We are doing this to address cases where the feedback is canceled and the same object has to be reused for subsequent report generation tasks. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2179 2180 2181 2182 2183 2184 2185 2186 2187 2188 2189 2190 2191 2192 2193 def reset_reporting_feedback ( self ): \"\"\"Creates a new reporting feedback object and reconnects the signals. We are doing this to address cases where the feedback is canceled and the same object has to be reused for subsequent report generation tasks. \"\"\" if self . reporting_feedback is not None : self . reporting_feedback . progressChanged . disconnect () self . reporting_feedback = QgsFeedback ( self ) self . reporting_feedback . progressChanged . connect ( self . on_reporting_progress_changed ) restore_scenario restore_scenario () Update the first tab input with the last scenario details Source code in src/cplus_plugin/gui/qgis_cplus_main.py 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 def restore_scenario ( self ): \"\"\"Update the first tab input with the last scenario details\"\"\" scenario_name = settings_manager . get_value ( Settings . SCENARIO_NAME ) scenario_description = settings_manager . get_value ( Settings . SCENARIO_DESCRIPTION ) extent = settings_manager . get_value ( Settings . SCENARIO_EXTENT ) self . scenario_name . setText ( scenario_name ) if scenario_name is not None else None self . scenario_description . setText ( scenario_description ) if scenario_description is not None else None if extent is not None : extent_rectangle = QgsRectangle ( float ( extent [ 0 ]), float ( extent [ 2 ]), float ( extent [ 1 ]), float ( extent [ 3 ]) ) self . extent_box . setOutputExtentFromUser ( extent_rectangle , QgsCoordinateReferenceSystem ( \"EPSG:4326\" ), ) run_analysis run_analysis () Runs the plugin analysis Source code in src/cplus_plugin/gui/qgis_cplus_main.py 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 def run_analysis ( self ): \"\"\"Runs the plugin analysis\"\"\" extent_list = PILOT_AREA_EXTENT [ \"coordinates\" ] default_extent = QgsRectangle ( extent_list [ 0 ], extent_list [ 2 ], extent_list [ 1 ], extent_list [ 3 ] ) passed_extent = self . extent_box . outputExtent () contains = default_extent == passed_extent or default_extent . contains ( passed_extent ) self . analysis_scenario_name = self . scenario_name . text () self . analysis_scenario_description = self . scenario_description . text () self . position_feedback = QgsProcessingFeedback () self . processing_context = QgsProcessingContext () for group in settings_manager . get_priority_groups (): group_layer_dict = { \"name\" : group . get ( \"name\" ), \"value\" : group . get ( \"value\" ), \"layers\" : [], } for layer in settings_manager . get_priority_layers (): group_names = [ group . get ( \"name\" ) for group in layer . get ( \"groups\" , [])] if group . get ( \"name\" ) in group_names : group_layer_dict [ \"layers\" ] . append ( layer . get ( \"name\" )) self . analysis_priority_layers_groups . append ( group_layer_dict ) self . analysis_implementation_models = [ item . implementation_model for item in self . implementation_model_widget . selected_im_items () ] base_dir = settings_manager . get_value ( Settings . BASE_DIR ) if self . analysis_scenario_name == \"\" or self . analysis_scenario_name is None : self . show_message ( tr ( f \"Scenario name cannot be blank.\" ), level = Qgis . Critical , ) return if ( self . analysis_scenario_description == \"\" or self . analysis_scenario_description is None ): self . show_message ( tr ( f \"Scenario description cannot be blank.\" ), level = Qgis . Critical , ) return if ( self . analysis_implementation_models == [] or self . analysis_implementation_models is None ): self . show_message ( tr ( \"Select at least one implementation models from step two.\" ), level = Qgis . Critical , ) return if not contains : self . show_message ( tr ( f \"Selected area of interest is outside the pilot area.\" ), level = Qgis . Critical , ) default_ext = ( f \" { default_extent . xMinimum () } , { default_extent . xMaximum () } ,\" f \" { default_extent . yMinimum () } , { default_extent . yMaximum () } \" ) log ( f \"Outside the pilot area, passed extent \" f \" { passed_extent } \" f \"default extent { default_ext } \" ) return if base_dir is None : self . show_message ( tr ( f \"Plugin base data directory is not set! \" f \"Go to plugin settings in order to set it.\" ), level = Qgis . Critial , ) return self . analysis_extent = SpatialExtent ( bbox = [ passed_extent . xMinimum (), passed_extent . xMaximum (), passed_extent . yMinimum (), passed_extent . yMaximum (), ] ) try : self . scenario_directory = ( f \" { base_dir } /\" f 'scenario_ { datetime . datetime . now () . strftime ( \"%Y_%m_ %d _%H_%M_%S\" ) } ' ) FileUtils . create_new_dir ( self . scenario_directory ) # Creates and opens the progress dialog for the analysis self . progress_dialog = ProgressDialog ( \"Raster calculation\" , \"implementation models\" , 0 , 100 , main_widget = self , ) self . progress_dialog . run_dialog () self . progress_dialog . scenario_name = \"\" self . progress_dialog . change_status_message ( tr ( \"Raster calculation\" ), tr ( \"models\" ) ) except Exception as err : self . show_message ( tr ( \"An error occurred when opening the progress dialog, \" \"check logs for more information\" ), level = Qgis . Info , ) log ( tr ( \"An error occurred when opening the progress dialog for \" 'scenario analysis, error message \" {} \"' . format ( err ) ) ) self . processing_cancelled = False self . run_pathways_analysis ( self . analysis_implementation_models , self . analysis_priority_layers_groups , self . analysis_extent , ) run_highest_position_analysis run_highest_position_analysis () Runs the highest position analysis which is last step in scenario analysis. Uses the models set by the current ongoing analysis. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 def run_highest_position_analysis ( self ): \"\"\"Runs the highest position analysis which is last step in scenario analysis. Uses the models set by the current ongoing analysis. \"\"\" if self . processing_cancelled : # Will not proceed if processing has been cancelled by the user return passed_extent_box = self . analysis_extent . bbox passed_extent = QgsRectangle ( passed_extent_box [ 0 ], passed_extent_box [ 2 ], passed_extent_box [ 1 ], passed_extent_box [ 3 ], ) scenario = Scenario ( uuid = uuid . uuid4 (), name = self . analysis_scenario_name , description = self . analysis_scenario_description , extent = self . analysis_extent , models = self . analysis_implementation_models , priority_layer_groups = self . analysis_priority_layers_groups , ) self . scenario_result = ScenarioResult ( scenario = scenario , ) try : layers = {} self . progress_dialog . progress_bar . setMinimum ( 0 ) self . progress_dialog . progress_bar . setMaximum ( 100 ) self . progress_dialog . progress_bar . setValue ( 0 ) self . progress_dialog . analysis_finished_message = tr ( \"Analysis finished\" ) self . progress_dialog . scenario_name = tr ( f \"<b> { scenario . name } </b>\" ) self . progress_dialog . scenario_id = str ( scenario . uuid ) self . progress_dialog . change_status_message ( tr ( \"Calculating the highest position\" ) ) self . position_feedback . progressChanged . connect ( self . update_progress_bar ) for model in self . analysis_implementation_models : if model . path is not None and model . path is not \"\" : raster_layer = QgsRasterLayer ( model . path , model . name ) layers [ model . name ] = ( raster_layer if raster_layer is not None else None ) else : for pathway in model . pathways : layers [ model . name ] = QgsRasterLayer ( pathway . path ) source_crs = QgsCoordinateReferenceSystem ( \"EPSG:4326\" ) dest_crs = list ( layers . values ())[ 0 ] . crs () if len ( layers ) > 0 else source_crs transform = QgsCoordinateTransform ( source_crs , dest_crs , QgsProject . instance () ) transformed_extent = transform . transformBoundingBox ( passed_extent ) extent_string = ( f \" { transformed_extent . xMinimum () } , { transformed_extent . xMaximum () } ,\" f \" { transformed_extent . yMinimum () } , { transformed_extent . yMaximum () } \" f \" [ { dest_crs . authid () } ]\" ) output_file = ( f \" { self . scenario_directory } /\" f \" { SCENARIO_OUTPUT_FILE_NAME } _ { str ( scenario . uuid )[: 4 ] } .tif\" ) # Preparing the input rasters for the highest position # analysis in a correct order models_names = [ model . name for model in self . analysis_implementation_models ] all_models_names = [ model . name for model in self . implementation_model_widget . implementation_models () ] sources = [] absolute_path = f \" { FileUtils . plugin_dir () } /app_data/layers/null_raster.tif\" null_raster_file = os . path . normpath ( absolute_path ) for model_name in all_models_names : if model_name in models_names : sources . append ( layers [ model_name ] . source ()) else : sources . append ( null_raster_file ) log ( f \"Layers sources { [ Path ( source ) . stem for source in sources ] } \" ) alg_params = { \"IGNORE_NODATA\" : True , \"INPUT_RASTERS\" : sources , \"EXTENT\" : extent_string , \"OUTPUT_NODATA_VALUE\" : - 9999 , \"REFERENCE_LAYER\" : list ( layers . values ())[ 0 ] if len ( layers ) >= 1 else None , \"OUTPUT\" : output_file , } log ( f \"Used parameters for highest position analysis { alg_params } \" ) alg = QgsApplication . processingRegistry () . algorithmById ( \"native:highestpositioninrasterstack\" ) # self.processing_cancelled = False self . task = QgsProcessingAlgRunnerTask ( alg , alg_params , self . processing_context , feedback = self . position_feedback , ) self . task . executed . connect ( self . scenario_results ) QgsApplication . taskManager () . addTask ( self . task ) except Exception as err : self . show_message ( tr ( \"An error occurred when running analysis task, \" \"check logs for more information\" ), level = Qgis . Info , ) log ( tr ( \"An error occurred when running task for \" 'scenario analysis, error message \" {} \"' . format ( str ( err )) ) ) run_models_analysis run_models_analysis ( models , priority_layers_groups , extent ) Runs the required model analysis on the passed implementation models. Parameters: Name Type Description Default models typing.List[ImplementationModel] List of the selected implementation models required priority_layers_groups dict Used priority layers groups and their values required extent SpatialExtent selected extent from user required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 def run_models_analysis ( self , models , priority_layers_groups , extent ): \"\"\"Runs the required model analysis on the passed implementation models. :param models: List of the selected implementation models :type models: typing.List[ImplementationModel] :param priority_layers_groups: Used priority layers groups and their values :type priority_layers_groups: dict :param extent: selected extent from user :type extent: SpatialExtent \"\"\" if self . processing_cancelled : # Will not proceed if processing has been cancelled by the user return False model_count = 0 priority_function = partial ( self . run_normalization_analysis , models , priority_layers_groups , extent ) main_task = QgsTask . fromFunction ( \"Running main functions\" , self . main_task , on_finished = priority_function ) previous_sub_tasks = [] self . progress_dialog . analysis_finished_message = tr ( \"Processing calculations\" ) self . progress_dialog . scenario_name = tr ( \"implementation models\" ) for model in models : new_ims_directory = f \" { self . scenario_directory } /implementation_models\" FileUtils . create_new_dir ( new_ims_directory ) file_name = clean_filename ( model . name . replace ( \" \" , \"_\" )) layers = [] if not model . pathways and ( model . path is None and model . path is \"\" ): self . show_message ( tr ( f \"No defined model pathways or a\" f \" model layer for the model { model . name } \" ), level = Qgis . Critical , ) log ( f \"No defined model pathways or a \" f \"model layer for the model { model . name } \" ) main_task . cancel () return False output_file = f \" { new_ims_directory } / { file_name } _ { str ( uuid . uuid4 ())[: 4 ] } .tif\" # Due to the implementation models base class # model only one of the following blocks will be executed, # the implementation model either contain a path or # pathways if model . path is not None and model . path is not \"\" : layers = [ model . path ] for pathway in model . pathways : layers . append ( pathway . path ) analysis_done = partial ( self . model_analysis_done , model_count , model , models , extent , priority_layers_groups , ) # Actual processing calculation alg_params = { \"IGNORE_NODATA\" : True , \"INPUT\" : layers , \"EXTENT\" : extent , \"OUTPUT_NODATA_VALUE\" : - 9999 , \"REFERENCE_LAYER\" : layers [ 0 ] if len ( layers ) > 0 else None , \"STATISTIC\" : 0 , # Sum \"OUTPUT\" : output_file , } log ( f \"Used parameters for \" f \"implementation models generation: { alg_params } \" ) alg = QgsApplication . processingRegistry () . algorithmById ( \"native:cellstatistics\" ) self . task = QgsProcessingAlgRunnerTask ( alg , alg_params , self . processing_context , self . position_feedback ) self . position_feedback . progressChanged . connect ( self . update_progress_bar ) main_task . addSubTask ( self . task , previous_sub_tasks , QgsTask . ParentDependsOnSubTask ) previous_sub_tasks . append ( self . task ) self . task . executed . connect ( analysis_done ) model_count = model_count + 1 QgsApplication . taskManager () . addTask ( main_task ) run_normalization_analysis run_normalization_analysis ( models , priority_layers_groups , extent ) Runs the normalization analysis on the models layers, adjusting band values measured on different scale, the resulting scale is computed using the below formula Normalized_Model = (Carbon coefficient + Suitability index) * ( (Model layer value) - (Model band minimum value)) / (Model band maximum value - Model band minimum value)) If the carbon coefficient and suitability index are both zero then the computation won't take them into account in the normalization calculation. Parameters: Name Type Description Default models typing.List[ImplementationModel] List of the analyzed implementation models required priority_layers_groups dict Used priority layers groups and their values required extent str selected extent from user required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 def run_normalization_analysis ( self , models , priority_layers_groups , extent ): \"\"\"Runs the normalization analysis on the models layers, adjusting band values measured on different scale, the resulting scale is computed using the below formula Normalized_Model = (Carbon coefficient + Suitability index) * ( (Model layer value) - (Model band minimum value)) / (Model band maximum value - Model band minimum value)) If the carbon coefficient and suitability index are both zero then the computation won't take them into account in the normalization calculation. :param models: List of the analyzed implementation models :type models: typing.List[ImplementationModel] :param priority_layers_groups: Used priority layers groups and their values :type priority_layers_groups: dict :param extent: selected extent from user :type extent: str \"\"\" if self . processing_cancelled : # Will not proceed if processing has been cancelled by the user return False model_count = 0 priority_function = partial ( self . run_priority_analysis , models , priority_layers_groups , extent ) main_task = QgsTask . fromFunction ( \"Running normalization\" , self . main_task , on_finished = priority_function ) previous_sub_tasks = [] self . progress_dialog . analysis_finished_message = tr ( \"Normalization\" ) self . progress_dialog . scenario_name = tr ( \"implementation models\" ) for model in models : if model . path is None or model . path is \"\" : if not self . processing_cancelled : self . show_message ( tr ( f \"Problem when running models normalization, \" f \"there is no map layer for the model { model . name } \" ), level = Qgis . Critical , ) log ( f \"Problem when running models normalization, \" f \"there is no map layer for the model { model . name } \" ) else : # If the user cancelled the processing self . show_message ( tr ( f \"Processing has been cancelled by the user.\" ), level = Qgis . Critical , ) log ( f \"Processing has been cancelled by the user.\" ) main_task . cancel () return False basenames = [] layers = [] new_ims_directory = f \" { self . scenario_directory } /normalized_ims\" FileUtils . create_new_dir ( new_ims_directory ) file_name = clean_filename ( model . name . replace ( \" \" , \"_\" )) output_file = f \" { new_ims_directory } / { file_name } _ { str ( uuid . uuid4 ())[: 4 ] } .tif\" model_layer = QgsRasterLayer ( model . path , model . name ) provider = model_layer . dataProvider () band_statistics = provider . bandStatistics ( 1 ) min_value = band_statistics . minimumValue max_value = band_statistics . maximumValue layer_name = Path ( model . path ) . stem layers . append ( model . path ) carbon_coefficient = float ( settings_manager . get_value ( Settings . CARBON_COEFFICIENT , default = 0.0 ) ) suitability_index = float ( settings_manager . get_value ( Settings . PATHWAY_SUITABILITY_INDEX , default = 0 ) ) normalization_index = carbon_coefficient + suitability_index if normalization_index > 0 : expression = ( f \" { normalization_index } * \" f '(\" { layer_name } @1\" - { min_value } ) /' f \" ( { max_value } - { min_value } )\" ) else : expression = ( f '(\" { layer_name } @1\" - { min_value } ) /' f \" ( { max_value } - { min_value } )\" ) analysis_done = partial ( self . normalization_analysis_done , model_count , model , models , extent , priority_layers_groups , ) # Actual processing calculation alg_params = { \"CELLSIZE\" : 0 , \"CRS\" : None , \"EXPRESSION\" : expression , \"EXTENT\" : extent , \"LAYERS\" : layers , \"OUTPUT\" : output_file , } log ( f \"Used parameters for normalization of the models: { alg_params } \" ) alg = QgsApplication . processingRegistry () . algorithmById ( \"qgis:rastercalculator\" ) self . task = QgsProcessingAlgRunnerTask ( alg , alg_params , self . processing_context , self . position_feedback ) self . position_feedback . progressChanged . connect ( self . update_progress_bar ) main_task . addSubTask ( self . task , previous_sub_tasks , QgsTask . ParentDependsOnSubTask ) previous_sub_tasks . append ( self . task ) self . task . executed . connect ( analysis_done ) model_count = model_count + 1 QgsApplication . taskManager () . addTask ( main_task ) run_pathways_analysis run_pathways_analysis ( models , priority_layers_groups , extent ) Runs the required model pathways analysis on the passed implementation models. The analysis involves adding the pathways carbon layers into the pathway layer. If the pathway layer has more than one carbon layer, the resulting weighted pathway will contain the sum of the pathway layer values with the average of the pathway carbon layers values. Parameters: Name Type Description Default models typing.List[ImplementationModel] List of the selected implementation models required priority_layers_groups dict Used priority layers groups and their values required extent SpatialExtent The selected extent from user required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 def run_pathways_analysis ( self , models , priority_layers_groups , extent ): \"\"\"Runs the required model pathways analysis on the passed implementation models. The analysis involves adding the pathways carbon layers into the pathway layer. If the pathway layer has more than one carbon layer, the resulting weighted pathway will contain the sum of the pathway layer values with the average of the pathway carbon layers values. :param models: List of the selected implementation models :type models: typing.List[ImplementationModel] :param priority_layers_groups: Used priority layers groups and their values :type priority_layers_groups: dict :param extent: The selected extent from user :type extent: SpatialExtent \"\"\" if self . processing_cancelled : # Will not proceed if processing has been cancelled by the user return False models_function = partial ( self . run_pathways_normalization , models , priority_layers_groups , extent ) main_task = QgsTask . fromFunction ( \"Main task for running pathways combination with carbon layers\" , self . main_task , on_finished = models_function , ) main_task . taskCompleted . connect ( models_function ) previous_sub_tasks = [] self . progress_dialog . analysis_finished_message = tr ( \"Calculating carbon layers\" ) self . progress_dialog . scenario_name = tr ( f \"models pathways\" ) pathways = [] models_paths = [] for model in models : if not model . pathways and ( model . path is None or model . path is \"\" ): self . show_message ( tr ( f \"No defined model pathways or a\" f \" model layer for the model { model . name } \" ), level = Qgis . Critical , ) log ( f \"No defined model pathways or a \" f \"model layer for the model { model . name } \" ) main_task . cancel () return False for pathway in model . pathways : if not ( pathway in pathways ): pathways . append ( pathway ) if model . path is not None and model . path is not \"\" : models_paths . append ( model . path ) if not pathways and len ( models_paths ) > 0 : self . run_pathways_normalization ( models , priority_layers_groups , extent ) return new_carbon_directory = f \" { self . scenario_directory } /pathways_carbon_layers\" suitability_index = float ( settings_manager . get_value ( Settings . PATHWAY_SUITABILITY_INDEX , default = 0 ) ) carbon_coefficient = float ( settings_manager . get_value ( Settings . CARBON_COEFFICIENT , default = 0.0 ) ) base_dir = settings_manager . get_value ( Settings . BASE_DIR ) FileUtils . create_new_dir ( new_carbon_directory ) pathway_count = 0 for pathway in pathways : basenames = [] layers = [] path_basename = Path ( pathway . path ) . stem layers . append ( pathway . path ) file_name = clean_filename ( pathway . name . replace ( \" \" , \"_\" )) output_file = ( f \" { new_carbon_directory } / { file_name } _ { str ( uuid . uuid4 ())[: 4 ] } .tif\" ) if suitability_index > 0 : basenames . append ( f ' { suitability_index } * \" { path_basename } @1\"' ) else : basenames . append ( f '\" { path_basename } @1\"' ) carbon_names = [] for carbon_path in pathway . carbon_paths : if base_dir not in carbon_path : carbon_path = f \" { base_dir } / { NCS_CARBON_SEGMENT } / { carbon_path } \" carbon_full_path = Path ( carbon_path ) if not carbon_full_path . exists (): continue layers . append ( carbon_path ) carbon_names . append ( f '\" { carbon_full_path . stem } @1\"' ) if len ( carbon_names ) == 1 and carbon_coefficient > 0 : basenames . append ( f \" { carbon_coefficient } * ( { carbon_names [ 0 ] } )\" ) # Setting up calculation to use carbon layers average when # a pathway has more than one carbon layer. if len ( carbon_names ) > 1 and carbon_coefficient > 0 : basenames . append ( f \" { carbon_coefficient } * (\" f '( { \" + \" . join ( carbon_names ) } ) / ' f \" { len ( pathway . carbon_paths ) } )\" ) expression = \" + \" . join ( basenames ) box = QgsRectangle ( float ( extent . bbox [ 0 ]), float ( extent . bbox [ 2 ]), float ( extent . bbox [ 1 ]), float ( extent . bbox [ 3 ]), ) source_crs = QgsCoordinateReferenceSystem ( \"EPSG:4326\" ) dest_crs = QgsRasterLayer ( layers [ 0 ]) . crs () transform = QgsCoordinateTransform ( source_crs , dest_crs , QgsProject . instance () ) transformed_extent = transform . transformBoundingBox ( box ) extent_string = ( f \" { transformed_extent . xMinimum () } , { transformed_extent . xMaximum () } ,\" f \" { transformed_extent . yMinimum () } , { transformed_extent . yMaximum () } \" f \" [ { dest_crs . authid () } ]\" ) analysis_done = partial ( self . pathways_analysis_done , pathway_count , models , extent_string , priority_layers_groups , pathways , pathway , ( pathway_count == len ( pathways ) - 1 ), ) if carbon_coefficient <= 0 and suitability_index <= 0 : self . run_pathways_normalization ( models , priority_layers_groups , extent_string ) return # Actual processing calculation alg_params = { \"CELLSIZE\" : 0 , \"CRS\" : None , \"EXPRESSION\" : expression , \"EXTENT\" : extent_string , \"LAYERS\" : layers , \"OUTPUT\" : output_file , } log ( f \"Used parameters for combining pathways\" f \" and carbon layers generation: { alg_params } \" ) alg = QgsApplication . processingRegistry () . algorithmById ( \"qgis:rastercalculator\" ) self . task = QgsProcessingAlgRunnerTask ( alg , alg_params , self . processing_context , self . position_feedback ) self . position_feedback . progressChanged . connect ( self . update_progress_bar ) main_task . addSubTask ( self . task , previous_sub_tasks , QgsTask . ParentDependsOnSubTask ) previous_sub_tasks . append ( self . task ) self . task . executed . connect ( analysis_done ) pathway_count = pathway_count + 1 QgsApplication . taskManager () . addTask ( main_task ) run_pathways_normalization run_pathways_normalization ( models , priority_layers_groups , extent ) Runs the normalization on the models pathways layers, adjusting band values measured on different scale, the resulting scale is computed using the below formula Normalized_Pathway = (Carbon coefficient + Suitability index) * ( (Model layer value) - (Model band minimum value)) / (Model band maximum value - Model band minimum value)) If the carbon coefficient and suitability index are both zero then the computation won't take them into account in the normalization calculation. Parameters: Name Type Description Default models typing.List[ImplementationModel] List of the analyzed implementation models required priority_layers_groups dict Used priority layers groups and their values required extent str selected extent from user required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 def run_pathways_normalization ( self , models , priority_layers_groups , extent ): \"\"\"Runs the normalization on the models pathways layers, adjusting band values measured on different scale, the resulting scale is computed using the below formula Normalized_Pathway = (Carbon coefficient + Suitability index) * ( (Model layer value) - (Model band minimum value)) / (Model band maximum value - Model band minimum value)) If the carbon coefficient and suitability index are both zero then the computation won't take them into account in the normalization calculation. :param models: List of the analyzed implementation models :type models: typing.List[ImplementationModel] :param priority_layers_groups: Used priority layers groups and their values :type priority_layers_groups: dict :param extent: selected extent from user :type extent: str \"\"\" if self . processing_cancelled : # Will not proceed if processing has been cancelled by the user return False pathway_count = 0 priority_function = partial ( self . run_models_analysis , models , priority_layers_groups , extent ) main_task = QgsTask . fromFunction ( \"Running pathways normalization\" , self . main_task , on_finished = priority_function , ) previous_sub_tasks = [] self . progress_dialog . analysis_finished_message = tr ( \"Normalization\" ) self . progress_dialog . scenario_name = tr ( \"pathways\" ) pathways = [] models_paths = [] for model in models : if not model . pathways and ( model . path is None or model . path is \"\" ): self . show_message ( tr ( f \"No defined model pathways or a\" f \" model layer for the model { model . name } \" ), level = Qgis . Critical , ) log ( f \"No defined model pathways or a \" f \"model layer for the model { model . name } \" ) main_task . cancel () return False for pathway in model . pathways : if not ( pathway in pathways ): pathways . append ( pathway ) if model . path is not None and model . path is not \"\" : models_paths . append ( model . path ) if not pathways and len ( models_paths ) > 0 : self . run_models_analysis ( models , priority_layers_groups , extent ) return carbon_coefficient = float ( settings_manager . get_value ( Settings . CARBON_COEFFICIENT , default = 0.0 ) ) suitability_index = float ( settings_manager . get_value ( Settings . PATHWAY_SUITABILITY_INDEX , default = 0 ) ) normalization_index = carbon_coefficient + suitability_index for pathway in pathways : layers = [] new_ims_directory = f \" { self . scenario_directory } /normalized_pathways\" FileUtils . create_new_dir ( new_ims_directory ) file_name = clean_filename ( pathway . name . replace ( \" \" , \"_\" )) output_file = f \" { new_ims_directory } / { file_name } _ { str ( uuid . uuid4 ())[: 4 ] } .tif\" pathway_layer = QgsRasterLayer ( pathway . path , pathway . name ) provider = pathway_layer . dataProvider () band_statistics = provider . bandStatistics ( 1 ) min_value = band_statistics . minimumValue max_value = band_statistics . maximumValue layer_name = Path ( pathway . path ) . stem layers . append ( pathway . path ) if normalization_index > 0 : expression = ( f \" { normalization_index } * \" f '(\" { layer_name } @1\" - { min_value } ) /' f \" ( { max_value } - { min_value } )\" ) else : expression = ( f '(\" { layer_name } @1\" - { min_value } ) /' f \" ( { max_value } - { min_value } )\" ) analysis_done = partial ( self . pathways_normalization_done , pathway_count , models , extent , priority_layers_groups , pathways , pathway , ( pathway_count == len ( pathways ) - 1 ), ) # Actual processing calculation alg_params = { \"CELLSIZE\" : 0 , \"CRS\" : None , \"EXPRESSION\" : expression , \"EXTENT\" : extent , \"LAYERS\" : layers , \"OUTPUT\" : output_file , } log ( f \"Used parameters for normalization of the pathways: { alg_params } \" ) alg = QgsApplication . processingRegistry () . algorithmById ( \"qgis:rastercalculator\" ) self . task = QgsProcessingAlgRunnerTask ( alg , alg_params , self . processing_context , self . position_feedback ) self . position_feedback . progressChanged . connect ( self . update_progress_bar ) main_task . addSubTask ( self . task , previous_sub_tasks , QgsTask . ParentDependsOnSubTask ) previous_sub_tasks . append ( self . task ) self . task . executed . connect ( analysis_done ) pathway_count = pathway_count + 1 QgsApplication . taskManager () . addTask ( main_task ) run_priority_analysis run_priority_analysis ( models , priority_layers_groups , extent ) Runs the required model analysis on the passed implementation models Parameters: Name Type Description Default models typing.List[ImplementationModel] List of the selected implementation models required priority_layers_groups dict Used priority layers groups and their values required extent SpatialExtent selected extent from user required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740 1741 1742 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1765 1766 1767 1768 1769 1770 1771 1772 1773 1774 1775 1776 1777 1778 1779 1780 1781 1782 1783 1784 1785 1786 1787 1788 1789 def run_priority_analysis ( self , models , priority_layers_groups , extent ): \"\"\"Runs the required model analysis on the passed implementation models :param models: List of the selected implementation models :type models: typing.List[ImplementationModel] :param priority_layers_groups: Used priority layers groups and their values :type priority_layers_groups: dict :param extent: selected extent from user :type extent: SpatialExtent \"\"\" model_count = 0 main_task = QgsTask . fromFunction ( \"Running main task for priority layers weighting\" , self . main_task , on_finished = self . run_highest_position_analysis , ) main_task . taskCompleted . connect ( self . run_highest_position_analysis ) previous_sub_tasks = [] self . progress_dialog . analysis_finished_message = tr ( f \"Weighting\" ) self . progress_dialog . scenario_name = tr ( f \"implementation models\" ) for model in models : if model . path is None or model . path is \"\" : self . show_message ( tr ( f \"Problem when running models weighting, \" f \"there is no map layer for the model { model . name } \" ), level = Qgis . Critical , ) log ( f \"Problem when running models normalization, \" f \"there is no map layer for the model { model . name } \" ) main_task . cancel () return False basenames = [] layers = [] selected_layers = [] analysis_done = partial ( self . priority_layers_analysis_done , model_count , model , models ) layers . append ( model . path ) basenames . append ( f '\" { Path ( model . path ) . stem } @1\"' ) if not any ( priority_layers_groups ): log ( f \"There are defined priority layers in groups,\" f \" skipping models weighting step.\" ) self . run_highest_position_analysis () return if model . priority_layers is None or model . priority_layers is []: log ( f \"There are no associated \" f \"priority weighting layers for model { model . name } \" ) continue settings_model = settings_manager . get_implementation_model ( str ( model . uuid )) for layer in settings_model . priority_layers : settings_layer = settings_manager . get_priority_layer ( layer . get ( \"uuid\" )) pwl = settings_layer . get ( \"path\" ) missing_pwl_message = ( f \"Path { pwl } for priority \" f \"weighting layer { layer . get ( 'name' ) } \" f \"doesn't exist, skipping the layer \" f \"from the model { model . name } weighting.\" ) if pwl is None : log ( missing_pwl_message ) continue pwl_path = Path ( pwl ) if not pwl_path . exists (): log ( missing_pwl_message ) continue path_basename = pwl_path . stem for priority_layer in settings_manager . get_priority_layers (): if priority_layer . get ( \"name\" ) == layer . get ( \"name\" ): for group in priority_layer . get ( \"groups\" , []): value = group . get ( \"value\" ) coefficient = float ( value ) if coefficient > 0 : if pwl not in layers : layers . append ( pwl ) basenames . append ( f '( { coefficient } *\" { path_basename } @1\")' ) if basenames is []: return new_ims_directory = f \" { self . scenario_directory } /weighted_ims\" FileUtils . create_new_dir ( new_ims_directory ) file_name = clean_filename ( model . name . replace ( \" \" , \"_\" )) output_file = f \" { new_ims_directory } / { file_name } _ { str ( uuid . uuid4 ())[: 4 ] } .tif\" expression = \" + \" . join ( basenames ) # Actual processing calculation alg_params = { \"CELLSIZE\" : 0 , \"CRS\" : None , \"EXPRESSION\" : expression , \"EXTENT\" : extent , \"LAYERS\" : layers , \"OUTPUT\" : output_file , } log ( f \" Used parameters for calculating weighting models { alg_params } \" ) alg = QgsApplication . processingRegistry () . algorithmById ( \"qgis:rastercalculator\" ) self . task = QgsProcessingAlgRunnerTask ( alg , alg_params , self . processing_context , self . position_feedback ) self . position_feedback . progressChanged . connect ( self . update_progress_bar ) main_task . addSubTask ( self . task , previous_sub_tasks , QgsTask . ParentDependsOnSubTask ) previous_sub_tasks . append ( self . task ) self . task . executed . connect ( analysis_done ) model_count = model_count + 1 QgsApplication . taskManager () . addTask ( main_task ) run_report run_report () Run report generation. This should be called after the analysis is complete. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2144 2145 2146 2147 2148 2149 2150 2151 2152 2153 2154 2155 2156 2157 2158 2159 2160 2161 2162 2163 2164 2165 2166 def run_report ( self ): \"\"\"Run report generation. This should be called after the analysis is complete. \"\"\" if self . processing_cancelled : # Will not proceed if processing has been cancelled by the user return if self . scenario_result is None : log ( \"Cannot run report generation, scenario result is \" \"not defined\" , info = False , ) return self . reset_reporting_feedback () submit_result = self . report_manager . generate ( self . scenario_result , self . reporting_feedback ) if not submit_result . status : msg = self . tr ( \"Unable to submit report request for scenario\" ) self . show_message ( f \" { msg } { self . scenario_result . scenario . name } .\" ) save_scenario save_scenario () Save current scenario details into settings Source code in src/cplus_plugin/gui/qgis_cplus_main.py 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 def save_scenario ( self ): \"\"\"Save current scenario details into settings\"\"\" scenario_name = self . scenario_name . text () scenario_description = self . scenario_description . text () extent = self . extent_box . outputExtent () extent_box = [ extent . xMinimum (), extent . xMaximum (), extent . yMinimum (), extent . yMaximum (), ] settings_manager . set_value ( Settings . SCENARIO_NAME , scenario_name ) settings_manager . set_value ( Settings . SCENARIO_DESCRIPTION , scenario_description ) settings_manager . set_value ( Settings . SCENARIO_EXTENT , extent_box ) scenario_results scenario_results ( success , output ) Called when the task ends. Sets the progress bar to 100 if it finished. Parameters: Name Type Description Default success bool Whether the scenario analysis was successful required output dict Analysis output results required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1835 1836 1837 1838 1839 1840 1841 1842 1843 1844 1845 1846 1847 1848 1849 1850 1851 1852 1853 1854 def scenario_results ( self , success , output ): \"\"\"Called when the task ends. Sets the progress bar to 100 if it finished. :param success: Whether the scenario analysis was successful :type success: bool :param output: Analysis output results :type output: dict \"\"\" if output is not None : self . update_progress_bar ( 100 ) self . scenario_result . analysis_output = output self . scenario_result . state = ScenarioState . FINISHED self . analysis_finished . emit ( self . scenario_result ) else : self . progress_dialog . change_status_message ( \"No valid output from the processing results.\" ) log ( f \"No valid output from the processing results.\" ) show_message show_message ( message , level = Qgis . Warning ) Shows message on the main widget message bar. Parameters: Name Type Description Default message str Text message required level Qgis.MessageLevel Message level type Warning Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2051 2052 2053 2054 2055 2056 2057 2058 2059 2060 2061 def show_message ( self , message , level = Qgis . Warning ): \"\"\"Shows message on the main widget message bar. :param message: Text message :type message: str :param level: Message level type :type level: Qgis.MessageLevel \"\"\" self . message_bar . clearWidgets () self . message_bar . pushMessage ( message , level = level ) transform_extent transform_extent ( extent , source_crs , dest_crs ) Transforms the passed extent into the destination crs :param extent: Target extent Parameters: Name Type Description Default source_crs QgsCoordinateReferenceSystem Source CRS of the passed extent required dest_crs QgsCoordinateReferenceSystem Destination CRS required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 def transform_extent ( self , extent , source_crs , dest_crs ): \"\"\"Transforms the passed extent into the destination crs :param extent: Target extent :type extent: QgsRectangle :param source_crs: Source CRS of the passed extent :type source_crs: QgsCoordinateReferenceSystem :param dest_crs: Destination CRS :type dest_crs: QgsCoordinateReferenceSystem \"\"\" transform = QgsCoordinateTransform ( source_crs , dest_crs , QgsProject . instance ()) transformed_extent = transform . transformBoundingBox ( extent ) return transformed_extent update_message_bar update_message_bar ( message ) Changes the message in the message bar item. Parameters: Name Type Description Default message str Message to be updated required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2042 2043 2044 2045 2046 2047 2048 2049 def update_message_bar ( self , message ): \"\"\"Changes the message in the message bar item. :param message: Message to be updated :type message: str \"\"\" message_bar_item = self . message_bar . createMessage ( message ) self . message_bar . pushWidget ( message_bar_item , Qgis . Info ) update_priority_layers update_priority_layers ( update_groups = True ) Updates the priority weighting layers list in the UI. Parameters: Name Type Description Default update_groups bool Whether to update the priority groups list or not True Source code in src/cplus_plugin/gui/qgis_cplus_main.py 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 def update_priority_layers ( self , update_groups = True ): \"\"\"Updates the priority weighting layers list in the UI. :param update_groups: Whether to update the priority groups list or not :type update_groups: bool \"\"\" self . priority_layers_list . clear () for layer in settings_manager . get_priority_layers (): item = QtWidgets . QListWidgetItem () item . setData ( QtCore . Qt . DisplayRole , layer . get ( \"name\" )) item . setData ( QtCore . Qt . UserRole , layer . get ( \"uuid\" )) self . priority_layers_list . addItem ( item ) if update_groups : for index in range ( self . priority_groups_list . topLevelItemCount ()): group = self . priority_groups_list . topLevelItem ( index ) if group . text ( 0 ) in layer . get ( \"groups\" ): self . add_priority_layer_group ( group , item ) else : group_children = group . takeChildren () children = [] for child in group_children : if child . text ( 0 ) == layer . get ( \"name\" ): continue children . append ( child ) group . addChildren ( children ) update_progress_bar update_progress_bar ( value ) Sets the value of the progress bar Parameters: Name Type Description Default value float Value to be set on the progress bar required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2030 2031 2032 2033 2034 2035 2036 2037 2038 2039 2040 def update_progress_bar ( self , value ): \"\"\"Sets the value of the progress bar :param value: Value to be set on the progress bar :type value: float \"\"\" if self . progress_dialog and not self . processing_cancelled : try : self . progress_dialog . update_progress_bar ( int ( value )) except RuntimeError : log ( tr ( \"Error setting value to a progress bar\" ), notify = False ) update_pwl_layers update_pwl_layers ( notify = False ) Updates the priority layers path available in the store implementation models Parameters: Name Type Description Default notify bool Whether to show message to user about the update False Source code in src/cplus_plugin/gui/qgis_cplus_main.py 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 def update_pwl_layers ( self , notify = False ): \"\"\"Updates the priority layers path available in the store implementation models :param notify: Whether to show message to user about the update :type notify: bool \"\"\" settings_manager . update_implementation_models () self . update_priority_layers () if notify : self . show_message ( tr ( \"Updated all the implementation models\" \" with their respective priority layers\" ), Qgis . Info , ) log ( tr ( \"Updated all the implementation models\" \" with their respective priority layers\" ) ) zoom_pilot_area zoom_pilot_area () Zoom the current main map canvas to the pilot area extent. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2063 2064 2065 2066 2067 2068 2069 2070 2071 2072 2073 2074 2075 2076 2077 2078 2079 2080 2081 2082 2083 2084 2085 2086 2087 2088 2089 2090 2091 2092 2093 2094 2095 def zoom_pilot_area ( self ): \"\"\"Zoom the current main map canvas to the pilot area extent.\"\"\" map_canvas = iface . mapCanvas () extent_list = PILOT_AREA_EXTENT [ \"coordinates\" ] default_extent = QgsRectangle ( extent_list [ 0 ], extent_list [ 2 ], extent_list [ 1 ], extent_list [ 3 ] ) zoom_extent = QgsRectangle ( extent_list [ 0 ] - 0.5 , extent_list [ 2 ], extent_list [ 1 ] + 0.5 , extent_list [ 3 ] ) canvas_crs = map_canvas . mapSettings () . destinationCrs () original_crs = QgsCoordinateReferenceSystem ( \"EPSG:4326\" ) if canvas_crs . authid () != original_crs . authid (): zoom_extent = self . transform_extent ( zoom_extent , original_crs , canvas_crs ) default_extent = self . transform_extent ( default_extent , original_crs , canvas_crs ) aoi = QgsRubberBand ( iface . mapCanvas (), QgsWkbTypes . PolygonGeometry ) aoi . setFillColor ( QtGui . QColor ( 0 , 0 , 0 , 0 )) aoi . setStrokeColor ( QtGui . QColor ( 88 , 128 , 8 )) aoi . setWidth ( 3 ) aoi . setLineStyle ( QtCore . Qt . DashLine ) geom = QgsGeometry . fromRect ( default_extent ) aoi . setToGeometry ( geom , canvas_crs ) map_canvas . setExtent ( zoom_extent ) map_canvas . refresh ()","title":"GUI main"},{"location":"developer/api/gui/api_gui_main/#gui-main","text":"The plugin main window class.","title":"GUI main"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain","text":"QgisCplusMain ( iface , parent = None ) Bases: QDockWidget , WidgetUi Main plugin UI Source code in src/cplus_plugin/gui/qgis_cplus_main.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 def __init__ ( self , iface , parent = None , ): super () . __init__ ( parent ) self . setupUi ( self ) self . iface = iface self . progress_dialog = None self . task = None self . processing_cancelled = False # Insert widget for step 2 self . implementation_model_widget = ImplementationModelContainerWidget ( self ) self . tab_widget . insertTab ( 1 , self . implementation_model_widget , self . tr ( \"Step 2\" ) ) self . tab_widget . currentChanged . connect ( self . on_tab_step_changed ) self . prepare_input () # Step 3, priority weighting layers initialization self . priority_groups_widgets = {} self . initialize_priority_layers () self . position_feedback = QgsProcessingFeedback () self . processing_context = QgsProcessingContext () self . scenario_result = None self . analysis_finished . connect ( self . post_analysis ) # Report manager self . report_manager = report_manager self . report_manager . generate_started . connect ( self . on_report_running ) self . report_manager . generate_completed . connect ( self . on_report_finished ) self . reporting_feedback : typing . Union [ QgsFeedback , None ] = None","title":"QgisCplusMain"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.add_priority_layer","text":"add_priority_layer () Adds a new priority layer into the plugin, then updates the priority list to show the new added priority layer. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 506 507 508 509 510 511 512 def add_priority_layer ( self ): \"\"\"Adds a new priority layer into the plugin, then updates the priority list to show the new added priority layer. \"\"\" layer_dialog = PriorityLayerDialog () layer_dialog . exec_ () self . update_priority_layers ( update_groups = False )","title":"add_priority_layer()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.add_priority_layer_group","text":"add_priority_layer_group ( target_group = None , priority_layer = None ) Adds priority layer from the weighting layers into a priority group If no target_group or priority_layer is passed then the current selected group or priority layer from their respective list will be used. Checks if priority layer is already in the target group and if so no addition is done. Once the addition is done, the respective priority layer plugin settings are updated to store the new information. Parameters: Name Type Description Default target_group dict Priority group where layer will be added to None priority_layer dict Priority weighting layer to be added None Source code in src/cplus_plugin/gui/qgis_cplus_main.py 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 def add_priority_layer_group ( self , target_group = None , priority_layer = None ): \"\"\"Adds priority layer from the weighting layers into a priority group If no target_group or priority_layer is passed then the current selected group or priority layer from their respective list will be used. Checks if priority layer is already in the target group and if so no addition is done. Once the addition is done, the respective priority layer plugin settings are updated to store the new information. :param target_group: Priority group where layer will be added to :type target_group: dict :param priority_layer: Priority weighting layer to be added :type priority_layer: dict \"\"\" selected_priority_layers = ( priority_layer or self . priority_layers_list . selectedItems () ) selected_priority_layers = ( [ selected_priority_layers ] if not isinstance ( selected_priority_layers , list ) else selected_priority_layers ) selected_group = target_group or self . priority_groups_list . currentItem () for selected_priority_layer in selected_priority_layers : if ( selected_group is not None and selected_group . parent () is None ) and selected_priority_layer is not None : children = selected_group . takeChildren () item_found = False text = selected_priority_layer . data ( QtCore . Qt . DisplayRole ) for child in children : if child . text ( 0 ) == text : item_found = True break selected_group . addChildren ( children ) if not item_found : selected_group . setExpanded ( True ) item = QtWidgets . QTreeWidgetItem ( selected_group ) item . setText ( 0 , text ) group_widget = self . priority_groups_list . itemWidget ( selected_group , 0 ) layer_id = selected_priority_layer . data ( QtCore . Qt . UserRole ) priority_layer = settings_manager . get_priority_layer ( layer_id ) target_group_name = ( group_widget . group . get ( \"name\" ) if group_widget . group else None ) groups = priority_layer . get ( \"groups\" ) new_groups = [] group_found = False for group in groups : if target_group_name == group [ \"name\" ]: group_found = True new_group = settings_manager . find_group_by_name ( target_group_name ) else : new_group = group new_groups . append ( new_group ) if not group_found : searched_group = settings_manager . find_group_by_name ( target_group_name ) new_groups . append ( searched_group ) priority_layer [ \"groups\" ] = new_groups settings_manager . save_priority_layer ( priority_layer )","title":"add_priority_layer_group()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.cancel_processing_task","text":"cancel_processing_task () Cancels the current processing task. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1817 1818 1819 1820 1821 1822 1823 1824 1825 1826 1827 1828 1829 1830 1831 1832 1833 def cancel_processing_task ( self ): \"\"\"Cancels the current processing task.\"\"\" self . processing_cancelled = True # Analysis processing tasks try : if self . task : self . task . cancel () except Exception as e : log ( f \"Problem cancelling task, { e } \" ) # Report generating task try : if self . reporting_feedback : self . reporting_feedback . cancel () except Exception as e : log ( f \"Problem cancelling report generating task, { e } \" )","title":"cancel_processing_task()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.edit_priority_layer","text":"edit_priority_layer () Edits the current selected priority layer and updates the layer box list. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 def edit_priority_layer ( self ): \"\"\"Edits the current selected priority layer and updates the layer box list.\"\"\" if self . priority_layers_list . currentItem () is None : self . show_message ( tr ( \"Select first the priority weighting layer from the layers list.\" ), Qgis . Critical , ) return current_text = self . priority_layers_list . currentItem () . data ( QtCore . Qt . DisplayRole ) if current_text == \"\" : self . show_message ( tr ( \"Could not fetch the selected priority layer for editing.\" ), Qgis . Critical , ) return layer = settings_manager . find_layer_by_name ( current_text ) layer_dialog = PriorityLayerDialog ( layer ) layer_dialog . exec_ ()","title":"edit_priority_layer()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.group_value_changed","text":"group_value_changed ( group_name , group_value ) Slot to handle priority group widget changes. Parameters: Name Type Description Default group_name str Group name required group_value int Group value required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 def group_value_changed ( self , group_name , group_value ): \"\"\"Slot to handle priority group widget changes. :param group_name: Group name :type group_name: str :param group_value: Group value :type group_value: int \"\"\" group = settings_manager . find_group_by_name ( group_name ) group [ \"value\" ] = group_value settings_manager . save_priority_group ( group ) for index in range ( self . priority_groups_list . topLevelItemCount ()): item = self . priority_groups_list . topLevelItem ( index ) for child_index in range ( item . childCount ()): child = item . child ( child_index ) layer = settings_manager . find_layer_by_name ( child . text ( 0 )) new_groups = [] for group in layer . get ( \"groups\" ): if group . get ( \"name\" ) == group_name : group [ \"value\" ] = group_value new_groups . append ( group ) layer [ \"groups\" ] = new_groups settings_manager . save_priority_layer ( layer )","title":"group_value_changed()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.initialize_priority_layers","text":"initialize_priority_layers () Prepares the priority weighted layers UI with the defaults. Gets the store priority layers from plugin settings and populates them into the QListWidget as QListWidgetItems then fetches the priority groups and adds them to the QTreeWidget as QTreeWidgetItems with their corresponding priority layers as their child items. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 def initialize_priority_layers ( self ): \"\"\"Prepares the priority weighted layers UI with the defaults. Gets the store priority layers from plugin settings and populates them into the QListWidget as QListWidgetItems then fetches the priority groups and adds them to the QTreeWidget as QTreeWidgetItems with their corresponding priority layers as their child items. \"\"\" self . priority_layers_list . clear () for layer in settings_manager . get_priority_layers (): item = QtWidgets . QListWidgetItem () item . setData ( QtCore . Qt . DisplayRole , layer . get ( \"name\" )) item . setData ( QtCore . Qt . UserRole , layer . get ( \"uuid\" )) self . priority_layers_list . addItem ( item ) list_items = [] items_only = [] stored_priority_groups = settings_manager . get_priority_groups () self . priority_groups_list . clear () for group in stored_priority_groups : group_widget = PriorityGroupWidget ( group , ) group_widget . input_value_changed . connect ( self . group_value_changed ) group_widget . slider_value_changed . connect ( self . group_value_changed ) self . priority_groups_widgets [ group [ \"name\" ]] = group_widget pw_layers = settings_manager . find_layers_by_group ( group [ \"name\" ]) item = QtWidgets . QTreeWidgetItem () item . setSizeHint ( 0 , group_widget . sizeHint ()) item . setExpanded ( True ) # Add priority layers into the group as a child items. item . setExpanded ( True ) if len ( pw_layers ) > 0 else None for layer in pw_layers : if item . parent () is None : layer_item = QtWidgets . QTreeWidgetItem ( item ) layer_item . setText ( 0 , layer . get ( \"name\" )) list_items . append (( item , group_widget )) items_only . append ( item ) self . priority_groups_list . addTopLevelItems ( items_only ) for item in list_items : self . priority_groups_list . setItemWidget ( item [ 0 ], 0 , item [ 1 ])","title":"initialize_priority_layers()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.main_task","text":"main_task () Serves as a QgsTask function for the main task that contains smaller sub-tasks running the actual processing calculations. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 872 873 874 875 876 877 def main_task ( self ): \"\"\"Serves as a QgsTask function for the main task that contains smaller sub-tasks running the actual processing calculations. \"\"\" log ( \"Running from main task.\" )","title":"main_task()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.model_analysis_done","text":"model_analysis_done ( model_index , model , models , extent , priority_layers_groups , success , output ) Slot that handles post calculations for the models layers Parameters: Name Type Description Default model_index int List index of the target model required model ImplementationModel Target implementation model required priority_layers_groups dict Used priority layers groups and their values required success bool Whether the scenario analysis was successful required output dict Analysis output results required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 def model_analysis_done ( self , model_index , model , models , extent , priority_layers_groups , success , output , ): \"\"\"Slot that handles post calculations for the models layers :param model_index: List index of the target model :type model_index: int :param model: Target implementation model :type model: ImplementationModel :param model: List of the selected implementation models :type model: typing.List[ImplementationModel] :param priority_layers_groups: Used priority layers groups and their values :type priority_layers_groups: dict :param success: Whether the scenario analysis was successful :type success: bool :param output: Analysis output results :type output: dict \"\"\" if output is not None and output . get ( \"OUTPUT\" ) is not None : model . path = output . get ( \"OUTPUT\" ) if model_index == len ( models ) - 1 : self . run_normalization_analysis ( models , priority_layers_groups , extent )","title":"model_analysis_done()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.move_layer_to_group","text":"move_layer_to_group ( layer , group ) Moves a layer open in QGIS to another group. Parameters: Name Type Description Default layer QgsRasterLayer Raster layer to move required group QgsLayerTreeGroup Group to which the raster should be moved required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1856 1857 1858 1859 1860 1861 1862 1863 1864 1865 1866 1867 1868 1869 1870 1871 def move_layer_to_group ( self , layer , group ) -> None : \"\"\"Moves a layer open in QGIS to another group. :param layer: Raster layer to move :type layer: QgsRasterLayer :param group: Group to which the raster should be moved :type group: QgsLayerTreeGroup \"\"\" if layer : instance_root = QgsProject . instance () . layerTreeRoot () layer = instance_root . findLayer ( layer . id ()) layer_clone = layer . clone () parent = layer . parent () group . insertChildNode ( 0 , layer_clone ) # Add to top of group parent . removeChildNode ( layer )","title":"move_layer_to_group()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.normalization_analysis_done","text":"normalization_analysis_done ( model_index , model , models , extent , priority_layers_groups , success , output ) Slot that handles normalized models layers. Parameters: Name Type Description Default model_index int List index of the target model required model ImplementationModel Target implementation model required models List of the selected implementation models required success bool Whether the scenario analysis was successful required output dict Analysis output results required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 def normalization_analysis_done ( self , model_index , model , models , extent , priority_layers_groups , success , output , ): \"\"\"Slot that handles normalized models layers. :param model_index: List index of the target model :type model_index: int :param model: Target implementation model :type model: ImplementationModel :param models: List of the selected implementation models :type modesls: typing.List[ImplementationModel] :param success: Whether the scenario analysis was successful :type success: bool :param output: Analysis output results :type output: dict \"\"\" if output is not None and output . get ( \"OUTPUT\" ) is not None : model . path = output . get ( \"OUTPUT\" ) if model_index == len ( models ) - 1 : self . run_priority_analysis ( models , priority_layers_groups , extent )","title":"normalization_analysis_done()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.on_report_finished","text":"on_report_finished ( scenario_id ) Slot raised when report task has finished. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2199 2200 2201 2202 2203 2204 2205 2206 2207 def on_report_finished ( self , scenario_id : str ): \"\"\"Slot raised when report task has finished.\"\"\" if not self . report_job_is_for_current_scenario ( scenario_id ): return self . progress_dialog . set_report_complete () self . progress_dialog . change_status_message ( tr ( \"Report generation complete\" ), tr ( \"scenario\" ) )","title":"on_report_finished()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.on_report_running","text":"on_report_running ( scenario_id ) Slot raised when report task has started. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2168 2169 2170 2171 2172 2173 2174 2175 2176 2177 def on_report_running ( self , scenario_id : str ): \"\"\"Slot raised when report task has started.\"\"\" if not self . report_job_is_for_current_scenario ( scenario_id ): return self . progress_dialog . update_progress_bar ( 0 ) self . progress_dialog . report_running = True self . progress_dialog . change_status_message ( tr ( \"Generating report\" ), tr ( \"scenario\" ) )","title":"on_report_running()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.on_reporting_progress_changed","text":"on_reporting_progress_changed ( progress ) Slot raised when the reporting progress has changed. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2195 2196 2197 def on_reporting_progress_changed ( self , progress : float ): \"\"\"Slot raised when the reporting progress has changed.\"\"\" self . progress_dialog . update_progress_bar ( progress )","title":"on_reporting_progress_changed()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.on_tab_step_changed","text":"on_tab_step_changed ( index ) Slot raised when the current tab changes. Parameters: Name Type Description Default index int Zero-based index position of new current tab required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2119 2120 2121 2122 2123 2124 2125 2126 2127 2128 2129 2130 2131 2132 2133 2134 2135 2136 2137 2138 def on_tab_step_changed ( self , index : int ): \"\"\"Slot raised when the current tab changes. :param index: Zero-based index position of new current tab :type index: int \"\"\" if index == 1 : self . implementation_model_widget . load () elif index == 2 : # Validate NCS pathway - implementation model mapping valid = self . implementation_model_widget . is_valid () if not valid : msg = self . tr ( \"Define one or more NCS pathways/map layers for at least one implementation model.\" ) self . show_message ( msg ) self . tab_widget . setCurrentIndex ( 1 ) else : self . message_bar . clearWidgets ()","title":"on_tab_step_changed()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.open_help","text":"open_help () Opens the user documentation for the plugin in a browser Source code in src/cplus_plugin/gui/qgis_cplus_main.py 502 503 504 def open_help ( self ): \"\"\"Opens the user documentation for the plugin in a browser\"\"\" open_documentation ( USER_DOCUMENTATION_SITE )","title":"open_help()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.open_settings","text":"open_settings () Options the CPLUS settings in the QGIS options dialog. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2140 2141 2142 def open_settings ( self ): \"\"\"Options the CPLUS settings in the QGIS options dialog.\"\"\" self . iface . showOptionsDialog ( currentPage = OPTIONS_TITLE )","title":"open_settings()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.pathways_analysis_done","text":"pathways_analysis_done ( pathway_count , models , extent , priority_layers_groups , pathways , pathway , last_pathway , success , output ) Slot that handles post calculations for the models pathways and carbon layers. Parameters: Name Type Description Default model_index int List index of the target model required pathway NCSPathway Target pathway required models typing.List[ImplementationModel] List of the selected implementation models required priority_layers_groups dict Used priority layers groups and their values required last_pathway bool Whether the pathway is the last from the models pathway list required success bool Whether the scenario analysis was successful required output dict Analysis output results required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 def pathways_analysis_done ( self , pathway_count , models , extent , priority_layers_groups , pathways , pathway , last_pathway , success , output , ): \"\"\"Slot that handles post calculations for the models pathways and carbon layers. :param model_index: List index of the target model :type model_index: int :param pathway: Target pathway :type pathway: NCSPathway :param models: List of the selected implementation models :type models: typing.List[ImplementationModel] :param priority_layers_groups: Used priority layers groups and their values :type priority_layers_groups: dict :param last_pathway: Whether the pathway is the last from the models pathway list :type last_pathway: bool :param success: Whether the scenario analysis was successful :type success: bool :param output: Analysis output results :type output: dict \"\"\" if output is not None and output . get ( \"OUTPUT\" ) is not None : pathway . path = output . get ( \"OUTPUT\" ) if ( pathway_count == len ( pathways ) - 1 ) and last_pathway : self . run_pathways_normalization ( models , priority_layers_groups , extent )","title":"pathways_analysis_done()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.pathways_normalization_done","text":"pathways_normalization_done ( pathway_count , models , extent , priority_layers_groups , pathways , pathway , last_pathway , success , output ) Slot that handles normalized pathways layers. Parameters: Name Type Description Default model_index int List index of the target model required pathway NCSPathway Target pathway required models typing.List[ImplementationModel] List of the selected implementation models required priority_layers_groups dict Used priority layers groups and their values required last_pathway bool Whether the pathway is the last from the models pathway list required success bool Whether the scenario analysis was successful required output dict Analysis output results required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 def pathways_normalization_done ( self , pathway_count , models , extent , priority_layers_groups , pathways , pathway , last_pathway , success , output , ): \"\"\"Slot that handles normalized pathways layers. :param model_index: List index of the target model :type model_index: int :param pathway: Target pathway :type pathway: NCSPathway :param models: List of the selected implementation models :type models: typing.List[ImplementationModel] :param priority_layers_groups: Used priority layers groups and their values :type priority_layers_groups: dict :param last_pathway: Whether the pathway is the last from the models pathway list :type last_pathway: bool :param success: Whether the scenario analysis was successful :type success: bool :param output: Analysis output results :type output: dict \"\"\" if output is not None and output . get ( \"OUTPUT\" ) is not None : pathway . path = output . get ( \"OUTPUT\" ) if ( pathway_count == len ( pathways ) - 1 ) and last_pathway : self . run_models_analysis ( models , priority_layers_groups , extent )","title":"pathways_normalization_done()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.post_analysis","text":"post_analysis ( scenario_result ) Handles analysis outputs from the final analysis results. Adds the resulting scenario raster to the canvas with styling. Adds each of the implementation models to the canvas with styling. Adds each IMs pathways to the canvas. Parameters: Name Type Description Default scenario_result ScenarioResult ScenarioResult of output results required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1873 1874 1875 1876 1877 1878 1879 1880 1881 1882 1883 1884 1885 1886 1887 1888 1889 1890 1891 1892 1893 1894 1895 1896 1897 1898 1899 1900 1901 1902 1903 1904 1905 1906 1907 1908 1909 1910 1911 1912 1913 1914 1915 1916 1917 1918 1919 1920 1921 1922 1923 1924 1925 1926 1927 1928 1929 1930 1931 1932 1933 1934 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023 2024 2025 2026 2027 2028 def post_analysis ( self , scenario_result ): \"\"\"Handles analysis outputs from the final analysis results. Adds the resulting scenario raster to the canvas with styling. Adds each of the implementation models to the canvas with styling. Adds each IMs pathways to the canvas. :param scenario_result: ScenarioResult of output results :type scenario_result: ScenarioResult \"\"\" # If the processing were stopped, no file will be added if not self . processing_cancelled : raster = scenario_result . analysis_output [ \"OUTPUT\" ] im_weighted_dir = os . path . dirname ( raster ) + \"/weighted_ims/\" list_weighted_ims = ( os . listdir ( im_weighted_dir ) if os . path . exists ( im_weighted_dir ) else [] ) scenario_name = scenario_result . scenario . name qgis_instance = QgsProject . instance () instance_root = qgis_instance . layerTreeRoot () # Check if there are other groups for the scenario # and assign a suffix. counter = 1 group_name = scenario_name # Control to prevent infinite loop max_limit = 100 while True and counter <= max_limit : scenario_grp = instance_root . findGroup ( group_name ) if scenario_grp is None : break group_name = f \" { scenario_name } { counter !s} \" counter += 1 # Groups scenario_group = instance_root . insertGroup ( 0 , group_name ) im_group = scenario_group . addGroup ( tr ( IM_GROUP_LAYER_NAME )) im_weighted_group = ( scenario_group . addGroup ( tr ( IM_WEIGHTED_GROUP_NAME )) if os . path . exists ( im_weighted_dir ) else None ) pathways_group = scenario_group . addGroup ( tr ( NCS_PATHWAYS_GROUP_LAYER_NAME )) # Group settings im_group . setExpanded ( False ) im_weighted_group . setExpanded ( False ) if im_weighted_group else None pathways_group . setExpanded ( False ) pathways_group . setItemVisibilityCheckedRecursive ( False ) # Add scenario result layer to the canvas with styling layer_file = scenario_result . analysis_output . get ( \"OUTPUT\" ) layer_name = ( f \" { SCENARIO_OUTPUT_LAYER_NAME } _\" f ' { datetime . datetime . now () . strftime ( \"%Y_%m_ %d _%H_%M_%S\" ) } ' ) scenario_result . output_layer_name = layer_name layer = QgsRasterLayer ( layer_file , layer_name , QGIS_GDAL_PROVIDER ) layer . loadNamedStyle ( LAYER_STYLES [ \"scenario_result\" ]) scenario_layer = qgis_instance . addMapLayer ( layer ) \"\"\"A workaround to add a layer to a group. Adding it using group.insertChildNode or group.addLayer causes issues, but adding to the root is fine. This approach adds it to the root, and then moves it to the group. \"\"\" self . move_layer_to_group ( scenario_layer , scenario_group ) coefficient = settings_manager . get_value ( Settings . CARBON_COEFFICIENT , default = 0.0 ) # Add implementation models and pathways list_models = scenario_result . scenario . models im_index = 0 for im in list_models : im_name = im . name im_layer = QgsRasterLayer ( im . path , im . name ) list_pathways = im . pathways # Add IM layer with styling, if available if im_layer : if float ( coefficient ) > 0 : # Style with range 0 to 2 style_to_use = LAYER_STYLES [ \"carbon\" ][ im_name ] else : # Style with range 0 to 1 style_to_use = LAYER_STYLES [ \"normal\" ][ im_name ] im_layer . loadNamedStyle ( style_to_use ) added_im_layer = qgis_instance . addMapLayer ( im_layer ) self . move_layer_to_group ( added_im_layer , im_group ) # Add IM pathways if len ( list_pathways ) > 0 : # im_pathway_group = pathways_group.addGroup(im_name) im_pathway_group = pathways_group . insertGroup ( im_index , im_name ) im_pathway_group . setExpanded ( False ) pw_index = 0 for pathway in list_pathways : try : # pathway_name = pathway.name pathway_layer = pathway . to_map_layer () added_pw_layer = qgis_instance . addMapLayer ( pathway_layer ) self . move_layer_to_group ( added_pw_layer , im_pathway_group ) pw_index = pw_index + 1 except Exception as err : self . show_message ( tr ( \"An error occurred loading a pathway, \" \"check logs for more information\" ), level = Qgis . Info , ) log ( tr ( \"An error occurred loading a pathway, \" 'scenario analysis, error message \" {} \"' . format ( err ) ) ) im_index = im_index + 1 for weighted_im in list_weighted_ims : if not weighted_im . endswith ( \".tif\" ): continue weighted_im_name = weighted_im [: len ( weighted_im ) - 9 ] if float ( coefficient ) > 0 : # Style with range 0 to 2 style_to_use = LAYER_STYLES_WEIGHTED [ \"carbon\" ][ weighted_im_name ] else : # Style with range 0 to 1 style_to_use = LAYER_STYLES_WEIGHTED [ \"normal\" ][ weighted_im_name ] im_weighted_layer = QgsRasterLayer ( im_weighted_dir + weighted_im , weighted_im_name , QGIS_GDAL_PROVIDER ) im_weighted_layer . loadNamedStyle ( style_to_use ) added_im_weighted_layer = qgis_instance . addMapLayer ( im_weighted_layer ) self . move_layer_to_group ( added_im_weighted_layer , im_weighted_group ) # Initiate report generation self . run_report () else : # Reinitializes variables if processing were cancelled by the user # Not doing this breaks the processing if a user tries to run # the processing after cancelling or if the processing fails self . position_feedback = QgsProcessingFeedback () self . processing_context = QgsProcessingContext ()","title":"post_analysis()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.prepare_extent_box","text":"prepare_extent_box () Configure the spatial extent box with the initial settings. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2097 2098 2099 2100 2101 2102 2103 2104 2105 2106 2107 2108 2109 2110 2111 2112 2113 2114 2115 2116 2117 def prepare_extent_box ( self ): \"\"\"Configure the spatial extent box with the initial settings.\"\"\" self . extent_box . setOutputCrs ( QgsCoordinateReferenceSystem ( \"EPSG:4326\" )) map_canvas = iface . mapCanvas () self . extent_box . setCurrentExtent ( map_canvas . mapSettings () . destinationCrs () . bounds (), map_canvas . mapSettings () . destinationCrs (), ) self . extent_box . setOutputExtentFromCurrent () self . extent_box . setMapCanvas ( map_canvas ) extent_list = PILOT_AREA_EXTENT [ \"coordinates\" ] default_extent = QgsRectangle ( extent_list [ 0 ], extent_list [ 2 ], extent_list [ 1 ], extent_list [ 3 ] ) self . extent_box . setOutputExtentFromUser ( default_extent , QgsCoordinateReferenceSystem ( \"EPSG:4326\" ), )","title":"prepare_extent_box()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.prepare_input","text":"prepare_input () Initializes plugin input widgets Source code in src/cplus_plugin/gui/qgis_cplus_main.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 def prepare_input ( self ): \"\"\"Initializes plugin input widgets\"\"\" self . prepare_extent_box () self . grid_layout = QtWidgets . QGridLayout () self . message_bar = QgsMessageBar () self . prepare_message_bar () self . progress_dialog = None self . scenario_directory = None self . help_btn . clicked . connect ( self . open_help ) self . pilot_area_btn . clicked . connect ( self . zoom_pilot_area ) self . run_scenario_btn . clicked . connect ( self . run_analysis ) self . options_btn . clicked . connect ( self . open_settings ) self . restore_scenario () self . scenario_name . textChanged . connect ( self . save_scenario ) self . scenario_description . textChanged . connect ( self . save_scenario ) self . extent_box . extentChanged . connect ( self . save_scenario ) icon_pixmap = QtGui . QPixmap ( ICON_PATH ) self . icon_la . setPixmap ( icon_pixmap ) add_layer_icon = QtGui . QIcon ( ADD_LAYER_ICON_PATH ) self . layer_add_btn . setIcon ( add_layer_icon ) remove_layer_icon = QtGui . QIcon ( REMOVE_LAYER_ICON_PATH ) self . layer_remove_btn . setIcon ( remove_layer_icon ) self . layer_add_btn . clicked . connect ( self . add_priority_layer_group ) self . layer_remove_btn . clicked . connect ( self . remove_priority_layer_group ) # Priority layers buttons self . add_pwl_btn . setIcon ( FileUtils . get_icon ( \"symbologyAdd.svg\" )) self . edit_pwl_btn . setIcon ( FileUtils . get_icon ( \"mActionToggleEditing.svg\" )) self . remove_pwl_btn . setIcon ( FileUtils . get_icon ( \"symbologyRemove.svg\" )) self . add_pwl_btn . clicked . connect ( self . add_priority_layer ) self . edit_pwl_btn . clicked . connect ( self . edit_priority_layer ) self . remove_pwl_btn . clicked . connect ( self . remove_priority_layer ) # Add priority groups list into the groups frame self . priority_groups_list = CustomTreeWidget () self . priority_groups_list . setHeaderHidden ( True ) self . priority_groups_list . setDragEnabled ( True ) self . priority_groups_list . setDragDropOverwriteMode ( True ) self . priority_groups_list . viewport () . setAcceptDrops ( True ) self . priority_groups_list . setDragDropMode ( QtWidgets . QAbstractItemView . DropOnly ) self . priority_groups_list . child_dragged_dropped . connect ( self . priority_groups_update ) layout = QtWidgets . QVBoxLayout () layout . setSpacing ( 0 ) layout . setContentsMargins ( 0 , 0 , 0 , 0 ) layout . addWidget ( self . priority_groups_list ) self . priority_groups_frame . setLayout ( layout ) # Scenario analysis variables self . analysis_scenario_name = None self . analysis_scenario_description = None self . analysis_extent = None self . analysis_implementation_models = None self . analysis_priority_layers_groups = []","title":"prepare_input()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.prepare_message_bar","text":"prepare_message_bar () Initializes the widget message bar settings Source code in src/cplus_plugin/gui/qgis_cplus_main.py 567 568 569 570 571 572 573 574 575 def prepare_message_bar ( self ): \"\"\"Initializes the widget message bar settings\"\"\" self . message_bar . setSizePolicy ( QtWidgets . QSizePolicy . Minimum , QtWidgets . QSizePolicy . Fixed ) self . grid_layout . addWidget ( self . message_bar , 0 , 0 , 1 , 1 , alignment = QtCore . Qt . AlignTop ) self . dock_widget_contents . layout () . insertLayout ( 0 , self . grid_layout )","title":"prepare_message_bar()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.priority_groups_update","text":"priority_groups_update ( target_item , selected_items ) Updates the priority groups list item with the passed selected layer items. Parameters: Name Type Description Default target_item QTreeWidgetItem The priority group tree widget item that is to be updated required selected_items list Priority layers items from the list widget required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def priority_groups_update ( self , target_item , selected_items ): \"\"\"Updates the priority groups list item with the passed selected layer items. :param target_item: The priority group tree widget item that is to be updated :type target_item: QTreeWidgetItem :param selected_items: Priority layers items from the list widget :type selected_items: list \"\"\" self . priority_groups_list . setCurrentItem ( target_item ) for item in selected_items : self . add_priority_layer_group ( target_item , item )","title":"priority_groups_update()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.priority_layers_analysis_done","text":"priority_layers_analysis_done ( model_index , model , models , success , output ) Slot that handles post calculations for the models priority layers Parameters: Name Type Description Default model_index int List index of the target model required model ImplementationModel Target implementation model required models typing.List[ImplementationModel] List of the selected implementation models required success bool Whether the scenario analysis was successful required output dict Analysis output results required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1791 1792 1793 1794 1795 1796 1797 1798 1799 1800 1801 1802 1803 1804 1805 1806 1807 1808 1809 1810 1811 1812 1813 1814 1815 def priority_layers_analysis_done ( self , model_index , model , models , success , output ): \"\"\"Slot that handles post calculations for the models priority layers :param model_index: List index of the target model :type model_index: int :param model: Target implementation model :type model: ImplementationModel :param models: List of the selected implementation models :type models: typing.List[ImplementationModel] :param success: Whether the scenario analysis was successful :type success: bool :param output: Analysis output results :type output: dict \"\"\" if output is not None and output . get ( \"OUTPUT\" ) is not None : model . path = output . get ( \"OUTPUT\" ) if model_index == len ( models ) - 1 : self . run_highest_position_analysis ()","title":"priority_layers_analysis_done()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.remove_priority_layer","text":"remove_priority_layer () Removes the current active priority layer. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 def remove_priority_layer ( self ): \"\"\"Removes the current active priority layer.\"\"\" if self . priority_layers_list . currentItem () is None : self . show_message ( tr ( \"Select first the priority \" \"weighting layer from the layers list.\" ), Qgis . Critical , ) return current_text = self . priority_layers_list . currentItem () . data ( QtCore . Qt . DisplayRole ) if current_text == \"\" : self . show_message ( tr ( \"Could not fetch the selected priority layer for editing.\" ), Qgis . Critical , ) return layer = settings_manager . find_layer_by_name ( current_text ) reply = QtWidgets . QMessageBox . warning ( self , tr ( \"QGIS CPLUS PLUGIN\" ), tr ( 'Remove the priority layer \" {} \"?' ) . format ( current_text ), QtWidgets . QMessageBox . Yes , QtWidgets . QMessageBox . No , ) if reply == QtWidgets . QMessageBox . Yes : settings_manager . delete_priority_layer ( layer . get ( \"uuid\" )) self . update_priority_layers ( update_groups = False )","title":"remove_priority_layer()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.remove_priority_layer_group","text":"remove_priority_layer_group () Remove the current select priority layer from the current priority group. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 def remove_priority_layer_group ( self ): \"\"\"Remove the current select priority layer from the current priority group.\"\"\" selected_group = self . priority_groups_list . currentItem () parent_item = selected_group . parent () if selected_group is not None else None if parent_item : priority_layer = settings_manager . find_layer_by_name ( selected_group . text ( 0 )) group_widget = self . priority_groups_list . itemWidget ( parent_item , 0 ) groups = priority_layer . get ( \"groups\" ) new_groups = [] for group in groups : if group . get ( \"name\" ) == group_widget . group . get ( \"name\" ): continue new_groups . append ( group ) priority_layer [ \"groups\" ] = new_groups settings_manager . save_priority_layer ( priority_layer ) parent_item . removeChild ( selected_group )","title":"remove_priority_layer_group()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.report_job_is_for_current_scenario","text":"report_job_is_for_current_scenario ( scenario_id ) Checks if the given scenario identifier is for the current scenario result. This is to ensure that signals raised by the report manager refer to the current scenario result object and not for old jobs. Parameters: Name Type Description Default scenario_id str Scenario identifier usually from a signal raised by the report manager. required Returns: Type Description bool True if the scenario identifier matches the current scenario object in the results, else False. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2209 2210 2211 2212 2213 2214 2215 2216 2217 2218 2219 2220 2221 2222 2223 2224 2225 2226 2227 2228 2229 2230 2231 2232 2233 2234 def report_job_is_for_current_scenario ( self , scenario_id : str ) -> bool : \"\"\"Checks if the given scenario identifier is for the current scenario result. This is to ensure that signals raised by the report manager refer to the current scenario result object and not for old jobs. :param scenario_id: Scenario identifier usually from a signal raised by the report manager. :type scenario_id: str :returns: True if the scenario identifier matches the current scenario object in the results, else False. :rtype: bool \"\"\" if self . scenario_result is None : return False current_scenario = self . scenario_result . scenario if current_scenario is None : return False if str ( current_scenario . uuid ) == scenario_id : return True return False","title":"report_job_is_for_current_scenario()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.reset_reporting_feedback","text":"reset_reporting_feedback () Creates a new reporting feedback object and reconnects the signals. We are doing this to address cases where the feedback is canceled and the same object has to be reused for subsequent report generation tasks. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2179 2180 2181 2182 2183 2184 2185 2186 2187 2188 2189 2190 2191 2192 2193 def reset_reporting_feedback ( self ): \"\"\"Creates a new reporting feedback object and reconnects the signals. We are doing this to address cases where the feedback is canceled and the same object has to be reused for subsequent report generation tasks. \"\"\" if self . reporting_feedback is not None : self . reporting_feedback . progressChanged . disconnect () self . reporting_feedback = QgsFeedback ( self ) self . reporting_feedback . progressChanged . connect ( self . on_reporting_progress_changed )","title":"reset_reporting_feedback()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.restore_scenario","text":"restore_scenario () Update the first tab input with the last scenario details Source code in src/cplus_plugin/gui/qgis_cplus_main.py 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 def restore_scenario ( self ): \"\"\"Update the first tab input with the last scenario details\"\"\" scenario_name = settings_manager . get_value ( Settings . SCENARIO_NAME ) scenario_description = settings_manager . get_value ( Settings . SCENARIO_DESCRIPTION ) extent = settings_manager . get_value ( Settings . SCENARIO_EXTENT ) self . scenario_name . setText ( scenario_name ) if scenario_name is not None else None self . scenario_description . setText ( scenario_description ) if scenario_description is not None else None if extent is not None : extent_rectangle = QgsRectangle ( float ( extent [ 0 ]), float ( extent [ 2 ]), float ( extent [ 1 ]), float ( extent [ 3 ]) ) self . extent_box . setOutputExtentFromUser ( extent_rectangle , QgsCoordinateReferenceSystem ( \"EPSG:4326\" ), )","title":"restore_scenario()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.run_analysis","text":"run_analysis () Runs the plugin analysis Source code in src/cplus_plugin/gui/qgis_cplus_main.py 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 def run_analysis ( self ): \"\"\"Runs the plugin analysis\"\"\" extent_list = PILOT_AREA_EXTENT [ \"coordinates\" ] default_extent = QgsRectangle ( extent_list [ 0 ], extent_list [ 2 ], extent_list [ 1 ], extent_list [ 3 ] ) passed_extent = self . extent_box . outputExtent () contains = default_extent == passed_extent or default_extent . contains ( passed_extent ) self . analysis_scenario_name = self . scenario_name . text () self . analysis_scenario_description = self . scenario_description . text () self . position_feedback = QgsProcessingFeedback () self . processing_context = QgsProcessingContext () for group in settings_manager . get_priority_groups (): group_layer_dict = { \"name\" : group . get ( \"name\" ), \"value\" : group . get ( \"value\" ), \"layers\" : [], } for layer in settings_manager . get_priority_layers (): group_names = [ group . get ( \"name\" ) for group in layer . get ( \"groups\" , [])] if group . get ( \"name\" ) in group_names : group_layer_dict [ \"layers\" ] . append ( layer . get ( \"name\" )) self . analysis_priority_layers_groups . append ( group_layer_dict ) self . analysis_implementation_models = [ item . implementation_model for item in self . implementation_model_widget . selected_im_items () ] base_dir = settings_manager . get_value ( Settings . BASE_DIR ) if self . analysis_scenario_name == \"\" or self . analysis_scenario_name is None : self . show_message ( tr ( f \"Scenario name cannot be blank.\" ), level = Qgis . Critical , ) return if ( self . analysis_scenario_description == \"\" or self . analysis_scenario_description is None ): self . show_message ( tr ( f \"Scenario description cannot be blank.\" ), level = Qgis . Critical , ) return if ( self . analysis_implementation_models == [] or self . analysis_implementation_models is None ): self . show_message ( tr ( \"Select at least one implementation models from step two.\" ), level = Qgis . Critical , ) return if not contains : self . show_message ( tr ( f \"Selected area of interest is outside the pilot area.\" ), level = Qgis . Critical , ) default_ext = ( f \" { default_extent . xMinimum () } , { default_extent . xMaximum () } ,\" f \" { default_extent . yMinimum () } , { default_extent . yMaximum () } \" ) log ( f \"Outside the pilot area, passed extent \" f \" { passed_extent } \" f \"default extent { default_ext } \" ) return if base_dir is None : self . show_message ( tr ( f \"Plugin base data directory is not set! \" f \"Go to plugin settings in order to set it.\" ), level = Qgis . Critial , ) return self . analysis_extent = SpatialExtent ( bbox = [ passed_extent . xMinimum (), passed_extent . xMaximum (), passed_extent . yMinimum (), passed_extent . yMaximum (), ] ) try : self . scenario_directory = ( f \" { base_dir } /\" f 'scenario_ { datetime . datetime . now () . strftime ( \"%Y_%m_ %d _%H_%M_%S\" ) } ' ) FileUtils . create_new_dir ( self . scenario_directory ) # Creates and opens the progress dialog for the analysis self . progress_dialog = ProgressDialog ( \"Raster calculation\" , \"implementation models\" , 0 , 100 , main_widget = self , ) self . progress_dialog . run_dialog () self . progress_dialog . scenario_name = \"\" self . progress_dialog . change_status_message ( tr ( \"Raster calculation\" ), tr ( \"models\" ) ) except Exception as err : self . show_message ( tr ( \"An error occurred when opening the progress dialog, \" \"check logs for more information\" ), level = Qgis . Info , ) log ( tr ( \"An error occurred when opening the progress dialog for \" 'scenario analysis, error message \" {} \"' . format ( err ) ) ) self . processing_cancelled = False self . run_pathways_analysis ( self . analysis_implementation_models , self . analysis_priority_layers_groups , self . analysis_extent , )","title":"run_analysis()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.run_highest_position_analysis","text":"run_highest_position_analysis () Runs the highest position analysis which is last step in scenario analysis. Uses the models set by the current ongoing analysis. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 def run_highest_position_analysis ( self ): \"\"\"Runs the highest position analysis which is last step in scenario analysis. Uses the models set by the current ongoing analysis. \"\"\" if self . processing_cancelled : # Will not proceed if processing has been cancelled by the user return passed_extent_box = self . analysis_extent . bbox passed_extent = QgsRectangle ( passed_extent_box [ 0 ], passed_extent_box [ 2 ], passed_extent_box [ 1 ], passed_extent_box [ 3 ], ) scenario = Scenario ( uuid = uuid . uuid4 (), name = self . analysis_scenario_name , description = self . analysis_scenario_description , extent = self . analysis_extent , models = self . analysis_implementation_models , priority_layer_groups = self . analysis_priority_layers_groups , ) self . scenario_result = ScenarioResult ( scenario = scenario , ) try : layers = {} self . progress_dialog . progress_bar . setMinimum ( 0 ) self . progress_dialog . progress_bar . setMaximum ( 100 ) self . progress_dialog . progress_bar . setValue ( 0 ) self . progress_dialog . analysis_finished_message = tr ( \"Analysis finished\" ) self . progress_dialog . scenario_name = tr ( f \"<b> { scenario . name } </b>\" ) self . progress_dialog . scenario_id = str ( scenario . uuid ) self . progress_dialog . change_status_message ( tr ( \"Calculating the highest position\" ) ) self . position_feedback . progressChanged . connect ( self . update_progress_bar ) for model in self . analysis_implementation_models : if model . path is not None and model . path is not \"\" : raster_layer = QgsRasterLayer ( model . path , model . name ) layers [ model . name ] = ( raster_layer if raster_layer is not None else None ) else : for pathway in model . pathways : layers [ model . name ] = QgsRasterLayer ( pathway . path ) source_crs = QgsCoordinateReferenceSystem ( \"EPSG:4326\" ) dest_crs = list ( layers . values ())[ 0 ] . crs () if len ( layers ) > 0 else source_crs transform = QgsCoordinateTransform ( source_crs , dest_crs , QgsProject . instance () ) transformed_extent = transform . transformBoundingBox ( passed_extent ) extent_string = ( f \" { transformed_extent . xMinimum () } , { transformed_extent . xMaximum () } ,\" f \" { transformed_extent . yMinimum () } , { transformed_extent . yMaximum () } \" f \" [ { dest_crs . authid () } ]\" ) output_file = ( f \" { self . scenario_directory } /\" f \" { SCENARIO_OUTPUT_FILE_NAME } _ { str ( scenario . uuid )[: 4 ] } .tif\" ) # Preparing the input rasters for the highest position # analysis in a correct order models_names = [ model . name for model in self . analysis_implementation_models ] all_models_names = [ model . name for model in self . implementation_model_widget . implementation_models () ] sources = [] absolute_path = f \" { FileUtils . plugin_dir () } /app_data/layers/null_raster.tif\" null_raster_file = os . path . normpath ( absolute_path ) for model_name in all_models_names : if model_name in models_names : sources . append ( layers [ model_name ] . source ()) else : sources . append ( null_raster_file ) log ( f \"Layers sources { [ Path ( source ) . stem for source in sources ] } \" ) alg_params = { \"IGNORE_NODATA\" : True , \"INPUT_RASTERS\" : sources , \"EXTENT\" : extent_string , \"OUTPUT_NODATA_VALUE\" : - 9999 , \"REFERENCE_LAYER\" : list ( layers . values ())[ 0 ] if len ( layers ) >= 1 else None , \"OUTPUT\" : output_file , } log ( f \"Used parameters for highest position analysis { alg_params } \" ) alg = QgsApplication . processingRegistry () . algorithmById ( \"native:highestpositioninrasterstack\" ) # self.processing_cancelled = False self . task = QgsProcessingAlgRunnerTask ( alg , alg_params , self . processing_context , feedback = self . position_feedback , ) self . task . executed . connect ( self . scenario_results ) QgsApplication . taskManager () . addTask ( self . task ) except Exception as err : self . show_message ( tr ( \"An error occurred when running analysis task, \" \"check logs for more information\" ), level = Qgis . Info , ) log ( tr ( \"An error occurred when running task for \" 'scenario analysis, error message \" {} \"' . format ( str ( err )) ) )","title":"run_highest_position_analysis()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.run_models_analysis","text":"run_models_analysis ( models , priority_layers_groups , extent ) Runs the required model analysis on the passed implementation models. Parameters: Name Type Description Default models typing.List[ImplementationModel] List of the selected implementation models required priority_layers_groups dict Used priority layers groups and their values required extent SpatialExtent selected extent from user required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 def run_models_analysis ( self , models , priority_layers_groups , extent ): \"\"\"Runs the required model analysis on the passed implementation models. :param models: List of the selected implementation models :type models: typing.List[ImplementationModel] :param priority_layers_groups: Used priority layers groups and their values :type priority_layers_groups: dict :param extent: selected extent from user :type extent: SpatialExtent \"\"\" if self . processing_cancelled : # Will not proceed if processing has been cancelled by the user return False model_count = 0 priority_function = partial ( self . run_normalization_analysis , models , priority_layers_groups , extent ) main_task = QgsTask . fromFunction ( \"Running main functions\" , self . main_task , on_finished = priority_function ) previous_sub_tasks = [] self . progress_dialog . analysis_finished_message = tr ( \"Processing calculations\" ) self . progress_dialog . scenario_name = tr ( \"implementation models\" ) for model in models : new_ims_directory = f \" { self . scenario_directory } /implementation_models\" FileUtils . create_new_dir ( new_ims_directory ) file_name = clean_filename ( model . name . replace ( \" \" , \"_\" )) layers = [] if not model . pathways and ( model . path is None and model . path is \"\" ): self . show_message ( tr ( f \"No defined model pathways or a\" f \" model layer for the model { model . name } \" ), level = Qgis . Critical , ) log ( f \"No defined model pathways or a \" f \"model layer for the model { model . name } \" ) main_task . cancel () return False output_file = f \" { new_ims_directory } / { file_name } _ { str ( uuid . uuid4 ())[: 4 ] } .tif\" # Due to the implementation models base class # model only one of the following blocks will be executed, # the implementation model either contain a path or # pathways if model . path is not None and model . path is not \"\" : layers = [ model . path ] for pathway in model . pathways : layers . append ( pathway . path ) analysis_done = partial ( self . model_analysis_done , model_count , model , models , extent , priority_layers_groups , ) # Actual processing calculation alg_params = { \"IGNORE_NODATA\" : True , \"INPUT\" : layers , \"EXTENT\" : extent , \"OUTPUT_NODATA_VALUE\" : - 9999 , \"REFERENCE_LAYER\" : layers [ 0 ] if len ( layers ) > 0 else None , \"STATISTIC\" : 0 , # Sum \"OUTPUT\" : output_file , } log ( f \"Used parameters for \" f \"implementation models generation: { alg_params } \" ) alg = QgsApplication . processingRegistry () . algorithmById ( \"native:cellstatistics\" ) self . task = QgsProcessingAlgRunnerTask ( alg , alg_params , self . processing_context , self . position_feedback ) self . position_feedback . progressChanged . connect ( self . update_progress_bar ) main_task . addSubTask ( self . task , previous_sub_tasks , QgsTask . ParentDependsOnSubTask ) previous_sub_tasks . append ( self . task ) self . task . executed . connect ( analysis_done ) model_count = model_count + 1 QgsApplication . taskManager () . addTask ( main_task )","title":"run_models_analysis()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.run_normalization_analysis","text":"run_normalization_analysis ( models , priority_layers_groups , extent ) Runs the normalization analysis on the models layers, adjusting band values measured on different scale, the resulting scale is computed using the below formula Normalized_Model = (Carbon coefficient + Suitability index) * ( (Model layer value) - (Model band minimum value)) / (Model band maximum value - Model band minimum value)) If the carbon coefficient and suitability index are both zero then the computation won't take them into account in the normalization calculation. Parameters: Name Type Description Default models typing.List[ImplementationModel] List of the analyzed implementation models required priority_layers_groups dict Used priority layers groups and their values required extent str selected extent from user required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 def run_normalization_analysis ( self , models , priority_layers_groups , extent ): \"\"\"Runs the normalization analysis on the models layers, adjusting band values measured on different scale, the resulting scale is computed using the below formula Normalized_Model = (Carbon coefficient + Suitability index) * ( (Model layer value) - (Model band minimum value)) / (Model band maximum value - Model band minimum value)) If the carbon coefficient and suitability index are both zero then the computation won't take them into account in the normalization calculation. :param models: List of the analyzed implementation models :type models: typing.List[ImplementationModel] :param priority_layers_groups: Used priority layers groups and their values :type priority_layers_groups: dict :param extent: selected extent from user :type extent: str \"\"\" if self . processing_cancelled : # Will not proceed if processing has been cancelled by the user return False model_count = 0 priority_function = partial ( self . run_priority_analysis , models , priority_layers_groups , extent ) main_task = QgsTask . fromFunction ( \"Running normalization\" , self . main_task , on_finished = priority_function ) previous_sub_tasks = [] self . progress_dialog . analysis_finished_message = tr ( \"Normalization\" ) self . progress_dialog . scenario_name = tr ( \"implementation models\" ) for model in models : if model . path is None or model . path is \"\" : if not self . processing_cancelled : self . show_message ( tr ( f \"Problem when running models normalization, \" f \"there is no map layer for the model { model . name } \" ), level = Qgis . Critical , ) log ( f \"Problem when running models normalization, \" f \"there is no map layer for the model { model . name } \" ) else : # If the user cancelled the processing self . show_message ( tr ( f \"Processing has been cancelled by the user.\" ), level = Qgis . Critical , ) log ( f \"Processing has been cancelled by the user.\" ) main_task . cancel () return False basenames = [] layers = [] new_ims_directory = f \" { self . scenario_directory } /normalized_ims\" FileUtils . create_new_dir ( new_ims_directory ) file_name = clean_filename ( model . name . replace ( \" \" , \"_\" )) output_file = f \" { new_ims_directory } / { file_name } _ { str ( uuid . uuid4 ())[: 4 ] } .tif\" model_layer = QgsRasterLayer ( model . path , model . name ) provider = model_layer . dataProvider () band_statistics = provider . bandStatistics ( 1 ) min_value = band_statistics . minimumValue max_value = band_statistics . maximumValue layer_name = Path ( model . path ) . stem layers . append ( model . path ) carbon_coefficient = float ( settings_manager . get_value ( Settings . CARBON_COEFFICIENT , default = 0.0 ) ) suitability_index = float ( settings_manager . get_value ( Settings . PATHWAY_SUITABILITY_INDEX , default = 0 ) ) normalization_index = carbon_coefficient + suitability_index if normalization_index > 0 : expression = ( f \" { normalization_index } * \" f '(\" { layer_name } @1\" - { min_value } ) /' f \" ( { max_value } - { min_value } )\" ) else : expression = ( f '(\" { layer_name } @1\" - { min_value } ) /' f \" ( { max_value } - { min_value } )\" ) analysis_done = partial ( self . normalization_analysis_done , model_count , model , models , extent , priority_layers_groups , ) # Actual processing calculation alg_params = { \"CELLSIZE\" : 0 , \"CRS\" : None , \"EXPRESSION\" : expression , \"EXTENT\" : extent , \"LAYERS\" : layers , \"OUTPUT\" : output_file , } log ( f \"Used parameters for normalization of the models: { alg_params } \" ) alg = QgsApplication . processingRegistry () . algorithmById ( \"qgis:rastercalculator\" ) self . task = QgsProcessingAlgRunnerTask ( alg , alg_params , self . processing_context , self . position_feedback ) self . position_feedback . progressChanged . connect ( self . update_progress_bar ) main_task . addSubTask ( self . task , previous_sub_tasks , QgsTask . ParentDependsOnSubTask ) previous_sub_tasks . append ( self . task ) self . task . executed . connect ( analysis_done ) model_count = model_count + 1 QgsApplication . taskManager () . addTask ( main_task )","title":"run_normalization_analysis()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.run_pathways_analysis","text":"run_pathways_analysis ( models , priority_layers_groups , extent ) Runs the required model pathways analysis on the passed implementation models. The analysis involves adding the pathways carbon layers into the pathway layer. If the pathway layer has more than one carbon layer, the resulting weighted pathway will contain the sum of the pathway layer values with the average of the pathway carbon layers values. Parameters: Name Type Description Default models typing.List[ImplementationModel] List of the selected implementation models required priority_layers_groups dict Used priority layers groups and their values required extent SpatialExtent The selected extent from user required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 def run_pathways_analysis ( self , models , priority_layers_groups , extent ): \"\"\"Runs the required model pathways analysis on the passed implementation models. The analysis involves adding the pathways carbon layers into the pathway layer. If the pathway layer has more than one carbon layer, the resulting weighted pathway will contain the sum of the pathway layer values with the average of the pathway carbon layers values. :param models: List of the selected implementation models :type models: typing.List[ImplementationModel] :param priority_layers_groups: Used priority layers groups and their values :type priority_layers_groups: dict :param extent: The selected extent from user :type extent: SpatialExtent \"\"\" if self . processing_cancelled : # Will not proceed if processing has been cancelled by the user return False models_function = partial ( self . run_pathways_normalization , models , priority_layers_groups , extent ) main_task = QgsTask . fromFunction ( \"Main task for running pathways combination with carbon layers\" , self . main_task , on_finished = models_function , ) main_task . taskCompleted . connect ( models_function ) previous_sub_tasks = [] self . progress_dialog . analysis_finished_message = tr ( \"Calculating carbon layers\" ) self . progress_dialog . scenario_name = tr ( f \"models pathways\" ) pathways = [] models_paths = [] for model in models : if not model . pathways and ( model . path is None or model . path is \"\" ): self . show_message ( tr ( f \"No defined model pathways or a\" f \" model layer for the model { model . name } \" ), level = Qgis . Critical , ) log ( f \"No defined model pathways or a \" f \"model layer for the model { model . name } \" ) main_task . cancel () return False for pathway in model . pathways : if not ( pathway in pathways ): pathways . append ( pathway ) if model . path is not None and model . path is not \"\" : models_paths . append ( model . path ) if not pathways and len ( models_paths ) > 0 : self . run_pathways_normalization ( models , priority_layers_groups , extent ) return new_carbon_directory = f \" { self . scenario_directory } /pathways_carbon_layers\" suitability_index = float ( settings_manager . get_value ( Settings . PATHWAY_SUITABILITY_INDEX , default = 0 ) ) carbon_coefficient = float ( settings_manager . get_value ( Settings . CARBON_COEFFICIENT , default = 0.0 ) ) base_dir = settings_manager . get_value ( Settings . BASE_DIR ) FileUtils . create_new_dir ( new_carbon_directory ) pathway_count = 0 for pathway in pathways : basenames = [] layers = [] path_basename = Path ( pathway . path ) . stem layers . append ( pathway . path ) file_name = clean_filename ( pathway . name . replace ( \" \" , \"_\" )) output_file = ( f \" { new_carbon_directory } / { file_name } _ { str ( uuid . uuid4 ())[: 4 ] } .tif\" ) if suitability_index > 0 : basenames . append ( f ' { suitability_index } * \" { path_basename } @1\"' ) else : basenames . append ( f '\" { path_basename } @1\"' ) carbon_names = [] for carbon_path in pathway . carbon_paths : if base_dir not in carbon_path : carbon_path = f \" { base_dir } / { NCS_CARBON_SEGMENT } / { carbon_path } \" carbon_full_path = Path ( carbon_path ) if not carbon_full_path . exists (): continue layers . append ( carbon_path ) carbon_names . append ( f '\" { carbon_full_path . stem } @1\"' ) if len ( carbon_names ) == 1 and carbon_coefficient > 0 : basenames . append ( f \" { carbon_coefficient } * ( { carbon_names [ 0 ] } )\" ) # Setting up calculation to use carbon layers average when # a pathway has more than one carbon layer. if len ( carbon_names ) > 1 and carbon_coefficient > 0 : basenames . append ( f \" { carbon_coefficient } * (\" f '( { \" + \" . join ( carbon_names ) } ) / ' f \" { len ( pathway . carbon_paths ) } )\" ) expression = \" + \" . join ( basenames ) box = QgsRectangle ( float ( extent . bbox [ 0 ]), float ( extent . bbox [ 2 ]), float ( extent . bbox [ 1 ]), float ( extent . bbox [ 3 ]), ) source_crs = QgsCoordinateReferenceSystem ( \"EPSG:4326\" ) dest_crs = QgsRasterLayer ( layers [ 0 ]) . crs () transform = QgsCoordinateTransform ( source_crs , dest_crs , QgsProject . instance () ) transformed_extent = transform . transformBoundingBox ( box ) extent_string = ( f \" { transformed_extent . xMinimum () } , { transformed_extent . xMaximum () } ,\" f \" { transformed_extent . yMinimum () } , { transformed_extent . yMaximum () } \" f \" [ { dest_crs . authid () } ]\" ) analysis_done = partial ( self . pathways_analysis_done , pathway_count , models , extent_string , priority_layers_groups , pathways , pathway , ( pathway_count == len ( pathways ) - 1 ), ) if carbon_coefficient <= 0 and suitability_index <= 0 : self . run_pathways_normalization ( models , priority_layers_groups , extent_string ) return # Actual processing calculation alg_params = { \"CELLSIZE\" : 0 , \"CRS\" : None , \"EXPRESSION\" : expression , \"EXTENT\" : extent_string , \"LAYERS\" : layers , \"OUTPUT\" : output_file , } log ( f \"Used parameters for combining pathways\" f \" and carbon layers generation: { alg_params } \" ) alg = QgsApplication . processingRegistry () . algorithmById ( \"qgis:rastercalculator\" ) self . task = QgsProcessingAlgRunnerTask ( alg , alg_params , self . processing_context , self . position_feedback ) self . position_feedback . progressChanged . connect ( self . update_progress_bar ) main_task . addSubTask ( self . task , previous_sub_tasks , QgsTask . ParentDependsOnSubTask ) previous_sub_tasks . append ( self . task ) self . task . executed . connect ( analysis_done ) pathway_count = pathway_count + 1 QgsApplication . taskManager () . addTask ( main_task )","title":"run_pathways_analysis()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.run_pathways_normalization","text":"run_pathways_normalization ( models , priority_layers_groups , extent ) Runs the normalization on the models pathways layers, adjusting band values measured on different scale, the resulting scale is computed using the below formula Normalized_Pathway = (Carbon coefficient + Suitability index) * ( (Model layer value) - (Model band minimum value)) / (Model band maximum value - Model band minimum value)) If the carbon coefficient and suitability index are both zero then the computation won't take them into account in the normalization calculation. Parameters: Name Type Description Default models typing.List[ImplementationModel] List of the analyzed implementation models required priority_layers_groups dict Used priority layers groups and their values required extent str selected extent from user required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 def run_pathways_normalization ( self , models , priority_layers_groups , extent ): \"\"\"Runs the normalization on the models pathways layers, adjusting band values measured on different scale, the resulting scale is computed using the below formula Normalized_Pathway = (Carbon coefficient + Suitability index) * ( (Model layer value) - (Model band minimum value)) / (Model band maximum value - Model band minimum value)) If the carbon coefficient and suitability index are both zero then the computation won't take them into account in the normalization calculation. :param models: List of the analyzed implementation models :type models: typing.List[ImplementationModel] :param priority_layers_groups: Used priority layers groups and their values :type priority_layers_groups: dict :param extent: selected extent from user :type extent: str \"\"\" if self . processing_cancelled : # Will not proceed if processing has been cancelled by the user return False pathway_count = 0 priority_function = partial ( self . run_models_analysis , models , priority_layers_groups , extent ) main_task = QgsTask . fromFunction ( \"Running pathways normalization\" , self . main_task , on_finished = priority_function , ) previous_sub_tasks = [] self . progress_dialog . analysis_finished_message = tr ( \"Normalization\" ) self . progress_dialog . scenario_name = tr ( \"pathways\" ) pathways = [] models_paths = [] for model in models : if not model . pathways and ( model . path is None or model . path is \"\" ): self . show_message ( tr ( f \"No defined model pathways or a\" f \" model layer for the model { model . name } \" ), level = Qgis . Critical , ) log ( f \"No defined model pathways or a \" f \"model layer for the model { model . name } \" ) main_task . cancel () return False for pathway in model . pathways : if not ( pathway in pathways ): pathways . append ( pathway ) if model . path is not None and model . path is not \"\" : models_paths . append ( model . path ) if not pathways and len ( models_paths ) > 0 : self . run_models_analysis ( models , priority_layers_groups , extent ) return carbon_coefficient = float ( settings_manager . get_value ( Settings . CARBON_COEFFICIENT , default = 0.0 ) ) suitability_index = float ( settings_manager . get_value ( Settings . PATHWAY_SUITABILITY_INDEX , default = 0 ) ) normalization_index = carbon_coefficient + suitability_index for pathway in pathways : layers = [] new_ims_directory = f \" { self . scenario_directory } /normalized_pathways\" FileUtils . create_new_dir ( new_ims_directory ) file_name = clean_filename ( pathway . name . replace ( \" \" , \"_\" )) output_file = f \" { new_ims_directory } / { file_name } _ { str ( uuid . uuid4 ())[: 4 ] } .tif\" pathway_layer = QgsRasterLayer ( pathway . path , pathway . name ) provider = pathway_layer . dataProvider () band_statistics = provider . bandStatistics ( 1 ) min_value = band_statistics . minimumValue max_value = band_statistics . maximumValue layer_name = Path ( pathway . path ) . stem layers . append ( pathway . path ) if normalization_index > 0 : expression = ( f \" { normalization_index } * \" f '(\" { layer_name } @1\" - { min_value } ) /' f \" ( { max_value } - { min_value } )\" ) else : expression = ( f '(\" { layer_name } @1\" - { min_value } ) /' f \" ( { max_value } - { min_value } )\" ) analysis_done = partial ( self . pathways_normalization_done , pathway_count , models , extent , priority_layers_groups , pathways , pathway , ( pathway_count == len ( pathways ) - 1 ), ) # Actual processing calculation alg_params = { \"CELLSIZE\" : 0 , \"CRS\" : None , \"EXPRESSION\" : expression , \"EXTENT\" : extent , \"LAYERS\" : layers , \"OUTPUT\" : output_file , } log ( f \"Used parameters for normalization of the pathways: { alg_params } \" ) alg = QgsApplication . processingRegistry () . algorithmById ( \"qgis:rastercalculator\" ) self . task = QgsProcessingAlgRunnerTask ( alg , alg_params , self . processing_context , self . position_feedback ) self . position_feedback . progressChanged . connect ( self . update_progress_bar ) main_task . addSubTask ( self . task , previous_sub_tasks , QgsTask . ParentDependsOnSubTask ) previous_sub_tasks . append ( self . task ) self . task . executed . connect ( analysis_done ) pathway_count = pathway_count + 1 QgsApplication . taskManager () . addTask ( main_task )","title":"run_pathways_normalization()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.run_priority_analysis","text":"run_priority_analysis ( models , priority_layers_groups , extent ) Runs the required model analysis on the passed implementation models Parameters: Name Type Description Default models typing.List[ImplementationModel] List of the selected implementation models required priority_layers_groups dict Used priority layers groups and their values required extent SpatialExtent selected extent from user required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740 1741 1742 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1765 1766 1767 1768 1769 1770 1771 1772 1773 1774 1775 1776 1777 1778 1779 1780 1781 1782 1783 1784 1785 1786 1787 1788 1789 def run_priority_analysis ( self , models , priority_layers_groups , extent ): \"\"\"Runs the required model analysis on the passed implementation models :param models: List of the selected implementation models :type models: typing.List[ImplementationModel] :param priority_layers_groups: Used priority layers groups and their values :type priority_layers_groups: dict :param extent: selected extent from user :type extent: SpatialExtent \"\"\" model_count = 0 main_task = QgsTask . fromFunction ( \"Running main task for priority layers weighting\" , self . main_task , on_finished = self . run_highest_position_analysis , ) main_task . taskCompleted . connect ( self . run_highest_position_analysis ) previous_sub_tasks = [] self . progress_dialog . analysis_finished_message = tr ( f \"Weighting\" ) self . progress_dialog . scenario_name = tr ( f \"implementation models\" ) for model in models : if model . path is None or model . path is \"\" : self . show_message ( tr ( f \"Problem when running models weighting, \" f \"there is no map layer for the model { model . name } \" ), level = Qgis . Critical , ) log ( f \"Problem when running models normalization, \" f \"there is no map layer for the model { model . name } \" ) main_task . cancel () return False basenames = [] layers = [] selected_layers = [] analysis_done = partial ( self . priority_layers_analysis_done , model_count , model , models ) layers . append ( model . path ) basenames . append ( f '\" { Path ( model . path ) . stem } @1\"' ) if not any ( priority_layers_groups ): log ( f \"There are defined priority layers in groups,\" f \" skipping models weighting step.\" ) self . run_highest_position_analysis () return if model . priority_layers is None or model . priority_layers is []: log ( f \"There are no associated \" f \"priority weighting layers for model { model . name } \" ) continue settings_model = settings_manager . get_implementation_model ( str ( model . uuid )) for layer in settings_model . priority_layers : settings_layer = settings_manager . get_priority_layer ( layer . get ( \"uuid\" )) pwl = settings_layer . get ( \"path\" ) missing_pwl_message = ( f \"Path { pwl } for priority \" f \"weighting layer { layer . get ( 'name' ) } \" f \"doesn't exist, skipping the layer \" f \"from the model { model . name } weighting.\" ) if pwl is None : log ( missing_pwl_message ) continue pwl_path = Path ( pwl ) if not pwl_path . exists (): log ( missing_pwl_message ) continue path_basename = pwl_path . stem for priority_layer in settings_manager . get_priority_layers (): if priority_layer . get ( \"name\" ) == layer . get ( \"name\" ): for group in priority_layer . get ( \"groups\" , []): value = group . get ( \"value\" ) coefficient = float ( value ) if coefficient > 0 : if pwl not in layers : layers . append ( pwl ) basenames . append ( f '( { coefficient } *\" { path_basename } @1\")' ) if basenames is []: return new_ims_directory = f \" { self . scenario_directory } /weighted_ims\" FileUtils . create_new_dir ( new_ims_directory ) file_name = clean_filename ( model . name . replace ( \" \" , \"_\" )) output_file = f \" { new_ims_directory } / { file_name } _ { str ( uuid . uuid4 ())[: 4 ] } .tif\" expression = \" + \" . join ( basenames ) # Actual processing calculation alg_params = { \"CELLSIZE\" : 0 , \"CRS\" : None , \"EXPRESSION\" : expression , \"EXTENT\" : extent , \"LAYERS\" : layers , \"OUTPUT\" : output_file , } log ( f \" Used parameters for calculating weighting models { alg_params } \" ) alg = QgsApplication . processingRegistry () . algorithmById ( \"qgis:rastercalculator\" ) self . task = QgsProcessingAlgRunnerTask ( alg , alg_params , self . processing_context , self . position_feedback ) self . position_feedback . progressChanged . connect ( self . update_progress_bar ) main_task . addSubTask ( self . task , previous_sub_tasks , QgsTask . ParentDependsOnSubTask ) previous_sub_tasks . append ( self . task ) self . task . executed . connect ( analysis_done ) model_count = model_count + 1 QgsApplication . taskManager () . addTask ( main_task )","title":"run_priority_analysis()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.run_report","text":"run_report () Run report generation. This should be called after the analysis is complete. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2144 2145 2146 2147 2148 2149 2150 2151 2152 2153 2154 2155 2156 2157 2158 2159 2160 2161 2162 2163 2164 2165 2166 def run_report ( self ): \"\"\"Run report generation. This should be called after the analysis is complete. \"\"\" if self . processing_cancelled : # Will not proceed if processing has been cancelled by the user return if self . scenario_result is None : log ( \"Cannot run report generation, scenario result is \" \"not defined\" , info = False , ) return self . reset_reporting_feedback () submit_result = self . report_manager . generate ( self . scenario_result , self . reporting_feedback ) if not submit_result . status : msg = self . tr ( \"Unable to submit report request for scenario\" ) self . show_message ( f \" { msg } { self . scenario_result . scenario . name } .\" )","title":"run_report()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.save_scenario","text":"save_scenario () Save current scenario details into settings Source code in src/cplus_plugin/gui/qgis_cplus_main.py 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 def save_scenario ( self ): \"\"\"Save current scenario details into settings\"\"\" scenario_name = self . scenario_name . text () scenario_description = self . scenario_description . text () extent = self . extent_box . outputExtent () extent_box = [ extent . xMinimum (), extent . xMaximum (), extent . yMinimum (), extent . yMaximum (), ] settings_manager . set_value ( Settings . SCENARIO_NAME , scenario_name ) settings_manager . set_value ( Settings . SCENARIO_DESCRIPTION , scenario_description ) settings_manager . set_value ( Settings . SCENARIO_EXTENT , extent_box )","title":"save_scenario()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.scenario_results","text":"scenario_results ( success , output ) Called when the task ends. Sets the progress bar to 100 if it finished. Parameters: Name Type Description Default success bool Whether the scenario analysis was successful required output dict Analysis output results required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1835 1836 1837 1838 1839 1840 1841 1842 1843 1844 1845 1846 1847 1848 1849 1850 1851 1852 1853 1854 def scenario_results ( self , success , output ): \"\"\"Called when the task ends. Sets the progress bar to 100 if it finished. :param success: Whether the scenario analysis was successful :type success: bool :param output: Analysis output results :type output: dict \"\"\" if output is not None : self . update_progress_bar ( 100 ) self . scenario_result . analysis_output = output self . scenario_result . state = ScenarioState . FINISHED self . analysis_finished . emit ( self . scenario_result ) else : self . progress_dialog . change_status_message ( \"No valid output from the processing results.\" ) log ( f \"No valid output from the processing results.\" )","title":"scenario_results()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.show_message","text":"show_message ( message , level = Qgis . Warning ) Shows message on the main widget message bar. Parameters: Name Type Description Default message str Text message required level Qgis.MessageLevel Message level type Warning Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2051 2052 2053 2054 2055 2056 2057 2058 2059 2060 2061 def show_message ( self , message , level = Qgis . Warning ): \"\"\"Shows message on the main widget message bar. :param message: Text message :type message: str :param level: Message level type :type level: Qgis.MessageLevel \"\"\" self . message_bar . clearWidgets () self . message_bar . pushMessage ( message , level = level )","title":"show_message()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.transform_extent","text":"transform_extent ( extent , source_crs , dest_crs ) Transforms the passed extent into the destination crs :param extent: Target extent Parameters: Name Type Description Default source_crs QgsCoordinateReferenceSystem Source CRS of the passed extent required dest_crs QgsCoordinateReferenceSystem Destination CRS required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 def transform_extent ( self , extent , source_crs , dest_crs ): \"\"\"Transforms the passed extent into the destination crs :param extent: Target extent :type extent: QgsRectangle :param source_crs: Source CRS of the passed extent :type source_crs: QgsCoordinateReferenceSystem :param dest_crs: Destination CRS :type dest_crs: QgsCoordinateReferenceSystem \"\"\" transform = QgsCoordinateTransform ( source_crs , dest_crs , QgsProject . instance ()) transformed_extent = transform . transformBoundingBox ( extent ) return transformed_extent","title":"transform_extent()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.update_message_bar","text":"update_message_bar ( message ) Changes the message in the message bar item. Parameters: Name Type Description Default message str Message to be updated required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2042 2043 2044 2045 2046 2047 2048 2049 def update_message_bar ( self , message ): \"\"\"Changes the message in the message bar item. :param message: Message to be updated :type message: str \"\"\" message_bar_item = self . message_bar . createMessage ( message ) self . message_bar . pushWidget ( message_bar_item , Qgis . Info )","title":"update_message_bar()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.update_priority_layers","text":"update_priority_layers ( update_groups = True ) Updates the priority weighting layers list in the UI. Parameters: Name Type Description Default update_groups bool Whether to update the priority groups list or not True Source code in src/cplus_plugin/gui/qgis_cplus_main.py 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 def update_priority_layers ( self , update_groups = True ): \"\"\"Updates the priority weighting layers list in the UI. :param update_groups: Whether to update the priority groups list or not :type update_groups: bool \"\"\" self . priority_layers_list . clear () for layer in settings_manager . get_priority_layers (): item = QtWidgets . QListWidgetItem () item . setData ( QtCore . Qt . DisplayRole , layer . get ( \"name\" )) item . setData ( QtCore . Qt . UserRole , layer . get ( \"uuid\" )) self . priority_layers_list . addItem ( item ) if update_groups : for index in range ( self . priority_groups_list . topLevelItemCount ()): group = self . priority_groups_list . topLevelItem ( index ) if group . text ( 0 ) in layer . get ( \"groups\" ): self . add_priority_layer_group ( group , item ) else : group_children = group . takeChildren () children = [] for child in group_children : if child . text ( 0 ) == layer . get ( \"name\" ): continue children . append ( child ) group . addChildren ( children )","title":"update_priority_layers()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.update_progress_bar","text":"update_progress_bar ( value ) Sets the value of the progress bar Parameters: Name Type Description Default value float Value to be set on the progress bar required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2030 2031 2032 2033 2034 2035 2036 2037 2038 2039 2040 def update_progress_bar ( self , value ): \"\"\"Sets the value of the progress bar :param value: Value to be set on the progress bar :type value: float \"\"\" if self . progress_dialog and not self . processing_cancelled : try : self . progress_dialog . update_progress_bar ( int ( value )) except RuntimeError : log ( tr ( \"Error setting value to a progress bar\" ), notify = False )","title":"update_progress_bar()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.update_pwl_layers","text":"update_pwl_layers ( notify = False ) Updates the priority layers path available in the store implementation models Parameters: Name Type Description Default notify bool Whether to show message to user about the update False Source code in src/cplus_plugin/gui/qgis_cplus_main.py 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 def update_pwl_layers ( self , notify = False ): \"\"\"Updates the priority layers path available in the store implementation models :param notify: Whether to show message to user about the update :type notify: bool \"\"\" settings_manager . update_implementation_models () self . update_priority_layers () if notify : self . show_message ( tr ( \"Updated all the implementation models\" \" with their respective priority layers\" ), Qgis . Info , ) log ( tr ( \"Updated all the implementation models\" \" with their respective priority layers\" ) )","title":"update_pwl_layers()"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.zoom_pilot_area","text":"zoom_pilot_area () Zoom the current main map canvas to the pilot area extent. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2063 2064 2065 2066 2067 2068 2069 2070 2071 2072 2073 2074 2075 2076 2077 2078 2079 2080 2081 2082 2083 2084 2085 2086 2087 2088 2089 2090 2091 2092 2093 2094 2095 def zoom_pilot_area ( self ): \"\"\"Zoom the current main map canvas to the pilot area extent.\"\"\" map_canvas = iface . mapCanvas () extent_list = PILOT_AREA_EXTENT [ \"coordinates\" ] default_extent = QgsRectangle ( extent_list [ 0 ], extent_list [ 2 ], extent_list [ 1 ], extent_list [ 3 ] ) zoom_extent = QgsRectangle ( extent_list [ 0 ] - 0.5 , extent_list [ 2 ], extent_list [ 1 ] + 0.5 , extent_list [ 3 ] ) canvas_crs = map_canvas . mapSettings () . destinationCrs () original_crs = QgsCoordinateReferenceSystem ( \"EPSG:4326\" ) if canvas_crs . authid () != original_crs . authid (): zoom_extent = self . transform_extent ( zoom_extent , original_crs , canvas_crs ) default_extent = self . transform_extent ( default_extent , original_crs , canvas_crs ) aoi = QgsRubberBand ( iface . mapCanvas (), QgsWkbTypes . PolygonGeometry ) aoi . setFillColor ( QtGui . QColor ( 0 , 0 , 0 , 0 )) aoi . setStrokeColor ( QtGui . QColor ( 88 , 128 , 8 )) aoi . setWidth ( 3 ) aoi . setLineStyle ( QtCore . Qt . DashLine ) geom = QgsGeometry . fromRect ( default_extent ) aoi . setToGeometry ( geom , canvas_crs ) map_canvas . setExtent ( zoom_extent ) map_canvas . refresh ()","title":"zoom_pilot_area()"},{"location":"developer/api/gui/api_im_editor_dialog/","text":"Implementation model editor Dialog for creating or editing an NCS pathway entry. ImplementationModelEditorDialog ImplementationModelEditorDialog ( parent = None , implementation_model = None , excluded_names = None ) Bases: QDialog , WidgetUi Dialog for creating or editing an implementation model entry. Source code in src/cplus_plugin/gui/implementation_model_editor_dialog.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def __init__ ( self , parent = None , implementation_model = None , excluded_names = None ): super () . __init__ ( parent ) self . setupUi ( self ) self . _message_bar = QgsMessageBar () self . vl_notification . addWidget ( self . _message_bar ) self . buttonBox . accepted . connect ( self . _on_accepted ) self . btn_select_file . clicked . connect ( self . _on_select_file ) icon_pixmap = QtGui . QPixmap ( ICON_PATH ) self . icon_la . setPixmap ( icon_pixmap ) self . cbo_layer . setFilters ( QgsMapLayerProxyModel . Filter . RasterLayer ) self . _edit_mode = False self . _layer = None self . _excluded_names = excluded_names if excluded_names is None : self . _excluded_names = [] self . _implementation_model = implementation_model if self . _implementation_model is not None : self . _edit_mode = True self . _layer = self . _implementation_model . to_map_layer () self . _update_controls () help_icon = FileUtils . get_icon ( \"mActionHelpContents.svg\" ) self . btn_help . setIcon ( help_icon ) edit_mode property edit_mode Returns the state of the editor. Returns: Type Description bool True if the editor is editing an existing ImplementationModel object, else False if its creating a new object. implementation_model property implementation_model Returns a reference to the ImplementationModel object. Returns: Type Description ImplementationModel Reference to the ImplementationModel object. layer property layer Returns the raster layer specified by the user, either existing layers in the map canvas or from the selected file. Returns: Type Description QgsRasterLayer The raster layer specified by the user or None if not set. validate validate () Validates if name has been specified. Returns: Type Description True True if the name have been set. Source code in src/cplus_plugin/gui/implementation_model_editor_dialog.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 def validate ( self ) -> bool : \"\"\"Validates if name has been specified. :returns: True if the name have been set. :rtype: True \"\"\" status = True self . _message_bar . clearWidgets () name = self . txt_name . text () if not name : msg = tr ( \"Implementation model name cannot be empty.\" ) self . _show_warning_message ( msg ) status = False if name . lower () in self . _excluded_names : msg = tr ( \"name has already been used.\" ) self . _show_warning_message ( f \"' { name } ' { msg } \" ) status = False if not self . txt_description . text (): msg = tr ( \"Description cannot be empty.\" ) self . _show_warning_message ( msg ) status = False if self . _layer and not self . _layer . isValid (): msg = tr ( \"Map layer is not valid.\" ) self . _show_warning_message ( msg ) status = False return status","title":"Implementation model editor"},{"location":"developer/api/gui/api_im_editor_dialog/#implementation-model-editor","text":"Dialog for creating or editing an NCS pathway entry.","title":"Implementation model editor"},{"location":"developer/api/gui/api_im_editor_dialog/#src.cplus_plugin.gui.implementation_model_editor_dialog.ImplementationModelEditorDialog","text":"ImplementationModelEditorDialog ( parent = None , implementation_model = None , excluded_names = None ) Bases: QDialog , WidgetUi Dialog for creating or editing an implementation model entry. Source code in src/cplus_plugin/gui/implementation_model_editor_dialog.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def __init__ ( self , parent = None , implementation_model = None , excluded_names = None ): super () . __init__ ( parent ) self . setupUi ( self ) self . _message_bar = QgsMessageBar () self . vl_notification . addWidget ( self . _message_bar ) self . buttonBox . accepted . connect ( self . _on_accepted ) self . btn_select_file . clicked . connect ( self . _on_select_file ) icon_pixmap = QtGui . QPixmap ( ICON_PATH ) self . icon_la . setPixmap ( icon_pixmap ) self . cbo_layer . setFilters ( QgsMapLayerProxyModel . Filter . RasterLayer ) self . _edit_mode = False self . _layer = None self . _excluded_names = excluded_names if excluded_names is None : self . _excluded_names = [] self . _implementation_model = implementation_model if self . _implementation_model is not None : self . _edit_mode = True self . _layer = self . _implementation_model . to_map_layer () self . _update_controls () help_icon = FileUtils . get_icon ( \"mActionHelpContents.svg\" ) self . btn_help . setIcon ( help_icon )","title":"ImplementationModelEditorDialog"},{"location":"developer/api/gui/api_im_editor_dialog/#src.cplus_plugin.gui.implementation_model_editor_dialog.ImplementationModelEditorDialog.edit_mode","text":"edit_mode Returns the state of the editor. Returns: Type Description bool True if the editor is editing an existing ImplementationModel object, else False if its creating a new object.","title":"edit_mode"},{"location":"developer/api/gui/api_im_editor_dialog/#src.cplus_plugin.gui.implementation_model_editor_dialog.ImplementationModelEditorDialog.implementation_model","text":"implementation_model Returns a reference to the ImplementationModel object. Returns: Type Description ImplementationModel Reference to the ImplementationModel object.","title":"implementation_model"},{"location":"developer/api/gui/api_im_editor_dialog/#src.cplus_plugin.gui.implementation_model_editor_dialog.ImplementationModelEditorDialog.layer","text":"layer Returns the raster layer specified by the user, either existing layers in the map canvas or from the selected file. Returns: Type Description QgsRasterLayer The raster layer specified by the user or None if not set.","title":"layer"},{"location":"developer/api/gui/api_im_editor_dialog/#src.cplus_plugin.gui.implementation_model_editor_dialog.ImplementationModelEditorDialog.validate","text":"validate () Validates if name has been specified. Returns: Type Description True True if the name have been set. Source code in src/cplus_plugin/gui/implementation_model_editor_dialog.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 def validate ( self ) -> bool : \"\"\"Validates if name has been specified. :returns: True if the name have been set. :rtype: True \"\"\" status = True self . _message_bar . clearWidgets () name = self . txt_name . text () if not name : msg = tr ( \"Implementation model name cannot be empty.\" ) self . _show_warning_message ( msg ) status = False if name . lower () in self . _excluded_names : msg = tr ( \"name has already been used.\" ) self . _show_warning_message ( f \"' { name } ' { msg } \" ) status = False if not self . txt_description . text (): msg = tr ( \"Description cannot be empty.\" ) self . _show_warning_message ( msg ) status = False if self . _layer and not self . _layer . isValid (): msg = tr ( \"Map layer is not valid.\" ) self . _show_warning_message ( msg ) status = False return status","title":"validate()"},{"location":"developer/api/gui/api_im_widget/","text":"Implementation model widget Container widget for configuring the implementation widget. ImplementationModelContainerWidget ImplementationModelContainerWidget ( parent = None ) Bases: QWidget , WidgetUi Widget for configuring the implementation model. Source code in src/cplus_plugin/gui/implementation_model_widget.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def __init__ ( self , parent = None ): super () . __init__ ( parent ) self . setupUi ( self ) self . _items_loaded = False self . btn_add_one . setIcon ( FileUtils . get_icon ( \"cplus_right_arrow.svg\" )) self . btn_add_one . setToolTip ( self . tr ( \"Add selected NCS pathway\" )) self . btn_add_one . clicked . connect ( self . _on_add_ncs_pathway ) self . btn_add_all . setIcon ( FileUtils . get_icon ( \"cplus_double_right_arrows.svg\" )) self . btn_add_all . setToolTip ( self . tr ( \"Add all NCS pathways\" )) self . btn_add_all . clicked . connect ( self . _on_add_all_ncs_pathways ) # NCS pathway view self . ncs_pathway_view = NcsComponentWidget () self . ncs_pathway_view . title = self . tr ( \"NCS Pathways\" ) self . ncs_layout . addWidget ( self . ncs_pathway_view ) # Implementation model view self . implementation_model_view = ImplementationModelComponentWidget () self . ipm_layout . addWidget ( self . implementation_model_view ) self . implementation_model_view . title = self . tr ( \"Implementation Models\" ) self . ncs_pathway_view . ncs_pathway_updated . connect ( self . on_ncs_pathway_updated ) self . load () implementation_models implementation_models () Returns the user-defined implementation models in the Implementation Models view. Returns: Type Description list User-defined implementation models for the current scenario. Source code in src/cplus_plugin/gui/implementation_model_widget.py 81 82 83 84 85 86 87 88 def implementation_models ( self ) -> typing . List [ ImplementationModel ]: \"\"\"Returns the user-defined implementation models in the Implementation Models view. :returns: User-defined implementation models for the current scenario. :rtype: list \"\"\" return self . implementation_model_view . models () is_valid is_valid () Check if the user input is valid. This checks if there is one implementation model defined with at least one NCS pathway under it. Returns: Type Description bool True if the implementation model configuration is valid, else False at least until there is one implementation model defined with at least one NCS pathway under it. Source code in src/cplus_plugin/gui/implementation_model_widget.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 def is_valid ( self ) -> bool : \"\"\"Check if the user input is valid. This checks if there is one implementation model defined with at least one NCS pathway under it. :returns: True if the implementation model configuration is valid, else False at least until there is one implementation model defined with at least one NCS pathway under it. :rtype: bool \"\"\" implementation_models = self . implementation_models () if len ( implementation_models ) == 0 : return False status = False for im in implementation_models : if len ( im . pathways ) > 0 : status = True break return status load load () Load NCS pathways and implementation models to the views. This function is idempotent as items will only be loaded once on initial call. Source code in src/cplus_plugin/gui/implementation_model_widget.py 62 63 64 65 66 67 68 69 70 71 def load ( self ): \"\"\"Load NCS pathways and implementation models to the views. This function is idempotent as items will only be loaded once on initial call. \"\"\" if not self . _items_loaded : self . ncs_pathway_view . load () self . implementation_model_view . load () self . _items_loaded = True ncs_pathways ncs_pathways () Gets the NCS pathway objects in the NCS Pathways view. Returns: Type Description list NCS pathway objects, both default and user-defined. Source code in src/cplus_plugin/gui/implementation_model_widget.py 73 74 75 76 77 78 79 def ncs_pathways ( self ) -> typing . List [ NcsPathway ]: \"\"\"Gets the NCS pathway objects in the NCS Pathways view. :returns: NCS pathway objects, both default and user-defined. :rtype: list \"\"\" return self . ncs_pathway_view . pathways () on_ncs_pathway_updated on_ncs_pathway_updated ( ncs_pathway ) Slot raised when an NCS pathway has been updated. Source code in src/cplus_plugin/gui/implementation_model_widget.py 109 110 111 def on_ncs_pathway_updated ( self , ncs_pathway : NcsPathway ): \"\"\"Slot raised when an NCS pathway has been updated.\"\"\" self . implementation_model_view . update_ncs_pathway_items ( ncs_pathway ) selected_im_items selected_im_items () Returns the currently selected instances of ImplementationModelItem. Returns: Type Description list Currently selected instances of ImplementationModelItem or an empty list if there is no selection of IM items. Source code in src/cplus_plugin/gui/implementation_model_widget.py 155 156 157 158 159 160 161 162 163 164 165 166 def selected_im_items ( self ) -> typing . List [ ImplementationModelItem ]: \"\"\"Returns the currently selected instances of ImplementationModelItem. :returns: Currently selected instances of ImplementationModelItem or an empty list if there is no selection of IM items. :rtype: list \"\"\" return [ item for item in self . selected_items () if isinstance ( item , ImplementationModelItem ) ] selected_items selected_items () Returns the selected model component item types which could be NCS pathway or implementation model items. These are cloned objects so as not to interfere with the underlying data models when used for scenario analysis. Otherwise, one can also use the data models from the MVC item model. Returns: Type Description list Selected model component items. Source code in src/cplus_plugin/gui/implementation_model_widget.py 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def selected_items ( self ) -> typing . List [ ModelComponentItemType ]: \"\"\"Returns the selected model component item types which could be NCS pathway or implementation model items. These are cloned objects so as not to interfere with the underlying data models when used for scenario analysis. Otherwise, one can also use the data models from the MVC item model. :returns: Selected model component items. :rtype: list \"\"\" ref_items = self . implementation_model_view . selected_items () cloned_items = [] for ref_item in ref_items : clone_item = ref_item . clone () cloned_items . append ( clone_item ) return cloned_items","title":"Implementation model widget"},{"location":"developer/api/gui/api_im_widget/#implementation-model-widget","text":"Container widget for configuring the implementation widget.","title":"Implementation model widget"},{"location":"developer/api/gui/api_im_widget/#src.cplus_plugin.gui.implementation_model_widget.ImplementationModelContainerWidget","text":"ImplementationModelContainerWidget ( parent = None ) Bases: QWidget , WidgetUi Widget for configuring the implementation model. Source code in src/cplus_plugin/gui/implementation_model_widget.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def __init__ ( self , parent = None ): super () . __init__ ( parent ) self . setupUi ( self ) self . _items_loaded = False self . btn_add_one . setIcon ( FileUtils . get_icon ( \"cplus_right_arrow.svg\" )) self . btn_add_one . setToolTip ( self . tr ( \"Add selected NCS pathway\" )) self . btn_add_one . clicked . connect ( self . _on_add_ncs_pathway ) self . btn_add_all . setIcon ( FileUtils . get_icon ( \"cplus_double_right_arrows.svg\" )) self . btn_add_all . setToolTip ( self . tr ( \"Add all NCS pathways\" )) self . btn_add_all . clicked . connect ( self . _on_add_all_ncs_pathways ) # NCS pathway view self . ncs_pathway_view = NcsComponentWidget () self . ncs_pathway_view . title = self . tr ( \"NCS Pathways\" ) self . ncs_layout . addWidget ( self . ncs_pathway_view ) # Implementation model view self . implementation_model_view = ImplementationModelComponentWidget () self . ipm_layout . addWidget ( self . implementation_model_view ) self . implementation_model_view . title = self . tr ( \"Implementation Models\" ) self . ncs_pathway_view . ncs_pathway_updated . connect ( self . on_ncs_pathway_updated ) self . load ()","title":"ImplementationModelContainerWidget"},{"location":"developer/api/gui/api_im_widget/#src.cplus_plugin.gui.implementation_model_widget.ImplementationModelContainerWidget.implementation_models","text":"implementation_models () Returns the user-defined implementation models in the Implementation Models view. Returns: Type Description list User-defined implementation models for the current scenario. Source code in src/cplus_plugin/gui/implementation_model_widget.py 81 82 83 84 85 86 87 88 def implementation_models ( self ) -> typing . List [ ImplementationModel ]: \"\"\"Returns the user-defined implementation models in the Implementation Models view. :returns: User-defined implementation models for the current scenario. :rtype: list \"\"\" return self . implementation_model_view . models ()","title":"implementation_models()"},{"location":"developer/api/gui/api_im_widget/#src.cplus_plugin.gui.implementation_model_widget.ImplementationModelContainerWidget.is_valid","text":"is_valid () Check if the user input is valid. This checks if there is one implementation model defined with at least one NCS pathway under it. Returns: Type Description bool True if the implementation model configuration is valid, else False at least until there is one implementation model defined with at least one NCS pathway under it. Source code in src/cplus_plugin/gui/implementation_model_widget.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 def is_valid ( self ) -> bool : \"\"\"Check if the user input is valid. This checks if there is one implementation model defined with at least one NCS pathway under it. :returns: True if the implementation model configuration is valid, else False at least until there is one implementation model defined with at least one NCS pathway under it. :rtype: bool \"\"\" implementation_models = self . implementation_models () if len ( implementation_models ) == 0 : return False status = False for im in implementation_models : if len ( im . pathways ) > 0 : status = True break return status","title":"is_valid()"},{"location":"developer/api/gui/api_im_widget/#src.cplus_plugin.gui.implementation_model_widget.ImplementationModelContainerWidget.load","text":"load () Load NCS pathways and implementation models to the views. This function is idempotent as items will only be loaded once on initial call. Source code in src/cplus_plugin/gui/implementation_model_widget.py 62 63 64 65 66 67 68 69 70 71 def load ( self ): \"\"\"Load NCS pathways and implementation models to the views. This function is idempotent as items will only be loaded once on initial call. \"\"\" if not self . _items_loaded : self . ncs_pathway_view . load () self . implementation_model_view . load () self . _items_loaded = True","title":"load()"},{"location":"developer/api/gui/api_im_widget/#src.cplus_plugin.gui.implementation_model_widget.ImplementationModelContainerWidget.ncs_pathways","text":"ncs_pathways () Gets the NCS pathway objects in the NCS Pathways view. Returns: Type Description list NCS pathway objects, both default and user-defined. Source code in src/cplus_plugin/gui/implementation_model_widget.py 73 74 75 76 77 78 79 def ncs_pathways ( self ) -> typing . List [ NcsPathway ]: \"\"\"Gets the NCS pathway objects in the NCS Pathways view. :returns: NCS pathway objects, both default and user-defined. :rtype: list \"\"\" return self . ncs_pathway_view . pathways ()","title":"ncs_pathways()"},{"location":"developer/api/gui/api_im_widget/#src.cplus_plugin.gui.implementation_model_widget.ImplementationModelContainerWidget.on_ncs_pathway_updated","text":"on_ncs_pathway_updated ( ncs_pathway ) Slot raised when an NCS pathway has been updated. Source code in src/cplus_plugin/gui/implementation_model_widget.py 109 110 111 def on_ncs_pathway_updated ( self , ncs_pathway : NcsPathway ): \"\"\"Slot raised when an NCS pathway has been updated.\"\"\" self . implementation_model_view . update_ncs_pathway_items ( ncs_pathway )","title":"on_ncs_pathway_updated()"},{"location":"developer/api/gui/api_im_widget/#src.cplus_plugin.gui.implementation_model_widget.ImplementationModelContainerWidget.selected_im_items","text":"selected_im_items () Returns the currently selected instances of ImplementationModelItem. Returns: Type Description list Currently selected instances of ImplementationModelItem or an empty list if there is no selection of IM items. Source code in src/cplus_plugin/gui/implementation_model_widget.py 155 156 157 158 159 160 161 162 163 164 165 166 def selected_im_items ( self ) -> typing . List [ ImplementationModelItem ]: \"\"\"Returns the currently selected instances of ImplementationModelItem. :returns: Currently selected instances of ImplementationModelItem or an empty list if there is no selection of IM items. :rtype: list \"\"\" return [ item for item in self . selected_items () if isinstance ( item , ImplementationModelItem ) ]","title":"selected_im_items()"},{"location":"developer/api/gui/api_im_widget/#src.cplus_plugin.gui.implementation_model_widget.ImplementationModelContainerWidget.selected_items","text":"selected_items () Returns the selected model component item types which could be NCS pathway or implementation model items. These are cloned objects so as not to interfere with the underlying data models when used for scenario analysis. Otherwise, one can also use the data models from the MVC item model. Returns: Type Description list Selected model component items. Source code in src/cplus_plugin/gui/implementation_model_widget.py 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def selected_items ( self ) -> typing . List [ ModelComponentItemType ]: \"\"\"Returns the selected model component item types which could be NCS pathway or implementation model items. These are cloned objects so as not to interfere with the underlying data models when used for scenario analysis. Otherwise, one can also use the data models from the MVC item model. :returns: Selected model component items. :rtype: list \"\"\" ref_items = self . implementation_model_view . selected_items () cloned_items = [] for ref_item in ref_items : clone_item = ref_item . clone () cloned_items . append ( clone_item ) return cloned_items","title":"selected_items()"},{"location":"developer/api/gui/api_items_selection_dialog/","text":"Items selection dialog Item selection dialog file ItemsSelectionDialog ItemsSelectionDialog ( parent , layer = None , models = []) Bases: QDialog , DialogUi Dialog for handling items selection Constructor Source code in src/cplus_plugin/gui/items_selection_dialog.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def __init__ ( self , parent , layer = None , models = []): \"\"\"Constructor\"\"\" super () . __init__ () self . setupUi ( self ) self . parent = parent self . layer = layer self . models = models select_all_btn = QtWidgets . QPushButton ( tr ( \"Select All\" )) select_all_btn . setToolTip ( tr ( \"Select the all listed items\" )) select_all_btn . clicked . connect ( self . select_all_clicked ) self . mButtonBox . addButton ( select_all_btn , QtWidgets . QDialogButtonBox . ActionRole ) clear_all_btn = QtWidgets . QPushButton ( tr ( \"Clear Selection\" )) clear_all_btn . setToolTip ( tr ( \"Clear the current selection\" )) clear_all_btn . clicked . connect ( self . clear_all_clicked ) self . mButtonBox . addButton ( clear_all_btn , QtWidgets . QDialogButtonBox . ActionRole ) toggle_selection_btn = QtWidgets . QPushButton ( tr ( \"Toggle Selection\" )) toggle_selection_btn . clicked . connect ( self . toggle_selection_clicked ) self . mButtonBox . addButton ( toggle_selection_btn , QtWidgets . QDialogButtonBox . ActionRole ) self . mButtonBox . accepted . connect ( self . accept ) self . set_items () for index in range ( self . list_widget . count ()): item = self . list_widget . item ( index ) model_uuid = item . data ( QtCore . Qt . UserRole ) model = settings_manager . get_implementation_model ( str ( model_uuid )) layer_model_uuids = [ model . uuid for model in self . models ] model_layer_uuids = [ layer . get ( \"uuid\" ) for layer in model . priority_layers ] if ( self . layer is not None and str ( self . layer . get ( \"uuid\" )) in model_layer_uuids ) or ( model . uuid in layer_model_uuids ): item . setCheckState ( QtCore . Qt . Checked ) accept accept () Saves the item selection Source code in src/cplus_plugin/gui/items_selection_dialog.py 104 105 106 107 def accept ( self ): \"\"\"Saves the item selection\"\"\" self . parent . set_selected_models ( self . selected_items (), self . unselected_items ()) super () . accept () clear_all_clicked clear_all_clicked () Slot for handling clear fselection for all items. Source code in src/cplus_plugin/gui/items_selection_dialog.py 115 116 117 118 119 def clear_all_clicked ( self ): \"\"\"Slot for handling clear fselection for all items.\"\"\" for item_index in range ( self . list_widget . count ()): item_item = self . list_widget . item ( item_index ) item_item . setCheckState ( QtCore . Qt . Unchecked ) select_all_clicked select_all_clicked () Slot for handling selection for all items. Source code in src/cplus_plugin/gui/items_selection_dialog.py 109 110 111 112 113 def select_all_clicked ( self ): \"\"\"Slot for handling selection for all items.\"\"\" for item_index in range ( self . list_widget . count ()): item_item = self . list_widget . item ( item_index ) item_item . setCheckState ( QtCore . Qt . Checked ) selected_items selected_items () Returns the selected items from the dialog Source code in src/cplus_plugin/gui/items_selection_dialog.py 80 81 82 83 84 85 86 87 88 89 90 def selected_items ( self ): \"\"\"Returns the selected items from the dialog\"\"\" models = settings_manager . get_all_implementation_models () items_text = [] for index in range ( self . list_widget . count ()): item = self . list_widget . item ( index ) if item . checkState () == QtCore . Qt . Checked : items_text . append ( item . text ()) item_names = \",\" . join ( items_text ) items = [ item for item in models if item . name in item_names ] return items set_items set_items () Sets the item list in the dialog Source code in src/cplus_plugin/gui/items_selection_dialog.py 67 68 69 70 71 72 73 74 75 76 77 78 def set_items ( self ): \"\"\"Sets the item list in the dialog\"\"\" models = settings_manager . get_all_implementation_models () for model in models : list_widget_item = QtWidgets . QListWidgetItem ( model . name ) list_widget_item . setFlags ( list_widget_item . flags () | QtCore . Qt . ItemIsUserCheckable ) list_widget_item . setData ( QtCore . Qt . UserRole , model . uuid ) list_widget_item . setCheckState ( QtCore . Qt . Unchecked ) self . list_widget . addItem ( list_widget_item ) toggle_selection_clicked toggle_selection_clicked () Toggles all the current items selection. Source code in src/cplus_plugin/gui/items_selection_dialog.py 121 122 123 124 125 126 127 128 129 def toggle_selection_clicked ( self ): \"\"\"Toggles all the current items selection.\"\"\" for item_index in range ( self . list_widget . count ()): item_item = self . list_widget . item ( item_index ) state = item_item . checkState () if state == QtCore . Qt . Checked : item_item . setCheckState ( QtCore . Qt . Unchecked ) elif state == QtCore . Qt . Unchecked : item_item . setCheckState ( QtCore . Qt . Checked ) unselected_items unselected_items () Returns unselected items from the dialog Source code in src/cplus_plugin/gui/items_selection_dialog.py 92 93 94 95 96 97 98 99 100 101 102 def unselected_items ( self ): \"\"\"Returns unselected items from the dialog\"\"\" models = settings_manager . get_all_implementation_models () items_text = [] for index in range ( self . list_widget . count ()): item = self . list_widget . item ( index ) if item . checkState () == QtCore . Qt . Unchecked : items_text . append ( item . text ()) item_names = \",\" . join ( items_text ) items = [ item for item in models if item . name in item_names ] return items","title":"Items selection dialog"},{"location":"developer/api/gui/api_items_selection_dialog/#items-selection-dialog","text":"Item selection dialog file","title":"Items selection dialog"},{"location":"developer/api/gui/api_items_selection_dialog/#src.cplus_plugin.gui.items_selection_dialog.ItemsSelectionDialog","text":"ItemsSelectionDialog ( parent , layer = None , models = []) Bases: QDialog , DialogUi Dialog for handling items selection Constructor Source code in src/cplus_plugin/gui/items_selection_dialog.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def __init__ ( self , parent , layer = None , models = []): \"\"\"Constructor\"\"\" super () . __init__ () self . setupUi ( self ) self . parent = parent self . layer = layer self . models = models select_all_btn = QtWidgets . QPushButton ( tr ( \"Select All\" )) select_all_btn . setToolTip ( tr ( \"Select the all listed items\" )) select_all_btn . clicked . connect ( self . select_all_clicked ) self . mButtonBox . addButton ( select_all_btn , QtWidgets . QDialogButtonBox . ActionRole ) clear_all_btn = QtWidgets . QPushButton ( tr ( \"Clear Selection\" )) clear_all_btn . setToolTip ( tr ( \"Clear the current selection\" )) clear_all_btn . clicked . connect ( self . clear_all_clicked ) self . mButtonBox . addButton ( clear_all_btn , QtWidgets . QDialogButtonBox . ActionRole ) toggle_selection_btn = QtWidgets . QPushButton ( tr ( \"Toggle Selection\" )) toggle_selection_btn . clicked . connect ( self . toggle_selection_clicked ) self . mButtonBox . addButton ( toggle_selection_btn , QtWidgets . QDialogButtonBox . ActionRole ) self . mButtonBox . accepted . connect ( self . accept ) self . set_items () for index in range ( self . list_widget . count ()): item = self . list_widget . item ( index ) model_uuid = item . data ( QtCore . Qt . UserRole ) model = settings_manager . get_implementation_model ( str ( model_uuid )) layer_model_uuids = [ model . uuid for model in self . models ] model_layer_uuids = [ layer . get ( \"uuid\" ) for layer in model . priority_layers ] if ( self . layer is not None and str ( self . layer . get ( \"uuid\" )) in model_layer_uuids ) or ( model . uuid in layer_model_uuids ): item . setCheckState ( QtCore . Qt . Checked )","title":"ItemsSelectionDialog"},{"location":"developer/api/gui/api_items_selection_dialog/#src.cplus_plugin.gui.items_selection_dialog.ItemsSelectionDialog.accept","text":"accept () Saves the item selection Source code in src/cplus_plugin/gui/items_selection_dialog.py 104 105 106 107 def accept ( self ): \"\"\"Saves the item selection\"\"\" self . parent . set_selected_models ( self . selected_items (), self . unselected_items ()) super () . accept ()","title":"accept()"},{"location":"developer/api/gui/api_items_selection_dialog/#src.cplus_plugin.gui.items_selection_dialog.ItemsSelectionDialog.clear_all_clicked","text":"clear_all_clicked () Slot for handling clear fselection for all items. Source code in src/cplus_plugin/gui/items_selection_dialog.py 115 116 117 118 119 def clear_all_clicked ( self ): \"\"\"Slot for handling clear fselection for all items.\"\"\" for item_index in range ( self . list_widget . count ()): item_item = self . list_widget . item ( item_index ) item_item . setCheckState ( QtCore . Qt . Unchecked )","title":"clear_all_clicked()"},{"location":"developer/api/gui/api_items_selection_dialog/#src.cplus_plugin.gui.items_selection_dialog.ItemsSelectionDialog.select_all_clicked","text":"select_all_clicked () Slot for handling selection for all items. Source code in src/cplus_plugin/gui/items_selection_dialog.py 109 110 111 112 113 def select_all_clicked ( self ): \"\"\"Slot for handling selection for all items.\"\"\" for item_index in range ( self . list_widget . count ()): item_item = self . list_widget . item ( item_index ) item_item . setCheckState ( QtCore . Qt . Checked )","title":"select_all_clicked()"},{"location":"developer/api/gui/api_items_selection_dialog/#src.cplus_plugin.gui.items_selection_dialog.ItemsSelectionDialog.selected_items","text":"selected_items () Returns the selected items from the dialog Source code in src/cplus_plugin/gui/items_selection_dialog.py 80 81 82 83 84 85 86 87 88 89 90 def selected_items ( self ): \"\"\"Returns the selected items from the dialog\"\"\" models = settings_manager . get_all_implementation_models () items_text = [] for index in range ( self . list_widget . count ()): item = self . list_widget . item ( index ) if item . checkState () == QtCore . Qt . Checked : items_text . append ( item . text ()) item_names = \",\" . join ( items_text ) items = [ item for item in models if item . name in item_names ] return items","title":"selected_items()"},{"location":"developer/api/gui/api_items_selection_dialog/#src.cplus_plugin.gui.items_selection_dialog.ItemsSelectionDialog.set_items","text":"set_items () Sets the item list in the dialog Source code in src/cplus_plugin/gui/items_selection_dialog.py 67 68 69 70 71 72 73 74 75 76 77 78 def set_items ( self ): \"\"\"Sets the item list in the dialog\"\"\" models = settings_manager . get_all_implementation_models () for model in models : list_widget_item = QtWidgets . QListWidgetItem ( model . name ) list_widget_item . setFlags ( list_widget_item . flags () | QtCore . Qt . ItemIsUserCheckable ) list_widget_item . setData ( QtCore . Qt . UserRole , model . uuid ) list_widget_item . setCheckState ( QtCore . Qt . Unchecked ) self . list_widget . addItem ( list_widget_item )","title":"set_items()"},{"location":"developer/api/gui/api_items_selection_dialog/#src.cplus_plugin.gui.items_selection_dialog.ItemsSelectionDialog.toggle_selection_clicked","text":"toggle_selection_clicked () Toggles all the current items selection. Source code in src/cplus_plugin/gui/items_selection_dialog.py 121 122 123 124 125 126 127 128 129 def toggle_selection_clicked ( self ): \"\"\"Toggles all the current items selection.\"\"\" for item_index in range ( self . list_widget . count ()): item_item = self . list_widget . item ( item_index ) state = item_item . checkState () if state == QtCore . Qt . Checked : item_item . setCheckState ( QtCore . Qt . Unchecked ) elif state == QtCore . Qt . Unchecked : item_item . setCheckState ( QtCore . Qt . Checked )","title":"toggle_selection_clicked()"},{"location":"developer/api/gui/api_items_selection_dialog/#src.cplus_plugin.gui.items_selection_dialog.ItemsSelectionDialog.unselected_items","text":"unselected_items () Returns unselected items from the dialog Source code in src/cplus_plugin/gui/items_selection_dialog.py 92 93 94 95 96 97 98 99 100 101 102 def unselected_items ( self ): \"\"\"Returns unselected items from the dialog\"\"\" models = settings_manager . get_all_implementation_models () items_text = [] for index in range ( self . list_widget . count ()): item = self . list_widget . item ( index ) if item . checkState () == QtCore . Qt . Unchecked : items_text . append ( item . text ()) item_names = \",\" . join ( items_text ) items = [ item for item in models if item . name in item_names ] return items","title":"unselected_items()"},{"location":"developer/api/gui/api_map_repeat_item_widget/","text":"Map repeat item widget Widget for the custom CPLUS layout map item. CplusMapLayoutItemGuiMetadata CplusMapLayoutItemGuiMetadata () Bases: QgsLayoutItemAbstractGuiMetadata GUI metadata for a CPLUS map layout item. Source code in src/cplus_plugin/gui/map_repeat_item_widget.py 55 56 def __init__ ( self ): super () . __init__ ( CPLUS_MAP_REPEAT_ITEM_TYPE , CPLUS_ITEM_NAME ) createItem createItem ( layout ) Factory override that returns the map item. Source code in src/cplus_plugin/gui/map_repeat_item_widget.py 62 63 64 def createItem ( self , layout ) -> QgsLayoutItem : \"\"\"Factory override that returns the map item.\"\"\" return CplusMapRepeatItem ( layout ) createItemWidget createItemWidget ( item ) Factory override for the item widget. Source code in src/cplus_plugin/gui/map_repeat_item_widget.py 58 59 60 def createItemWidget ( self , item ) -> QtWidgets . QWidget : \"\"\"Factory override for the item widget.\"\"\" return CplusMapRepeatItemWidget ( None , item ) creationIcon creationIcon () Factory override for item icon. Source code in src/cplus_plugin/gui/map_repeat_item_widget.py 70 71 72 def creationIcon ( self ) -> QtGui . QIcon : \"\"\"Factory override for item icon.\"\"\" return FileUtils . get_icon ( \"mLayoutItemMap_cplus_add.svg\" ) newItemAddedToLayout newItemAddedToLayout ( map_repeat_item ) Define action that is called when the CplusMapItem is added to a layout through the GUI. Parameters: Name Type Description Default map_repeat_item CplusMapRepeatItem Map repeat item to be added to the layout. required Source code in src/cplus_plugin/gui/map_repeat_item_widget.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def newItemAddedToLayout ( self , map_repeat_item : CplusMapRepeatItem ): \"\"\"Define action that is called when the CplusMapItem is added to a layout through the GUI. :param map_repeat_item: Map repeat item to be added to the layout. :type map_repeat_item: CplusMapRepeatItem \"\"\" items = map_repeat_item . layout () . items () counter = 1 for item in items : if isinstance ( item , CplusMapRepeatItem ): counter += 1 # Set frame properties map_repeat_item . setFrameEnabled ( True ) map_repeat_item . setFrameJoinStyle ( QtCore . Qt . MiterJoin ) map_repeat_item . setFrameStrokeColor ( QtGui . QColor ( 132 , 192 , 68 )) map_repeat_item . setFrameStrokeWidth ( QgsLayoutMeasurement ( 0.4 )) map_repeat_item . setId ( f \" { CPLUS_ITEM_NAME } { counter !s} \" ) visibleName visibleName () Override for user-visible name identifying the item. Source code in src/cplus_plugin/gui/map_repeat_item_widget.py 66 67 68 def visibleName ( self ) -> str : \"\"\"Override for user-visible name identifying the item.\"\"\" return CPLUS_ITEM_NAME CplusMapRepeatItemWidget CplusMapRepeatItemWidget ( parent , layout_object ) Bases: QgsLayoutItemBaseWidget , WidgetUi Widget for configuring the CPLUS layout map repeatitem. Source code in src/cplus_plugin/gui/map_repeat_item_widget.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def __init__ ( self , parent , layout_object : CplusMapRepeatItem ): super () . __init__ ( parent , layout_object ) self . setupUi ( self ) self . _map_item = layout_object # Common item properties widget self . _prop_widget = QgsLayoutItemPropertiesWidget ( self , layout_object ) self . layout . addWidget ( self . _prop_widget , 2 , 0 , 1 , 2 ) self . cbo_map_type . addItem ( self . tr ( \"Implementation model\" ), ModelComponentType . IMPLEMENTATION_MODEL . value , )","title":"Map repeat item widget"},{"location":"developer/api/gui/api_map_repeat_item_widget/#map-repeat-item-widget","text":"Widget for the custom CPLUS layout map item.","title":"Map repeat item widget"},{"location":"developer/api/gui/api_map_repeat_item_widget/#src.cplus_plugin.gui.map_repeat_item_widget.CplusMapLayoutItemGuiMetadata","text":"CplusMapLayoutItemGuiMetadata () Bases: QgsLayoutItemAbstractGuiMetadata GUI metadata for a CPLUS map layout item. Source code in src/cplus_plugin/gui/map_repeat_item_widget.py 55 56 def __init__ ( self ): super () . __init__ ( CPLUS_MAP_REPEAT_ITEM_TYPE , CPLUS_ITEM_NAME )","title":"CplusMapLayoutItemGuiMetadata"},{"location":"developer/api/gui/api_map_repeat_item_widget/#src.cplus_plugin.gui.map_repeat_item_widget.CplusMapLayoutItemGuiMetadata.createItem","text":"createItem ( layout ) Factory override that returns the map item. Source code in src/cplus_plugin/gui/map_repeat_item_widget.py 62 63 64 def createItem ( self , layout ) -> QgsLayoutItem : \"\"\"Factory override that returns the map item.\"\"\" return CplusMapRepeatItem ( layout )","title":"createItem()"},{"location":"developer/api/gui/api_map_repeat_item_widget/#src.cplus_plugin.gui.map_repeat_item_widget.CplusMapLayoutItemGuiMetadata.createItemWidget","text":"createItemWidget ( item ) Factory override for the item widget. Source code in src/cplus_plugin/gui/map_repeat_item_widget.py 58 59 60 def createItemWidget ( self , item ) -> QtWidgets . QWidget : \"\"\"Factory override for the item widget.\"\"\" return CplusMapRepeatItemWidget ( None , item )","title":"createItemWidget()"},{"location":"developer/api/gui/api_map_repeat_item_widget/#src.cplus_plugin.gui.map_repeat_item_widget.CplusMapLayoutItemGuiMetadata.creationIcon","text":"creationIcon () Factory override for item icon. Source code in src/cplus_plugin/gui/map_repeat_item_widget.py 70 71 72 def creationIcon ( self ) -> QtGui . QIcon : \"\"\"Factory override for item icon.\"\"\" return FileUtils . get_icon ( \"mLayoutItemMap_cplus_add.svg\" )","title":"creationIcon()"},{"location":"developer/api/gui/api_map_repeat_item_widget/#src.cplus_plugin.gui.map_repeat_item_widget.CplusMapLayoutItemGuiMetadata.newItemAddedToLayout","text":"newItemAddedToLayout ( map_repeat_item ) Define action that is called when the CplusMapItem is added to a layout through the GUI. Parameters: Name Type Description Default map_repeat_item CplusMapRepeatItem Map repeat item to be added to the layout. required Source code in src/cplus_plugin/gui/map_repeat_item_widget.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def newItemAddedToLayout ( self , map_repeat_item : CplusMapRepeatItem ): \"\"\"Define action that is called when the CplusMapItem is added to a layout through the GUI. :param map_repeat_item: Map repeat item to be added to the layout. :type map_repeat_item: CplusMapRepeatItem \"\"\" items = map_repeat_item . layout () . items () counter = 1 for item in items : if isinstance ( item , CplusMapRepeatItem ): counter += 1 # Set frame properties map_repeat_item . setFrameEnabled ( True ) map_repeat_item . setFrameJoinStyle ( QtCore . Qt . MiterJoin ) map_repeat_item . setFrameStrokeColor ( QtGui . QColor ( 132 , 192 , 68 )) map_repeat_item . setFrameStrokeWidth ( QgsLayoutMeasurement ( 0.4 )) map_repeat_item . setId ( f \" { CPLUS_ITEM_NAME } { counter !s} \" )","title":"newItemAddedToLayout()"},{"location":"developer/api/gui/api_map_repeat_item_widget/#src.cplus_plugin.gui.map_repeat_item_widget.CplusMapLayoutItemGuiMetadata.visibleName","text":"visibleName () Override for user-visible name identifying the item. Source code in src/cplus_plugin/gui/map_repeat_item_widget.py 66 67 68 def visibleName ( self ) -> str : \"\"\"Override for user-visible name identifying the item.\"\"\" return CPLUS_ITEM_NAME","title":"visibleName()"},{"location":"developer/api/gui/api_map_repeat_item_widget/#src.cplus_plugin.gui.map_repeat_item_widget.CplusMapRepeatItemWidget","text":"CplusMapRepeatItemWidget ( parent , layout_object ) Bases: QgsLayoutItemBaseWidget , WidgetUi Widget for configuring the CPLUS layout map repeatitem. Source code in src/cplus_plugin/gui/map_repeat_item_widget.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def __init__ ( self , parent , layout_object : CplusMapRepeatItem ): super () . __init__ ( parent , layout_object ) self . setupUi ( self ) self . _map_item = layout_object # Common item properties widget self . _prop_widget = QgsLayoutItemPropertiesWidget ( self , layout_object ) self . layout . addWidget ( self . _prop_widget , 2 , 0 , 1 , 2 ) self . cbo_map_type . addItem ( self . tr ( \"Implementation model\" ), ModelComponentType . IMPLEMENTATION_MODEL . value , )","title":"CplusMapRepeatItemWidget"},{"location":"developer/api/gui/api_model_component_widget/","text":"Model component widget Composite list view-based widgets for displaying implementation model and NCS pathway items. ImplementationModelComponentWidget ImplementationModelComponentWidget ( parent = None ) Bases: ModelComponentWidget Widget for displaying and managing implementation models. Source code in src/cplus_plugin/gui/model_component_widget.py 402 403 404 405 406 407 408 409 410 411 412 413 414 def __init__ ( self , parent = None ): super () . __init__ ( parent ) self . _saved_ims = settings_manager . get_all_implementation_models () self . item_model = IMItemModel ( parent ) self . item_model . im_pathways_updated . connect ( self . on_pathways_updated ) self . lst_model_items . setAcceptDrops ( True ) self . lst_model_items . setDragDropMode ( QtWidgets . QAbstractItemView . DropOnly ) self . lst_model_items . setDropIndicatorShown ( True ) self . btn_reload . setVisible ( False ) add_implementation_model add_implementation_model ( implementation_model , layer = None ) Adds an implementation model object to the view with the option of specifying the layer. Parameters: Name Type Description Default implementation_model ImplementationModel Implementation model object to be added to the view. required layer QgsMapLayer Optional map layer to be added to the model. None Returns: Type Description bool True if the implementation model was successfully added, else False. Source code in src/cplus_plugin/gui/model_component_widget.py 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 def add_implementation_model ( self , implementation_model : ImplementationModel , layer : QgsMapLayer = None ): \"\"\"Adds an implementation model object to the view with the option of specifying the layer. :param implementation_model: Implementation model object to be added to the view. :type implementation_model: ImplementationModel :param layer: Optional map layer to be added to the model. :type layer: QgsMapLayer :returns: True if the implementation model was successfully added, else False. :rtype: bool \"\"\" return self . item_model . add_implementation_model ( implementation_model , layer ) add_ncs_pathway_items add_ncs_pathway_items ( ncs_items ) Adds an NCS pathway item to the collection. One, and only one, target implementation model item needs to have been selected. Parameters: Name Type Description Default ncs_items List [ NcsPathwayItem ] NCS pathway items to be added to the implementation model. required Returns: Type Description bool True if the item was successfully added, else False. Source code in src/cplus_plugin/gui/model_component_widget.py 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 def add_ncs_pathway_items ( self , ncs_items : typing . List [ NcsPathwayItem ]) -> bool : \"\"\"Adds an NCS pathway item to the collection. One, and only one, target implementation model item needs to have been selected. :param ncs_items: NCS pathway items to be added to the implementation model. :type ncs_items: list :returns: True if the item was successfully added, else False. :rtype: bool \"\"\" selected_models = self . selected_items () if len ( selected_models ) == 0 or len ( selected_models ) > 1 : return False sel_model = selected_models [ 0 ] item_type = sel_model . type () # Use the parent to add the NCS item if item_type == NCS_PATHWAY_TYPE : if sel_model . parent is None : return False sel_model = sel_model . parent elif item_type == LAYER_ITEM_TYPE : return False status = True for ncs_item in ncs_items : status = self . item_model . add_ncs_pathway ( ncs_item , sel_model ) return status clear clear () Removes all implementation model items in the view. Source code in src/cplus_plugin/gui/model_component_widget.py 456 457 458 459 460 def clear ( self ): \"\"\"Removes all implementation model items in the view.\"\"\" items = self . model_items () for item in items : self . item_model . remove_implementation_model ( item . uuid ) load load () Load implementation models from settings. Source code in src/cplus_plugin/gui/model_component_widget.py 462 463 464 465 466 467 def load ( self ): \"\"\"Load implementation models from settings.\"\"\" self . clear () for imp_model in self . _saved_ims : self . add_implementation_model ( imp_model ) model_items model_items () Returns a collection of all ImplementationModelItem objects in the list view. Returns: Type Description list Collection of ImplementationModelItem objects in the list view. Source code in src/cplus_plugin/gui/model_component_widget.py 446 447 448 449 450 451 452 453 454 def model_items ( self ) -> typing . List [ ImplementationModelItem ]: \"\"\"Returns a collection of all ImplementationModelItem objects in the list view. :returns: Collection of ImplementationModelItem objects in the list view. :rtype: list \"\"\" return self . item_model . model_items () model_names model_names () Gets the names of the implementation models in the item model. Returns: Type Description list Returns the names of implementation models in lower case or an empty list if the item model has not been set. Source code in src/cplus_plugin/gui/model_component_widget.py 426 427 428 429 430 431 432 433 434 435 436 437 438 def model_names ( self ) -> typing . List [ str ]: \"\"\"Gets the names of the implementation models in the item model. :returns: Returns the names of implementation models in lower case or an empty list if the item model has not been set. :rtype: list \"\"\" if self . _item_model is None : return [] model_components = self . _item_model . models () return [ mc . name . lower () for mc in model_components ] models models () Returns a collection of ImplementationModel objects in the list view. Returns: Type Description list Collection of ImplementationModel objects in the list view. Source code in src/cplus_plugin/gui/model_component_widget.py 416 417 418 419 420 421 422 423 424 def models ( self ) -> typing . List [ ImplementationModel ]: \"\"\"Returns a collection of ImplementationModel objects in the list view. :returns: Collection of ImplementationModel objects in the list view. :rtype: list \"\"\" return self . item_model . models () on_pathways_updated on_pathways_updated ( im_item ) Slot raised when the pathways of an ImplementationModelItem have been added or removed. Persist this information in settings. Source code in src/cplus_plugin/gui/model_component_widget.py 440 441 442 443 444 def on_pathways_updated ( self , im_item : ImplementationModelItem ): \"\"\"Slot raised when the pathways of an ImplementationModelItem have been added or removed. Persist this information in settings. \"\"\" self . _save_item ( im_item ) update_ncs_pathway_items update_ncs_pathway_items ( ncs_pathway ) Update NCS pathway items used for IMs that are linked to the given NCS pathway. Parameters: Name Type Description Default ncs_pathway NcsPathway NCS pathway whose attribute values will be updated for the related pathways used in the IMs. required Returns: Type Description bool True if NCS pathway items were updated, else False. Source code in src/cplus_plugin/gui/model_component_widget.py 643 644 645 646 647 648 649 650 651 652 653 654 def update_ncs_pathway_items ( self , ncs_pathway : NcsPathway ) -> bool : \"\"\"Update NCS pathway items used for IMs that are linked to the given NCS pathway. :param ncs_pathway: NCS pathway whose attribute values will be updated for the related pathways used in the IMs. :type ncs_pathway: NcsPathway :returns: True if NCS pathway items were updated, else False. :rtype: bool \"\"\" return self . item_model . update_ncs_pathway_items ( ncs_pathway ) ModelComponentWidget ModelComponentWidget ( parent = None , item_model = None ) Bases: QWidget , WidgetUi Widget for displaying and managing model items in a list view. Source code in src/cplus_plugin/gui/model_component_widget.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def __init__ ( self , parent = None , item_model = None ): super () . __init__ ( parent ) self . setupUi ( self ) self . _item_model = item_model if self . _item_model is not None : self . item_model = self . _item_model add_icon = FileUtils . get_icon ( \"symbologyAdd.svg\" ) self . btn_add . setIcon ( add_icon ) self . btn_add . clicked . connect ( self . _on_add_item ) remove_icon = FileUtils . get_icon ( \"symbologyRemove.svg\" ) self . btn_remove . setIcon ( remove_icon ) self . btn_remove . setEnabled ( False ) self . btn_remove . clicked . connect ( self . _on_remove_item ) edit_icon = FileUtils . get_icon ( \"mActionToggleEditing.svg\" ) self . btn_edit . setIcon ( edit_icon ) self . btn_edit . setEnabled ( False ) self . btn_edit . clicked . connect ( self . _on_edit_item ) reload_icon = FileUtils . get_icon ( \"mActionReload.svg\" ) self . btn_reload . setIcon ( reload_icon ) self . btn_reload . setToolTip ( self . tr ( \"Refresh view\" )) self . btn_reload . clicked . connect ( self . _on_reload ) self . btn_edit_description . setIcon ( edit_icon ) self . btn_edit_description . setToolTip ( self . tr ( \"Edit description\" )) self . btn_edit_description . setEnabled ( False ) self . btn_edit_description . clicked . connect ( self . _on_update_description ) item_model property writable item_model Returns the component item model for managing items the list view. Returns: Type Description ComponentItemModel Component item model for managing items the list view. selection_model property selection_model Gets the item's view selection model. Returns: Type Description QtCore.QItemSelectionModel The item's view selection model. title property writable title Returns the title of the view. Returns: Type Description str Title of the view. clear clear () Remove all items in the view. To be implemented by subclasses. Source code in src/cplus_plugin/gui/model_component_widget.py 245 246 247 248 def clear ( self ): \"\"\"Remove all items in the view. To be implemented by subclasses.\"\"\" pass clear_description clear_description () Clears the content in the description text box. Source code in src/cplus_plugin/gui/model_component_widget.py 190 191 192 193 def clear_description ( self ): \"\"\"Clears the content in the description text box.\"\"\" self . txt_item_description . clear () self . txt_item_description . setToolTip ( \"\" ) load load () Subclass to determine how to initialize the items. Source code in src/cplus_plugin/gui/model_component_widget.py 125 126 127 def load ( self ): \"\"\"Subclass to determine how to initialize the items.\"\"\" pass model_names model_names () Gets the names of the components in the item model. Returns: Type Description list Returns the model names in lower case or an empty list if the item model has not been set. Source code in src/cplus_plugin/gui/model_component_widget.py 257 258 259 260 261 262 263 264 265 266 267 268 269 def model_names ( self ) -> typing . List [ str ]: \"\"\"Gets the names of the components in the item model. :returns: Returns the model names in lower case or an empty list if the item model has not been set. :rtype: list \"\"\" if self . _item_model is None : return [] model_components = self . _item_model . model_components () return [ mc . name . lower () for mc in model_components ] selected_items selected_items () Returns the selected items in the list view. Returns: Type Description list A collection of the selected model component items. Returns an empty list if the item model has not been set. Source code in src/cplus_plugin/gui/model_component_widget.py 230 231 232 233 234 235 236 237 238 239 240 241 242 243 def selected_items ( self ) -> typing . List [ ModelComponentItemType ]: \"\"\"Returns the selected items in the list view. :returns: A collection of the selected model component items. Returns an empty list if the item model has not been set. :rtype: list \"\"\" if self . _item_model is None : return [] selection_model = self . lst_model_items . selectionModel () idxs = selection_model . selectedRows () return [ self . _item_model . item ( idx . row ()) for idx in idxs ] set_description set_description ( description ) Updates the text for the selected item. Parameters: Name Type Description Default description str Description for the selected item. required Source code in src/cplus_plugin/gui/model_component_widget.py 181 182 183 184 185 186 187 188 def set_description ( self , description : str ): \"\"\"Updates the text for the selected item. :param description: Description for the selected item. :type description: str \"\"\" self . txt_item_description . setText ( description ) self . txt_item_description . setToolTip ( description ) NcsComponentWidget NcsComponentWidget ( parent = None ) Bases: ModelComponentWidget Widget for displaying and managing NCS pathways. Source code in src/cplus_plugin/gui/model_component_widget.py 277 278 279 280 281 282 283 284 def __init__ ( self , parent = None ): super () . __init__ ( parent ) self . item_model = NcsPathwayItemModel ( parent ) self . lst_model_items . setDragEnabled ( True ) self . lst_model_items . setDragDropMode ( QtWidgets . QAbstractItemView . DragOnly ) self . lst_model_items . setAcceptDrops ( False ) add_ncs_pathway add_ncs_pathway ( ncs_pathway ) Adds an NCS pathway object to the view. Parameters: Name Type Description Default ncs_pathway NcsPathway NCS pathway object to be added to the view. required Returns: Type Description bool Returns True if the NcsPathway was successfully added, else False. Source code in src/cplus_plugin/gui/model_component_widget.py 286 287 288 289 290 291 292 293 294 295 296 def add_ncs_pathway ( self , ncs_pathway : NcsPathway ) -> bool : \"\"\"Adds an NCS pathway object to the view. :param ncs_pathway: NCS pathway object to be added to the view. :type ncs_pathway: NcsPathway :returns: Returns True if the NcsPathway was successfully added, else False. :rtype: bool \"\"\" return self . item_model . add_ncs_pathway ( ncs_pathway ) clear clear () Removes all NCS pathway items in the view. Source code in src/cplus_plugin/gui/model_component_widget.py 298 299 300 301 302 def clear ( self ): \"\"\"Removes all NCS pathway items in the view.\"\"\" items = self . ncs_items () for item in items : self . item_model . remove_ncs_pathway ( item . uuid ) load load () Load items from settings. Source code in src/cplus_plugin/gui/model_component_widget.py 389 390 391 392 393 394 395 396 def load ( self ): \"\"\"Load items from settings.\"\"\" self . clear () settings_manager . update_ncs_pathways () ncs_pathways = settings_manager . get_all_ncs_pathways () for ncs in ncs_pathways : self . add_ncs_pathway ( ncs ) ncs_items ncs_items () Returns a collection of all NcsPathwayItem objects in the list view. Returns: Type Description list Collection of NcsPathwayItem objects in the list view. Source code in src/cplus_plugin/gui/model_component_widget.py 316 317 318 319 320 321 322 323 def ncs_items ( self ) -> typing . List [ NcsPathwayItem ]: \"\"\"Returns a collection of all NcsPathwayItem objects in the list view. :returns: Collection of NcsPathwayItem objects in the list view. :rtype: list \"\"\" return self . item_model . model_component_items () pathways pathways ( valid_only = False ) Returns a collection of NcsPathway objects in the list view. Parameters: Name Type Description Default valid_only bool True to only return those NcsPathway objects that are valid, default is False. False Returns: Type Description list Collection of NcsPathway objects in the list view. Source code in src/cplus_plugin/gui/model_component_widget.py 304 305 306 307 308 309 310 311 312 313 314 def pathways ( self , valid_only = False ) -> typing . List [ NcsPathway ]: \"\"\"Returns a collection of NcsPathway objects in the list view. :param valid_only: True to only return those NcsPathway objects that are valid, default is False. :type valid_only: bool :returns: Collection of NcsPathway objects in the list view. :rtype: list \"\"\" return self . item_model . pathways ( valid_only )","title":"Model component widget"},{"location":"developer/api/gui/api_model_component_widget/#model-component-widget","text":"Composite list view-based widgets for displaying implementation model and NCS pathway items.","title":"Model component widget"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ImplementationModelComponentWidget","text":"ImplementationModelComponentWidget ( parent = None ) Bases: ModelComponentWidget Widget for displaying and managing implementation models. Source code in src/cplus_plugin/gui/model_component_widget.py 402 403 404 405 406 407 408 409 410 411 412 413 414 def __init__ ( self , parent = None ): super () . __init__ ( parent ) self . _saved_ims = settings_manager . get_all_implementation_models () self . item_model = IMItemModel ( parent ) self . item_model . im_pathways_updated . connect ( self . on_pathways_updated ) self . lst_model_items . setAcceptDrops ( True ) self . lst_model_items . setDragDropMode ( QtWidgets . QAbstractItemView . DropOnly ) self . lst_model_items . setDropIndicatorShown ( True ) self . btn_reload . setVisible ( False )","title":"ImplementationModelComponentWidget"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ImplementationModelComponentWidget.add_implementation_model","text":"add_implementation_model ( implementation_model , layer = None ) Adds an implementation model object to the view with the option of specifying the layer. Parameters: Name Type Description Default implementation_model ImplementationModel Implementation model object to be added to the view. required layer QgsMapLayer Optional map layer to be added to the model. None Returns: Type Description bool True if the implementation model was successfully added, else False. Source code in src/cplus_plugin/gui/model_component_widget.py 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 def add_implementation_model ( self , implementation_model : ImplementationModel , layer : QgsMapLayer = None ): \"\"\"Adds an implementation model object to the view with the option of specifying the layer. :param implementation_model: Implementation model object to be added to the view. :type implementation_model: ImplementationModel :param layer: Optional map layer to be added to the model. :type layer: QgsMapLayer :returns: True if the implementation model was successfully added, else False. :rtype: bool \"\"\" return self . item_model . add_implementation_model ( implementation_model , layer )","title":"add_implementation_model()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ImplementationModelComponentWidget.add_ncs_pathway_items","text":"add_ncs_pathway_items ( ncs_items ) Adds an NCS pathway item to the collection. One, and only one, target implementation model item needs to have been selected. Parameters: Name Type Description Default ncs_items List [ NcsPathwayItem ] NCS pathway items to be added to the implementation model. required Returns: Type Description bool True if the item was successfully added, else False. Source code in src/cplus_plugin/gui/model_component_widget.py 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 def add_ncs_pathway_items ( self , ncs_items : typing . List [ NcsPathwayItem ]) -> bool : \"\"\"Adds an NCS pathway item to the collection. One, and only one, target implementation model item needs to have been selected. :param ncs_items: NCS pathway items to be added to the implementation model. :type ncs_items: list :returns: True if the item was successfully added, else False. :rtype: bool \"\"\" selected_models = self . selected_items () if len ( selected_models ) == 0 or len ( selected_models ) > 1 : return False sel_model = selected_models [ 0 ] item_type = sel_model . type () # Use the parent to add the NCS item if item_type == NCS_PATHWAY_TYPE : if sel_model . parent is None : return False sel_model = sel_model . parent elif item_type == LAYER_ITEM_TYPE : return False status = True for ncs_item in ncs_items : status = self . item_model . add_ncs_pathway ( ncs_item , sel_model ) return status","title":"add_ncs_pathway_items()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ImplementationModelComponentWidget.clear","text":"clear () Removes all implementation model items in the view. Source code in src/cplus_plugin/gui/model_component_widget.py 456 457 458 459 460 def clear ( self ): \"\"\"Removes all implementation model items in the view.\"\"\" items = self . model_items () for item in items : self . item_model . remove_implementation_model ( item . uuid )","title":"clear()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ImplementationModelComponentWidget.load","text":"load () Load implementation models from settings. Source code in src/cplus_plugin/gui/model_component_widget.py 462 463 464 465 466 467 def load ( self ): \"\"\"Load implementation models from settings.\"\"\" self . clear () for imp_model in self . _saved_ims : self . add_implementation_model ( imp_model )","title":"load()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ImplementationModelComponentWidget.model_items","text":"model_items () Returns a collection of all ImplementationModelItem objects in the list view. Returns: Type Description list Collection of ImplementationModelItem objects in the list view. Source code in src/cplus_plugin/gui/model_component_widget.py 446 447 448 449 450 451 452 453 454 def model_items ( self ) -> typing . List [ ImplementationModelItem ]: \"\"\"Returns a collection of all ImplementationModelItem objects in the list view. :returns: Collection of ImplementationModelItem objects in the list view. :rtype: list \"\"\" return self . item_model . model_items ()","title":"model_items()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ImplementationModelComponentWidget.model_names","text":"model_names () Gets the names of the implementation models in the item model. Returns: Type Description list Returns the names of implementation models in lower case or an empty list if the item model has not been set. Source code in src/cplus_plugin/gui/model_component_widget.py 426 427 428 429 430 431 432 433 434 435 436 437 438 def model_names ( self ) -> typing . List [ str ]: \"\"\"Gets the names of the implementation models in the item model. :returns: Returns the names of implementation models in lower case or an empty list if the item model has not been set. :rtype: list \"\"\" if self . _item_model is None : return [] model_components = self . _item_model . models () return [ mc . name . lower () for mc in model_components ]","title":"model_names()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ImplementationModelComponentWidget.models","text":"models () Returns a collection of ImplementationModel objects in the list view. Returns: Type Description list Collection of ImplementationModel objects in the list view. Source code in src/cplus_plugin/gui/model_component_widget.py 416 417 418 419 420 421 422 423 424 def models ( self ) -> typing . List [ ImplementationModel ]: \"\"\"Returns a collection of ImplementationModel objects in the list view. :returns: Collection of ImplementationModel objects in the list view. :rtype: list \"\"\" return self . item_model . models ()","title":"models()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ImplementationModelComponentWidget.on_pathways_updated","text":"on_pathways_updated ( im_item ) Slot raised when the pathways of an ImplementationModelItem have been added or removed. Persist this information in settings. Source code in src/cplus_plugin/gui/model_component_widget.py 440 441 442 443 444 def on_pathways_updated ( self , im_item : ImplementationModelItem ): \"\"\"Slot raised when the pathways of an ImplementationModelItem have been added or removed. Persist this information in settings. \"\"\" self . _save_item ( im_item )","title":"on_pathways_updated()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ImplementationModelComponentWidget.update_ncs_pathway_items","text":"update_ncs_pathway_items ( ncs_pathway ) Update NCS pathway items used for IMs that are linked to the given NCS pathway. Parameters: Name Type Description Default ncs_pathway NcsPathway NCS pathway whose attribute values will be updated for the related pathways used in the IMs. required Returns: Type Description bool True if NCS pathway items were updated, else False. Source code in src/cplus_plugin/gui/model_component_widget.py 643 644 645 646 647 648 649 650 651 652 653 654 def update_ncs_pathway_items ( self , ncs_pathway : NcsPathway ) -> bool : \"\"\"Update NCS pathway items used for IMs that are linked to the given NCS pathway. :param ncs_pathway: NCS pathway whose attribute values will be updated for the related pathways used in the IMs. :type ncs_pathway: NcsPathway :returns: True if NCS pathway items were updated, else False. :rtype: bool \"\"\" return self . item_model . update_ncs_pathway_items ( ncs_pathway )","title":"update_ncs_pathway_items()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ModelComponentWidget","text":"ModelComponentWidget ( parent = None , item_model = None ) Bases: QWidget , WidgetUi Widget for displaying and managing model items in a list view. Source code in src/cplus_plugin/gui/model_component_widget.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def __init__ ( self , parent = None , item_model = None ): super () . __init__ ( parent ) self . setupUi ( self ) self . _item_model = item_model if self . _item_model is not None : self . item_model = self . _item_model add_icon = FileUtils . get_icon ( \"symbologyAdd.svg\" ) self . btn_add . setIcon ( add_icon ) self . btn_add . clicked . connect ( self . _on_add_item ) remove_icon = FileUtils . get_icon ( \"symbologyRemove.svg\" ) self . btn_remove . setIcon ( remove_icon ) self . btn_remove . setEnabled ( False ) self . btn_remove . clicked . connect ( self . _on_remove_item ) edit_icon = FileUtils . get_icon ( \"mActionToggleEditing.svg\" ) self . btn_edit . setIcon ( edit_icon ) self . btn_edit . setEnabled ( False ) self . btn_edit . clicked . connect ( self . _on_edit_item ) reload_icon = FileUtils . get_icon ( \"mActionReload.svg\" ) self . btn_reload . setIcon ( reload_icon ) self . btn_reload . setToolTip ( self . tr ( \"Refresh view\" )) self . btn_reload . clicked . connect ( self . _on_reload ) self . btn_edit_description . setIcon ( edit_icon ) self . btn_edit_description . setToolTip ( self . tr ( \"Edit description\" )) self . btn_edit_description . setEnabled ( False ) self . btn_edit_description . clicked . connect ( self . _on_update_description )","title":"ModelComponentWidget"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ModelComponentWidget.item_model","text":"item_model Returns the component item model for managing items the list view. Returns: Type Description ComponentItemModel Component item model for managing items the list view.","title":"item_model"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ModelComponentWidget.selection_model","text":"selection_model Gets the item's view selection model. Returns: Type Description QtCore.QItemSelectionModel The item's view selection model.","title":"selection_model"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ModelComponentWidget.title","text":"title Returns the title of the view. Returns: Type Description str Title of the view.","title":"title"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ModelComponentWidget.clear","text":"clear () Remove all items in the view. To be implemented by subclasses. Source code in src/cplus_plugin/gui/model_component_widget.py 245 246 247 248 def clear ( self ): \"\"\"Remove all items in the view. To be implemented by subclasses.\"\"\" pass","title":"clear()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ModelComponentWidget.clear_description","text":"clear_description () Clears the content in the description text box. Source code in src/cplus_plugin/gui/model_component_widget.py 190 191 192 193 def clear_description ( self ): \"\"\"Clears the content in the description text box.\"\"\" self . txt_item_description . clear () self . txt_item_description . setToolTip ( \"\" )","title":"clear_description()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ModelComponentWidget.load","text":"load () Subclass to determine how to initialize the items. Source code in src/cplus_plugin/gui/model_component_widget.py 125 126 127 def load ( self ): \"\"\"Subclass to determine how to initialize the items.\"\"\" pass","title":"load()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ModelComponentWidget.model_names","text":"model_names () Gets the names of the components in the item model. Returns: Type Description list Returns the model names in lower case or an empty list if the item model has not been set. Source code in src/cplus_plugin/gui/model_component_widget.py 257 258 259 260 261 262 263 264 265 266 267 268 269 def model_names ( self ) -> typing . List [ str ]: \"\"\"Gets the names of the components in the item model. :returns: Returns the model names in lower case or an empty list if the item model has not been set. :rtype: list \"\"\" if self . _item_model is None : return [] model_components = self . _item_model . model_components () return [ mc . name . lower () for mc in model_components ]","title":"model_names()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ModelComponentWidget.selected_items","text":"selected_items () Returns the selected items in the list view. Returns: Type Description list A collection of the selected model component items. Returns an empty list if the item model has not been set. Source code in src/cplus_plugin/gui/model_component_widget.py 230 231 232 233 234 235 236 237 238 239 240 241 242 243 def selected_items ( self ) -> typing . List [ ModelComponentItemType ]: \"\"\"Returns the selected items in the list view. :returns: A collection of the selected model component items. Returns an empty list if the item model has not been set. :rtype: list \"\"\" if self . _item_model is None : return [] selection_model = self . lst_model_items . selectionModel () idxs = selection_model . selectedRows () return [ self . _item_model . item ( idx . row ()) for idx in idxs ]","title":"selected_items()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ModelComponentWidget.set_description","text":"set_description ( description ) Updates the text for the selected item. Parameters: Name Type Description Default description str Description for the selected item. required Source code in src/cplus_plugin/gui/model_component_widget.py 181 182 183 184 185 186 187 188 def set_description ( self , description : str ): \"\"\"Updates the text for the selected item. :param description: Description for the selected item. :type description: str \"\"\" self . txt_item_description . setText ( description ) self . txt_item_description . setToolTip ( description )","title":"set_description()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.NcsComponentWidget","text":"NcsComponentWidget ( parent = None ) Bases: ModelComponentWidget Widget for displaying and managing NCS pathways. Source code in src/cplus_plugin/gui/model_component_widget.py 277 278 279 280 281 282 283 284 def __init__ ( self , parent = None ): super () . __init__ ( parent ) self . item_model = NcsPathwayItemModel ( parent ) self . lst_model_items . setDragEnabled ( True ) self . lst_model_items . setDragDropMode ( QtWidgets . QAbstractItemView . DragOnly ) self . lst_model_items . setAcceptDrops ( False )","title":"NcsComponentWidget"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.NcsComponentWidget.add_ncs_pathway","text":"add_ncs_pathway ( ncs_pathway ) Adds an NCS pathway object to the view. Parameters: Name Type Description Default ncs_pathway NcsPathway NCS pathway object to be added to the view. required Returns: Type Description bool Returns True if the NcsPathway was successfully added, else False. Source code in src/cplus_plugin/gui/model_component_widget.py 286 287 288 289 290 291 292 293 294 295 296 def add_ncs_pathway ( self , ncs_pathway : NcsPathway ) -> bool : \"\"\"Adds an NCS pathway object to the view. :param ncs_pathway: NCS pathway object to be added to the view. :type ncs_pathway: NcsPathway :returns: Returns True if the NcsPathway was successfully added, else False. :rtype: bool \"\"\" return self . item_model . add_ncs_pathway ( ncs_pathway )","title":"add_ncs_pathway()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.NcsComponentWidget.clear","text":"clear () Removes all NCS pathway items in the view. Source code in src/cplus_plugin/gui/model_component_widget.py 298 299 300 301 302 def clear ( self ): \"\"\"Removes all NCS pathway items in the view.\"\"\" items = self . ncs_items () for item in items : self . item_model . remove_ncs_pathway ( item . uuid )","title":"clear()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.NcsComponentWidget.load","text":"load () Load items from settings. Source code in src/cplus_plugin/gui/model_component_widget.py 389 390 391 392 393 394 395 396 def load ( self ): \"\"\"Load items from settings.\"\"\" self . clear () settings_manager . update_ncs_pathways () ncs_pathways = settings_manager . get_all_ncs_pathways () for ncs in ncs_pathways : self . add_ncs_pathway ( ncs )","title":"load()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.NcsComponentWidget.ncs_items","text":"ncs_items () Returns a collection of all NcsPathwayItem objects in the list view. Returns: Type Description list Collection of NcsPathwayItem objects in the list view. Source code in src/cplus_plugin/gui/model_component_widget.py 316 317 318 319 320 321 322 323 def ncs_items ( self ) -> typing . List [ NcsPathwayItem ]: \"\"\"Returns a collection of all NcsPathwayItem objects in the list view. :returns: Collection of NcsPathwayItem objects in the list view. :rtype: list \"\"\" return self . item_model . model_component_items ()","title":"ncs_items()"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.NcsComponentWidget.pathways","text":"pathways ( valid_only = False ) Returns a collection of NcsPathway objects in the list view. Parameters: Name Type Description Default valid_only bool True to only return those NcsPathway objects that are valid, default is False. False Returns: Type Description list Collection of NcsPathway objects in the list view. Source code in src/cplus_plugin/gui/model_component_widget.py 304 305 306 307 308 309 310 311 312 313 314 def pathways ( self , valid_only = False ) -> typing . List [ NcsPathway ]: \"\"\"Returns a collection of NcsPathway objects in the list view. :param valid_only: True to only return those NcsPathway objects that are valid, default is False. :type valid_only: bool :returns: Collection of NcsPathway objects in the list view. :rtype: list \"\"\" return self . item_model . pathways ( valid_only )","title":"pathways()"},{"location":"developer/api/gui/api_ncs_pathway_editor/","text":"NCS patway editor Dialog for creating or editing an NCS pathway entry. NcsPathwayEditorDialog NcsPathwayEditorDialog ( parent = None , ncs_pathway = None , excluded_names = None ) Bases: QDialog , WidgetUi Dialog for creating or editing an NCS pathway entry. Source code in src/cplus_plugin/gui/ncs_pathway_editor_dialog.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def __init__ ( self , parent = None , ncs_pathway = None , excluded_names = None ): super () . __init__ ( parent ) self . setupUi ( self ) QgsGui . enableAutoGeometryRestore ( self ) self . _message_bar = QgsMessageBar () self . vl_notification . addWidget ( self . _message_bar ) self . _carbon_model = CarbonLayerModel ( self ) self . lst_carbon_layers . setModel ( self . _carbon_model ) self . lst_carbon_layers . selectionModel () . selectionChanged . connect ( self . _on_selection_changed ) self . buttonBox . accepted . connect ( self . _on_accepted ) self . btn_add_layer . clicked . connect ( self . _on_select_file ) icon_pixmap = QtGui . QPixmap ( ICON_PATH ) self . icon_la . setPixmap ( icon_pixmap ) help_icon = FileUtils . get_icon ( \"mActionHelpContents.svg\" ) self . btn_help . setIcon ( help_icon ) add_icon = FileUtils . get_icon ( \"symbologyAdd.svg\" ) self . btn_add_carbon . setIcon ( add_icon ) self . btn_add_carbon . clicked . connect ( self . _on_add_carbon_layer ) remove_icon = FileUtils . get_icon ( \"symbologyRemove.svg\" ) self . btn_delete_carbon . setIcon ( remove_icon ) self . btn_delete_carbon . setEnabled ( False ) self . btn_delete_carbon . clicked . connect ( self . _on_remove_carbon_layer ) edit_icon = FileUtils . get_icon ( \"mActionToggleEditing.svg\" ) self . btn_edit_carbon . setIcon ( edit_icon ) self . btn_edit_carbon . setEnabled ( False ) self . btn_edit_carbon . clicked . connect ( self . _on_edit_carbon_layer ) # Set to use default carbon coefficient defined in settings carbon_coefficient = settings_manager . get_value ( Settings . CARBON_COEFFICIENT , 0.0 , float ) self . sb_carbon_coefficient . setValue ( carbon_coefficient ) self . _excluded_names = excluded_names if excluded_names is None : self . _excluded_names = [] self . _edit_mode = False self . _layer = None self . _ncs_pathway = ncs_pathway if self . _ncs_pathway is not None : self . _edit_mode = True self . _layer = self . _ncs_pathway . to_map_layer () self . _update_controls () edit_mode property edit_mode Returns the state of the editor. Returns: Type Description bool True if the editor is editing an existing NcsPathway object, else False if its creating a new object. layer property layer Returns the raster layer specified by the user, either existing layers in the map canvas or from the selected file. Returns: Type Description QgsRasterLayer The raster layer specified by the user or None if not set. ncs_pathway property ncs_pathway Returns a reference to the NcsPathway object. Returns: Type Description NcsPathway Reference to the NcsPathway object. selected_carbon_items selected_carbon_items () Returns the selected carbon items in the list view. Returns: Type Description list A collection of the selected carbon items. Source code in src/cplus_plugin/gui/ncs_pathway_editor_dialog.py 232 233 234 235 236 237 238 239 240 241 def selected_carbon_items ( self ) -> typing . List [ CarbonLayerItem ]: \"\"\"Returns the selected carbon items in the list view. :returns: A collection of the selected carbon items. :rtype: list \"\"\" selection_model = self . lst_carbon_layers . selectionModel () idxs = selection_model . selectedRows () return [ self . _carbon_model . item ( idx . row ()) for idx in idxs ] validate validate () Validates if name and layer have been specified. Returns: Type Description True True if user input (i.e. name and layer) have been set. Source code in src/cplus_plugin/gui/ncs_pathway_editor_dialog.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 def validate ( self ) -> bool : \"\"\"Validates if name and layer have been specified. :returns: True if user input (i.e. name and layer) have been set. :rtype: True \"\"\" status = True self . _message_bar . clearWidgets () name = self . txt_name . text () if not name : msg = tr ( \"NCS pathway name cannot be empty.\" ) self . _show_warning_message ( msg ) status = False if name . lower () in self . _excluded_names : msg = tr ( \"name has already been used.\" ) self . _show_warning_message ( f \"' { name } ' { msg } \" ) status = False if not self . txt_description . toPlainText (): msg = tr ( \"Description cannot be empty.\" ) self . _show_warning_message ( msg ) status = False layer = self . _get_selected_map_layer () if layer is None : msg = tr ( \"Map layer not specified.\" ) self . _show_warning_message ( msg ) status = False if layer and not layer . isValid (): msg = tr ( \"Map layer is not valid.\" ) self . _show_warning_message ( msg ) status = False return status","title":"NCS Pathway editor"},{"location":"developer/api/gui/api_ncs_pathway_editor/#ncs-patway-editor","text":"Dialog for creating or editing an NCS pathway entry.","title":"NCS patway editor"},{"location":"developer/api/gui/api_ncs_pathway_editor/#src.cplus_plugin.gui.ncs_pathway_editor_dialog.NcsPathwayEditorDialog","text":"NcsPathwayEditorDialog ( parent = None , ncs_pathway = None , excluded_names = None ) Bases: QDialog , WidgetUi Dialog for creating or editing an NCS pathway entry. Source code in src/cplus_plugin/gui/ncs_pathway_editor_dialog.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def __init__ ( self , parent = None , ncs_pathway = None , excluded_names = None ): super () . __init__ ( parent ) self . setupUi ( self ) QgsGui . enableAutoGeometryRestore ( self ) self . _message_bar = QgsMessageBar () self . vl_notification . addWidget ( self . _message_bar ) self . _carbon_model = CarbonLayerModel ( self ) self . lst_carbon_layers . setModel ( self . _carbon_model ) self . lst_carbon_layers . selectionModel () . selectionChanged . connect ( self . _on_selection_changed ) self . buttonBox . accepted . connect ( self . _on_accepted ) self . btn_add_layer . clicked . connect ( self . _on_select_file ) icon_pixmap = QtGui . QPixmap ( ICON_PATH ) self . icon_la . setPixmap ( icon_pixmap ) help_icon = FileUtils . get_icon ( \"mActionHelpContents.svg\" ) self . btn_help . setIcon ( help_icon ) add_icon = FileUtils . get_icon ( \"symbologyAdd.svg\" ) self . btn_add_carbon . setIcon ( add_icon ) self . btn_add_carbon . clicked . connect ( self . _on_add_carbon_layer ) remove_icon = FileUtils . get_icon ( \"symbologyRemove.svg\" ) self . btn_delete_carbon . setIcon ( remove_icon ) self . btn_delete_carbon . setEnabled ( False ) self . btn_delete_carbon . clicked . connect ( self . _on_remove_carbon_layer ) edit_icon = FileUtils . get_icon ( \"mActionToggleEditing.svg\" ) self . btn_edit_carbon . setIcon ( edit_icon ) self . btn_edit_carbon . setEnabled ( False ) self . btn_edit_carbon . clicked . connect ( self . _on_edit_carbon_layer ) # Set to use default carbon coefficient defined in settings carbon_coefficient = settings_manager . get_value ( Settings . CARBON_COEFFICIENT , 0.0 , float ) self . sb_carbon_coefficient . setValue ( carbon_coefficient ) self . _excluded_names = excluded_names if excluded_names is None : self . _excluded_names = [] self . _edit_mode = False self . _layer = None self . _ncs_pathway = ncs_pathway if self . _ncs_pathway is not None : self . _edit_mode = True self . _layer = self . _ncs_pathway . to_map_layer () self . _update_controls ()","title":"NcsPathwayEditorDialog"},{"location":"developer/api/gui/api_ncs_pathway_editor/#src.cplus_plugin.gui.ncs_pathway_editor_dialog.NcsPathwayEditorDialog.edit_mode","text":"edit_mode Returns the state of the editor. Returns: Type Description bool True if the editor is editing an existing NcsPathway object, else False if its creating a new object.","title":"edit_mode"},{"location":"developer/api/gui/api_ncs_pathway_editor/#src.cplus_plugin.gui.ncs_pathway_editor_dialog.NcsPathwayEditorDialog.layer","text":"layer Returns the raster layer specified by the user, either existing layers in the map canvas or from the selected file. Returns: Type Description QgsRasterLayer The raster layer specified by the user or None if not set.","title":"layer"},{"location":"developer/api/gui/api_ncs_pathway_editor/#src.cplus_plugin.gui.ncs_pathway_editor_dialog.NcsPathwayEditorDialog.ncs_pathway","text":"ncs_pathway Returns a reference to the NcsPathway object. Returns: Type Description NcsPathway Reference to the NcsPathway object.","title":"ncs_pathway"},{"location":"developer/api/gui/api_ncs_pathway_editor/#src.cplus_plugin.gui.ncs_pathway_editor_dialog.NcsPathwayEditorDialog.selected_carbon_items","text":"selected_carbon_items () Returns the selected carbon items in the list view. Returns: Type Description list A collection of the selected carbon items. Source code in src/cplus_plugin/gui/ncs_pathway_editor_dialog.py 232 233 234 235 236 237 238 239 240 241 def selected_carbon_items ( self ) -> typing . List [ CarbonLayerItem ]: \"\"\"Returns the selected carbon items in the list view. :returns: A collection of the selected carbon items. :rtype: list \"\"\" selection_model = self . lst_carbon_layers . selectionModel () idxs = selection_model . selectedRows () return [ self . _carbon_model . item ( idx . row ()) for idx in idxs ]","title":"selected_carbon_items()"},{"location":"developer/api/gui/api_ncs_pathway_editor/#src.cplus_plugin.gui.ncs_pathway_editor_dialog.NcsPathwayEditorDialog.validate","text":"validate () Validates if name and layer have been specified. Returns: Type Description True True if user input (i.e. name and layer) have been set. Source code in src/cplus_plugin/gui/ncs_pathway_editor_dialog.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 def validate ( self ) -> bool : \"\"\"Validates if name and layer have been specified. :returns: True if user input (i.e. name and layer) have been set. :rtype: True \"\"\" status = True self . _message_bar . clearWidgets () name = self . txt_name . text () if not name : msg = tr ( \"NCS pathway name cannot be empty.\" ) self . _show_warning_message ( msg ) status = False if name . lower () in self . _excluded_names : msg = tr ( \"name has already been used.\" ) self . _show_warning_message ( f \"' { name } ' { msg } \" ) status = False if not self . txt_description . toPlainText (): msg = tr ( \"Description cannot be empty.\" ) self . _show_warning_message ( msg ) status = False layer = self . _get_selected_map_layer () if layer is None : msg = tr ( \"Map layer not specified.\" ) self . _show_warning_message ( msg ) status = False if layer and not layer . isValid (): msg = tr ( \"Map layer is not valid.\" ) self . _show_warning_message ( msg ) status = False return status","title":"validate()"},{"location":"developer/api/gui/api_priority_group/","text":"Priority group Priority group item widget PriorityGroupWidget PriorityGroupWidget ( group , parent = None ) Bases: QWidget , WidgetUi Widget that provide UI for priority group details. Source code in src/cplus_plugin/gui/priority_group_widget.py 29 30 31 32 33 34 35 36 37 38 def __init__ ( self , group , parent = None , ): super () . __init__ ( parent ) self . setupUi ( self ) self . group = group self . initialize_ui () group_value group_value () Returns: name (dict): Priority group value Source code in src/cplus_plugin/gui/priority_group_widget.py 72 73 74 75 76 77 def group_value ( self ): \"\"\" Returns: name (dict): Priority group value \"\"\" return self . group_slider . value () initialize_ui initialize_ui () Populate UI inputs when loading the widget Source code in src/cplus_plugin/gui/priority_group_widget.py 40 41 42 43 44 45 46 47 48 49 def initialize_ui ( self ): \"\"\"Populate UI inputs when loading the widget\"\"\" if self . group is not None : self . group_la . setText ( self . group . get ( \"name\" )) self . group_slider . setValue ( int ( self . group . get ( \"value\" , 0 ))) self . group_spin_box . setValue ( int ( self . group . get ( \"value\" , 0 ))) self . group_slider . valueChanged . connect ( self . update_spin_box ) self . group_spin_box . valueChanged . connect ( self . update_slider ) name name () Returns: name (dict): Priority group name Source code in src/cplus_plugin/gui/priority_group_widget.py 65 66 67 68 69 70 def name ( self ): \"\"\" Returns: name (dict): Priority group name \"\"\" return self . group . get ( \"name\" ) set_group set_group ( group ) Sets the priority layer group and updates the slider and input values Args: group (dict): Priority group Source code in src/cplus_plugin/gui/priority_group_widget.py 51 52 53 54 55 56 57 58 59 60 61 62 63 def set_group ( self , group ): \"\"\"Sets the priority layer group and updates the slider and input values Args: group (dict): Priority group \"\"\" if group is not None : self . group = group self . group_la . setText ( group . get ( \"name\" )) self . group_slider . setValue ( int ( group [ \"value\" ])) self . group_spin_box . setValue ( int ( group [ \"value\" ])) update_slider update_slider ( value ) Changes the current slider value. Args: value (int): Value to be set on the slider Note: Emits input_value_changed signal Source code in src/cplus_plugin/gui/priority_group_widget.py 79 80 81 82 83 84 85 86 87 88 89 90 91 def update_slider ( self , value ): \"\"\"Changes the current slider value. Args: value (int): Value to be set on the slider Note: Emits input_value_changed signal \"\"\" if self . group is not None : self . input_value_changed . emit ( self . group [ \"name\" ], value ) self . group_slider . blockSignals ( True ) self . group_slider . setValue ( value ) self . group_slider . blockSignals ( False ) update_spin_box update_spin_box ( value ) Changes the input value of the spin box Args: value (int): Value to be set on the spin box. Note: Emits slider_value_changed signal Source code in src/cplus_plugin/gui/priority_group_widget.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def update_spin_box ( self , value ): \"\"\"Changes the input value of the spin box Args: value (int): Value to be set on the spin box. Note: Emits slider_value_changed signal \"\"\" if self . group is not None : self . slider_value_changed . emit ( self . group [ \"name\" ], value ) self . group_spin_box . blockSignals ( True ) self . group_spin_box . setValue ( value ) self . group_spin_box . blockSignals ( False ) widgets widgets () Returns widget_list (list): List of component widgets for the priority group widget Source code in src/cplus_plugin/gui/priority_group_widget.py 108 109 110 111 112 113 114 def widgets ( self ) -> typing . List [ QtWidgets . QWidget ]: \"\"\" Returns widget_list (list): List of component widgets for the priority group widget \"\"\" return [ self . group_la , self . group_slider , self . group_spin_box ]","title":"Priority group"},{"location":"developer/api/gui/api_priority_group/#priority-group","text":"Priority group item widget","title":"Priority group"},{"location":"developer/api/gui/api_priority_group/#src.cplus_plugin.gui.priority_group_widget.PriorityGroupWidget","text":"PriorityGroupWidget ( group , parent = None ) Bases: QWidget , WidgetUi Widget that provide UI for priority group details. Source code in src/cplus_plugin/gui/priority_group_widget.py 29 30 31 32 33 34 35 36 37 38 def __init__ ( self , group , parent = None , ): super () . __init__ ( parent ) self . setupUi ( self ) self . group = group self . initialize_ui ()","title":"PriorityGroupWidget"},{"location":"developer/api/gui/api_priority_group/#src.cplus_plugin.gui.priority_group_widget.PriorityGroupWidget.group_value","text":"group_value () Returns: name (dict): Priority group value Source code in src/cplus_plugin/gui/priority_group_widget.py 72 73 74 75 76 77 def group_value ( self ): \"\"\" Returns: name (dict): Priority group value \"\"\" return self . group_slider . value ()","title":"group_value()"},{"location":"developer/api/gui/api_priority_group/#src.cplus_plugin.gui.priority_group_widget.PriorityGroupWidget.initialize_ui","text":"initialize_ui () Populate UI inputs when loading the widget Source code in src/cplus_plugin/gui/priority_group_widget.py 40 41 42 43 44 45 46 47 48 49 def initialize_ui ( self ): \"\"\"Populate UI inputs when loading the widget\"\"\" if self . group is not None : self . group_la . setText ( self . group . get ( \"name\" )) self . group_slider . setValue ( int ( self . group . get ( \"value\" , 0 ))) self . group_spin_box . setValue ( int ( self . group . get ( \"value\" , 0 ))) self . group_slider . valueChanged . connect ( self . update_spin_box ) self . group_spin_box . valueChanged . connect ( self . update_slider )","title":"initialize_ui()"},{"location":"developer/api/gui/api_priority_group/#src.cplus_plugin.gui.priority_group_widget.PriorityGroupWidget.name","text":"name () Returns: name (dict): Priority group name Source code in src/cplus_plugin/gui/priority_group_widget.py 65 66 67 68 69 70 def name ( self ): \"\"\" Returns: name (dict): Priority group name \"\"\" return self . group . get ( \"name\" )","title":"name()"},{"location":"developer/api/gui/api_priority_group/#src.cplus_plugin.gui.priority_group_widget.PriorityGroupWidget.set_group","text":"set_group ( group ) Sets the priority layer group and updates the slider and input values Args: group (dict): Priority group Source code in src/cplus_plugin/gui/priority_group_widget.py 51 52 53 54 55 56 57 58 59 60 61 62 63 def set_group ( self , group ): \"\"\"Sets the priority layer group and updates the slider and input values Args: group (dict): Priority group \"\"\" if group is not None : self . group = group self . group_la . setText ( group . get ( \"name\" )) self . group_slider . setValue ( int ( group [ \"value\" ])) self . group_spin_box . setValue ( int ( group [ \"value\" ]))","title":"set_group()"},{"location":"developer/api/gui/api_priority_group/#src.cplus_plugin.gui.priority_group_widget.PriorityGroupWidget.update_slider","text":"update_slider ( value ) Changes the current slider value. Args: value (int): Value to be set on the slider Note: Emits input_value_changed signal Source code in src/cplus_plugin/gui/priority_group_widget.py 79 80 81 82 83 84 85 86 87 88 89 90 91 def update_slider ( self , value ): \"\"\"Changes the current slider value. Args: value (int): Value to be set on the slider Note: Emits input_value_changed signal \"\"\" if self . group is not None : self . input_value_changed . emit ( self . group [ \"name\" ], value ) self . group_slider . blockSignals ( True ) self . group_slider . setValue ( value ) self . group_slider . blockSignals ( False )","title":"update_slider()"},{"location":"developer/api/gui/api_priority_group/#src.cplus_plugin.gui.priority_group_widget.PriorityGroupWidget.update_spin_box","text":"update_spin_box ( value ) Changes the input value of the spin box Args: value (int): Value to be set on the spin box. Note: Emits slider_value_changed signal Source code in src/cplus_plugin/gui/priority_group_widget.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def update_spin_box ( self , value ): \"\"\"Changes the input value of the spin box Args: value (int): Value to be set on the spin box. Note: Emits slider_value_changed signal \"\"\" if self . group is not None : self . slider_value_changed . emit ( self . group [ \"name\" ], value ) self . group_spin_box . blockSignals ( True ) self . group_spin_box . setValue ( value ) self . group_spin_box . blockSignals ( False )","title":"update_spin_box()"},{"location":"developer/api/gui/api_priority_group/#src.cplus_plugin.gui.priority_group_widget.PriorityGroupWidget.widgets","text":"widgets () Returns widget_list (list): List of component widgets for the priority group widget Source code in src/cplus_plugin/gui/priority_group_widget.py 108 109 110 111 112 113 114 def widgets ( self ) -> typing . List [ QtWidgets . QWidget ]: \"\"\" Returns widget_list (list): List of component widgets for the priority group widget \"\"\" return [ self . group_la , self . group_slider , self . group_spin_box ]","title":"widgets()"},{"location":"developer/api/gui/api_priority_layer/","text":"Priority weighting layer dialog Priority layer dialog PriorityLayerDialog PriorityLayerDialog ( layer = None , parent = None ) Bases: QDialog , DialogUi Dialog that provide UI for priority layer details. Source code in src/cplus_plugin/gui/priority_layer_dialog.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def __init__ ( self , layer = None , parent = None , ): super () . __init__ ( parent ) self . setupUi ( self ) self . layer = layer self . button_box . button ( QtWidgets . QDialogButtonBox . Ok ) . setEnabled ( False ) self . map_layer_box . layerChanged . connect ( self . map_layer_changed ) ok_signals = [ self . layer_name . textChanged , self . layer_description . textChanged , self . map_layer_file_widget . fileChanged , self . map_layer_box . layerChanged , ] for signal in ok_signals : signal . connect ( self . update_ok_buttons ) icon_pixmap = QtGui . QPixmap ( ICON_PATH ) self . icon_la . setPixmap ( icon_pixmap ) self . models = [] self . initialize_ui () accept accept () Handles logic for adding new priority layer and edit existing one Source code in src/cplus_plugin/gui/priority_layer_dialog.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 def accept ( self ): \"\"\"Handles logic for adding new priority layer and edit existing one\"\"\" layer_id = uuid . uuid4 () layer_groups = [] layer = {} if self . layer is not None : layer_id = self . layer . get ( \"uuid\" ) layer_groups = self . layer . get ( \"groups\" , []) layer [ \"uuid\" ] = str ( layer_id ) layer [ \"name\" ] = self . layer_name . text () layer [ \"description\" ] = self . layer_description . toPlainText () layer [ \"groups\" ] = layer_groups layer [ \"path\" ] = self . map_layer_file_widget . filePath () settings_manager . save_priority_layer ( layer ) self . layer = layer self . set_selected_models ( self . models ) super () . accept () initialize_ui initialize_ui () Populate UI inputs when loading the dialog Source code in src/cplus_plugin/gui/priority_layer_dialog.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 def initialize_ui ( self ): \"\"\"Populate UI inputs when loading the dialog\"\"\" self . btn_help . setIcon ( FileUtils . get_icon ( \"mActionHelpContents.svg\" )) self . btn_help . clicked . connect ( self . open_help ) self . map_layer_file_widget . setStorageMode ( QgsFileWidget . StorageMode . GetFile ) self . select_models_btn . clicked . connect ( self . open_layer_select_dialog ) if self . layer is not None : layer_path = self . layer . get ( \"path\" ) layer_uuids = [ layer . get ( \"uuid\" ) for layer in PRIORITY_LAYERS ] if not os . path . isabs ( layer_path ) and self . layer . get ( \"uuid\" ) in layer_uuids : base_dir = settings_manager . get_value ( Settings . BASE_DIR ) layer_path = f \" { base_dir } / { PRIORITY_LAYERS_SEGMENT } / { layer_path } \" self . layer_name . setText ( self . layer [ \"name\" ]) self . layer_description . setText ( self . layer [ \"description\" ]) self . map_layer_file_widget . setFilePath ( layer_path ) all_models = settings_manager . get_all_implementation_models () for model in all_models : model_layer_uuids = [ layer . get ( \"uuid\" ) for layer in model . priority_layers ] if str ( self . layer . get ( \"uuid\" )) in model_layer_uuids : self . models . append ( model ) self . set_selected_models ( self . models ) map_layer_changed map_layer_changed ( layer ) Sets the file path of the selected layer in file path input Parameters: Name Type Description Default layer QgsMapLayer Qgis map layer required Source code in src/cplus_plugin/gui/priority_layer_dialog.py 64 65 66 67 68 69 70 71 def map_layer_changed ( self , layer ): \"\"\"Sets the file path of the selected layer in file path input :param layer: Qgis map layer :type layer: QgsMapLayer \"\"\" if layer is not None : self . map_layer_file_widget . setFilePath ( layer . source ()) open_help open_help () Opens the user documentation for the plugin in a browser Source code in src/cplus_plugin/gui/priority_layer_dialog.py 192 193 194 def open_help ( self ): \"\"\"Opens the user documentation for the plugin in a browser\"\"\" open_documentation ( USER_DOCUMENTATION_SITE ) open_layer_select_dialog open_layer_select_dialog () Opens priority layer item selection dialog Source code in src/cplus_plugin/gui/priority_layer_dialog.py 124 125 126 127 def open_layer_select_dialog ( self ): \"\"\"Opens priority layer item selection dialog\"\"\" model_select_dialog = ItemsSelectionDialog ( self , self . layer , self . models ) model_select_dialog . exec_ () set_selected_models set_selected_models ( models , removed_models = []) Adds this dialog layer into the passed models and removes it from the unselected models passed as removed_models. Parameters: Name Type Description Default models list Selected implementation models required removed_models list Implementation models that dialog layer should be removed from. [] Source code in src/cplus_plugin/gui/priority_layer_dialog.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 def set_selected_models ( self , models , removed_models = []): \"\"\"Adds this dialog layer into the passed models and removes it from the unselected models passed as removed_models. :param models: Selected implementation models :type models: list :param removed_models: Implementation models that dialog layer should be removed from. :type removed_models: list \"\"\" self . models = models models_names = [ model . name for model in models ] self . selected_models_le . setText ( \" , \" . join ( models_names )) if not self . layer : return if len ( removed_models ) <= 0 : all_models = settings_manager . get_all_implementation_models () removed_models = [ model for model in all_models if model . name not in models_names ] for model in models : models_layer_uuids = [ str ( layer . get ( \"uuid\" )) for layer in model . priority_layers ] if str ( self . layer . get ( \"uuid\" )) not in models_layer_uuids : model . priority_layers . append ( self . layer ) settings_manager . save_implementation_model ( model ) for model in removed_models : for layer in model . priority_layers : if str ( layer . get ( \"uuid\" )) == str ( self . layer . get ( \"uuid\" )): model . priority_layers . remove ( layer ) settings_manager . save_implementation_model ( model ) update_ok_buttons update_ok_buttons () Responsible for changing the state of the dialog OK button. Source code in src/cplus_plugin/gui/priority_layer_dialog.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def update_ok_buttons ( self ): \"\"\"Responsible for changing the state of the dialog OK button. \"\"\" enabled_state = ( self . layer_name . text () != \"\" and self . layer_description . toPlainText () != \"\" and ( self . map_layer_box . currentLayer () is not None or ( self . map_layer_file_widget . filePath () is not None and self . map_layer_file_widget . filePath () is not \"\" ) ) ) self . button_box . button ( QtWidgets . QDialogButtonBox . Ok ) . setEnabled ( enabled_state )","title":"Priority layer dialog"},{"location":"developer/api/gui/api_priority_layer/#priority-weighting-layer-dialog","text":"Priority layer dialog","title":"Priority weighting layer dialog"},{"location":"developer/api/gui/api_priority_layer/#src.cplus_plugin.gui.priority_layer_dialog.PriorityLayerDialog","text":"PriorityLayerDialog ( layer = None , parent = None ) Bases: QDialog , DialogUi Dialog that provide UI for priority layer details. Source code in src/cplus_plugin/gui/priority_layer_dialog.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def __init__ ( self , layer = None , parent = None , ): super () . __init__ ( parent ) self . setupUi ( self ) self . layer = layer self . button_box . button ( QtWidgets . QDialogButtonBox . Ok ) . setEnabled ( False ) self . map_layer_box . layerChanged . connect ( self . map_layer_changed ) ok_signals = [ self . layer_name . textChanged , self . layer_description . textChanged , self . map_layer_file_widget . fileChanged , self . map_layer_box . layerChanged , ] for signal in ok_signals : signal . connect ( self . update_ok_buttons ) icon_pixmap = QtGui . QPixmap ( ICON_PATH ) self . icon_la . setPixmap ( icon_pixmap ) self . models = [] self . initialize_ui ()","title":"PriorityLayerDialog"},{"location":"developer/api/gui/api_priority_layer/#src.cplus_plugin.gui.priority_layer_dialog.PriorityLayerDialog.accept","text":"accept () Handles logic for adding new priority layer and edit existing one Source code in src/cplus_plugin/gui/priority_layer_dialog.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 def accept ( self ): \"\"\"Handles logic for adding new priority layer and edit existing one\"\"\" layer_id = uuid . uuid4 () layer_groups = [] layer = {} if self . layer is not None : layer_id = self . layer . get ( \"uuid\" ) layer_groups = self . layer . get ( \"groups\" , []) layer [ \"uuid\" ] = str ( layer_id ) layer [ \"name\" ] = self . layer_name . text () layer [ \"description\" ] = self . layer_description . toPlainText () layer [ \"groups\" ] = layer_groups layer [ \"path\" ] = self . map_layer_file_widget . filePath () settings_manager . save_priority_layer ( layer ) self . layer = layer self . set_selected_models ( self . models ) super () . accept ()","title":"accept()"},{"location":"developer/api/gui/api_priority_layer/#src.cplus_plugin.gui.priority_layer_dialog.PriorityLayerDialog.initialize_ui","text":"initialize_ui () Populate UI inputs when loading the dialog Source code in src/cplus_plugin/gui/priority_layer_dialog.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 def initialize_ui ( self ): \"\"\"Populate UI inputs when loading the dialog\"\"\" self . btn_help . setIcon ( FileUtils . get_icon ( \"mActionHelpContents.svg\" )) self . btn_help . clicked . connect ( self . open_help ) self . map_layer_file_widget . setStorageMode ( QgsFileWidget . StorageMode . GetFile ) self . select_models_btn . clicked . connect ( self . open_layer_select_dialog ) if self . layer is not None : layer_path = self . layer . get ( \"path\" ) layer_uuids = [ layer . get ( \"uuid\" ) for layer in PRIORITY_LAYERS ] if not os . path . isabs ( layer_path ) and self . layer . get ( \"uuid\" ) in layer_uuids : base_dir = settings_manager . get_value ( Settings . BASE_DIR ) layer_path = f \" { base_dir } / { PRIORITY_LAYERS_SEGMENT } / { layer_path } \" self . layer_name . setText ( self . layer [ \"name\" ]) self . layer_description . setText ( self . layer [ \"description\" ]) self . map_layer_file_widget . setFilePath ( layer_path ) all_models = settings_manager . get_all_implementation_models () for model in all_models : model_layer_uuids = [ layer . get ( \"uuid\" ) for layer in model . priority_layers ] if str ( self . layer . get ( \"uuid\" )) in model_layer_uuids : self . models . append ( model ) self . set_selected_models ( self . models )","title":"initialize_ui()"},{"location":"developer/api/gui/api_priority_layer/#src.cplus_plugin.gui.priority_layer_dialog.PriorityLayerDialog.map_layer_changed","text":"map_layer_changed ( layer ) Sets the file path of the selected layer in file path input Parameters: Name Type Description Default layer QgsMapLayer Qgis map layer required Source code in src/cplus_plugin/gui/priority_layer_dialog.py 64 65 66 67 68 69 70 71 def map_layer_changed ( self , layer ): \"\"\"Sets the file path of the selected layer in file path input :param layer: Qgis map layer :type layer: QgsMapLayer \"\"\" if layer is not None : self . map_layer_file_widget . setFilePath ( layer . source ())","title":"map_layer_changed()"},{"location":"developer/api/gui/api_priority_layer/#src.cplus_plugin.gui.priority_layer_dialog.PriorityLayerDialog.open_help","text":"open_help () Opens the user documentation for the plugin in a browser Source code in src/cplus_plugin/gui/priority_layer_dialog.py 192 193 194 def open_help ( self ): \"\"\"Opens the user documentation for the plugin in a browser\"\"\" open_documentation ( USER_DOCUMENTATION_SITE )","title":"open_help()"},{"location":"developer/api/gui/api_priority_layer/#src.cplus_plugin.gui.priority_layer_dialog.PriorityLayerDialog.open_layer_select_dialog","text":"open_layer_select_dialog () Opens priority layer item selection dialog Source code in src/cplus_plugin/gui/priority_layer_dialog.py 124 125 126 127 def open_layer_select_dialog ( self ): \"\"\"Opens priority layer item selection dialog\"\"\" model_select_dialog = ItemsSelectionDialog ( self , self . layer , self . models ) model_select_dialog . exec_ ()","title":"open_layer_select_dialog()"},{"location":"developer/api/gui/api_priority_layer/#src.cplus_plugin.gui.priority_layer_dialog.PriorityLayerDialog.set_selected_models","text":"set_selected_models ( models , removed_models = []) Adds this dialog layer into the passed models and removes it from the unselected models passed as removed_models. Parameters: Name Type Description Default models list Selected implementation models required removed_models list Implementation models that dialog layer should be removed from. [] Source code in src/cplus_plugin/gui/priority_layer_dialog.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 def set_selected_models ( self , models , removed_models = []): \"\"\"Adds this dialog layer into the passed models and removes it from the unselected models passed as removed_models. :param models: Selected implementation models :type models: list :param removed_models: Implementation models that dialog layer should be removed from. :type removed_models: list \"\"\" self . models = models models_names = [ model . name for model in models ] self . selected_models_le . setText ( \" , \" . join ( models_names )) if not self . layer : return if len ( removed_models ) <= 0 : all_models = settings_manager . get_all_implementation_models () removed_models = [ model for model in all_models if model . name not in models_names ] for model in models : models_layer_uuids = [ str ( layer . get ( \"uuid\" )) for layer in model . priority_layers ] if str ( self . layer . get ( \"uuid\" )) not in models_layer_uuids : model . priority_layers . append ( self . layer ) settings_manager . save_implementation_model ( model ) for model in removed_models : for layer in model . priority_layers : if str ( layer . get ( \"uuid\" )) == str ( self . layer . get ( \"uuid\" )): model . priority_layers . remove ( layer ) settings_manager . save_implementation_model ( model )","title":"set_selected_models()"},{"location":"developer/api/gui/api_priority_layer/#src.cplus_plugin.gui.priority_layer_dialog.PriorityLayerDialog.update_ok_buttons","text":"update_ok_buttons () Responsible for changing the state of the dialog OK button. Source code in src/cplus_plugin/gui/priority_layer_dialog.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def update_ok_buttons ( self ): \"\"\"Responsible for changing the state of the dialog OK button. \"\"\" enabled_state = ( self . layer_name . text () != \"\" and self . layer_description . toPlainText () != \"\" and ( self . map_layer_box . currentLayer () is not None or ( self . map_layer_file_widget . filePath () is not None and self . map_layer_file_widget . filePath () is not \"\" ) ) ) self . button_box . button ( QtWidgets . QDialogButtonBox . Ok ) . setEnabled ( enabled_state )","title":"update_ok_buttons()"},{"location":"developer/api/gui/api_progress_dialog/","text":"Progress dialog at the top ProgressDialog ProgressDialog ( init_message = 'Processing' , scenario_name = 'Scenario' , minimum = 0 , maximum = 100 , main_widget = None , parent = None ) Bases: QDialog , Ui_DlgProgress This progress dialog Source code in src/cplus_plugin/gui/progress_dialog.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def __init__ ( self , init_message = \"Processing\" , scenario_name = \"Scenario\" , minimum = 0 , maximum = 100 , main_widget = None , parent = None , ): super () . __init__ ( parent ) self . setupUi ( self ) self . scenario_name = scenario_name self . scenario_id = \"\" self . main_widget = main_widget self . report_manager = report_manager # Dialog window flags flags = QtCore . Qt . WindowMinimizeButtonHint | QtCore . Qt . WindowCloseButtonHint self . setWindowFlags ( flags ) # Dialog statuses self . analysis_running = True self . change_status_message ( init_message ) # Report status self . report_running = False # Progress bar self . progress_bar . setAlignment ( QtCore . Qt . AlignLeft | QtCore . Qt . AlignVCenter ) self . progress_bar . setMinimum ( minimum ) self . progress_bar . setMaximum ( maximum ) # Report menu self . menu = QMenu ( \"&View Report\" ) self . btn_view_report . setMenu ( self . menu ) self . btn_view_report . setIcon ( QIcon ( ICON_REPORT )) # Menu button to open report in Layout designer self . designer_action = QAction ( QIcon ( ICON_LAYOUT ), \"Layout designer\" , parent = self ) self . designer_action . triggered . connect ( self . view_report_layout_designer ) self . designer_action . setEnabled ( False ) self . menu . addAction ( self . designer_action ) # Open a PDF version of the report self . pdf_action = QAction ( QIcon ( ICON_PDF ), \"Open PDF\" , parent = self ) self . pdf_action . triggered . connect ( self . view_report_pdf ) self . pdf_action . setEnabled ( False ) self . menu . addAction ( self . pdf_action ) # Open a Help for reports action = QAction ( QIcon ( ICON_HELP ), \"Help\" , parent = self ) action . triggered . connect ( self . open_report_help ) action . setEnabled ( True ) self . menu . addAction ( action ) # Connections self . btn_cancel . clicked . connect ( self . cancel_clicked ) self . analysis_finished_message = tr ( \"Analysis has finished.\" ) cancel_clicked cancel_clicked () User clicked cancel. Processing will be stopped, and the UI will be updated to accommodate the processing status. Source code in src/cplus_plugin/gui/progress_dialog.py 190 191 192 193 194 195 196 197 198 199 200 201 202 203 def cancel_clicked ( self ) -> None : \"\"\"User clicked cancel. Processing will be stopped, and the UI will be updated to accommodate the processing status. \"\"\" self . cancel_reporting () if self . analysis_running : # If cancelled is clicked self . stop_processing () else : # If close has been clicked. In this case processing were already stopped super () . close () cancel_reporting cancel_reporting () Cancel the report generation process. Source code in src/cplus_plugin/gui/progress_dialog.py 205 206 207 208 def cancel_reporting ( self ): \"\"\"Cancel the report generation process.\"\"\" if self . report_running : self . report_manager . remove_report_task ( self . scenario_id ) change_status_message change_status_message ( message = 'Processing' , entity = 'scenario' ) Updates the status message Parameters: Name Type Description Default message str Message to show on the status bar 'Processing' Source code in src/cplus_plugin/gui/progress_dialog.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 def change_status_message ( self , message = \"Processing\" , entity = \"scenario\" ) -> None : \"\"\"Updates the status message :param message: Message to show on the status bar :type message: str :param message: The current processed entity, eg analysis scenario, ncs pathway or an implementation model :type message: str \"\"\" # Split like this so that the message gets translated, but not the scenario name msg = \" {} for {} \" . format ( message , entity ) final_msg = \" {}{} \" . format ( tr ( msg ), self . scenario_name , ) self . lbl_status . setText ( final_msg ) get_processing_status get_processing_status () Returns the status of the processing. Returns: Type Description bool Status of processing. Source code in src/cplus_plugin/gui/progress_dialog.py 101 102 103 104 105 106 107 108 def get_processing_status ( self ) -> bool : \"\"\"Returns the status of the processing. :returns: Status of processing. :rtype: bool \"\"\" return self . analysis_running get_progress_bar get_progress_bar () Returns a reference to the Progress bar object. Returns: Type Description QProgressBar Progress bar Source code in src/cplus_plugin/gui/progress_dialog.py 110 111 112 113 114 115 116 117 def get_progress_bar ( self ) -> QProgressBar : \"\"\"Returns a reference to the Progress bar object. :returns: Progress bar :rtype: QProgressBar \"\"\" return self . progress_bar open_report_help open_report_help () Opens the Report guide in a browser Source code in src/cplus_plugin/gui/progress_dialog.py 186 187 188 def open_report_help ( self ) -> None : \"\"\"Opens the Report guide in a browser\"\"\" open_documentation ( REPORT_DOCUMENTATION ) processing_cancelled processing_cancelled () Post-steps when processing were cancelled. Source code in src/cplus_plugin/gui/progress_dialog.py 232 233 234 235 236 237 238 239 def processing_cancelled ( self ) -> None : \"\"\"Post-steps when processing were cancelled.\"\"\" self . analysis_running = False # Change cancel button to the close button status self . btn_cancel . setText ( tr ( \"Close\" )) self . btn_view_report . setEnabled ( False ) processing_finished processing_finished () Post-steps when processing succeeded. Source code in src/cplus_plugin/gui/progress_dialog.py 241 242 243 244 245 246 247 248 249 250 251 def processing_finished ( self ) -> None : \"\"\"Post-steps when processing succeeded.\"\"\" self . analysis_running = False self . change_status_message ( self . analysis_finished_message ) # Change cancel button to the close button status self . btn_cancel . setText ( tr ( \"Close\" )) self . btn_view_report . setEnabled ( True ) icon = self . style () . standardIcon ( QStyle . SP_DialogCloseButton ) self . btn_cancel . setIcon ( icon ) reject reject () Called when the dialog is closed Source code in src/cplus_plugin/gui/progress_dialog.py 210 211 212 213 214 215 216 217 218 219 def reject ( self ) -> None : \"\"\"Called when the dialog is closed\"\"\" if self . analysis_running : # Stops analysis if it is still running self . stop_processing () self . cancel_reporting () super () . reject () run_dialog run_dialog () Runs/opens the dialog. Sets modal to modeless. This will allow the dialog to display and not interfere with other processes. Source code in src/cplus_plugin/gui/progress_dialog.py 93 94 95 96 97 98 99 def run_dialog ( self ): \"\"\"Runs/opens the dialog. Sets modal to modeless. This will allow the dialog to display and not interfere with other processes. \"\"\" self . setModal ( False ) self . show () set_report_complete set_report_complete () Enable layout designer and PDF report buttons. Source code in src/cplus_plugin/gui/progress_dialog.py 149 150 151 152 153 154 155 156 def set_report_complete ( self ): \"\"\"Enable layout designer and PDF report buttons.\"\"\" self . btn_view_report . setEnabled ( True ) self . designer_action . setEnabled ( True ) self . pdf_action . setEnabled ( True ) self . report_running = False self . processing_finished () stop_processing stop_processing () The user cancelled the processing. Source code in src/cplus_plugin/gui/progress_dialog.py 221 222 223 224 225 226 227 228 229 230 def stop_processing ( self ) -> None : \"\"\"The user cancelled the processing.\"\"\" self . change_status_message ( \"Processing has been cancelled by the user\" ) # Stops the processing task if self . main_widget : self . main_widget . cancel_processing_task () self . processing_cancelled () update_progress_bar update_progress_bar ( value ) Sets the value of the progress bar Parameters: Name Type Description Default value float Value to be set on the progress bar required Source code in src/cplus_plugin/gui/progress_dialog.py 119 120 121 122 123 124 125 126 127 128 129 def update_progress_bar ( self , value ) -> None : \"\"\"Sets the value of the progress bar :param value: Value to be set on the progress bar :type value: float \"\"\" if self . progress_bar : try : self . progress_bar . setValue ( int ( value )) except RuntimeError : log ( tr ( \"Error setting value to a progress bar\" ), notify = False ) view_report_layout_designer view_report_layout_designer () Opens the report in layout designer Source code in src/cplus_plugin/gui/progress_dialog.py 172 173 174 175 176 177 178 179 180 181 182 183 184 def view_report_layout_designer ( self ) -> None : \"\"\"Opens the report in layout designer\"\"\" if not self . scenario_id : log ( \"Scenario ID has not been set.\" ) return result = report_manager . report_result ( self . scenario_id ) if result is None : log ( \"Report result not found.\" ) else : status = report_manager . open_layout_designer ( result ) if not status : log ( \"Unable to open layout designer.\" ) view_report_pdf view_report_pdf () Opens a PDF version of the report Source code in src/cplus_plugin/gui/progress_dialog.py 158 159 160 161 162 163 164 165 166 167 168 169 170 def view_report_pdf ( self ) -> None : \"\"\"Opens a PDF version of the report\"\"\" if not self . scenario_id : log ( \"Scenario ID has not been set.\" ) return result = report_manager . report_result ( self . scenario_id ) if result is None : log ( \"Report result not found.\" ) else : status = report_manager . view_pdf ( result ) if not status : log ( \"Unable to open PDF report.\" )","title":"Progress dialog"},{"location":"developer/api/gui/api_progress_dialog/#progress-dialog","text":"at the top","title":"Progress dialog"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog","text":"ProgressDialog ( init_message = 'Processing' , scenario_name = 'Scenario' , minimum = 0 , maximum = 100 , main_widget = None , parent = None ) Bases: QDialog , Ui_DlgProgress This progress dialog Source code in src/cplus_plugin/gui/progress_dialog.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def __init__ ( self , init_message = \"Processing\" , scenario_name = \"Scenario\" , minimum = 0 , maximum = 100 , main_widget = None , parent = None , ): super () . __init__ ( parent ) self . setupUi ( self ) self . scenario_name = scenario_name self . scenario_id = \"\" self . main_widget = main_widget self . report_manager = report_manager # Dialog window flags flags = QtCore . Qt . WindowMinimizeButtonHint | QtCore . Qt . WindowCloseButtonHint self . setWindowFlags ( flags ) # Dialog statuses self . analysis_running = True self . change_status_message ( init_message ) # Report status self . report_running = False # Progress bar self . progress_bar . setAlignment ( QtCore . Qt . AlignLeft | QtCore . Qt . AlignVCenter ) self . progress_bar . setMinimum ( minimum ) self . progress_bar . setMaximum ( maximum ) # Report menu self . menu = QMenu ( \"&View Report\" ) self . btn_view_report . setMenu ( self . menu ) self . btn_view_report . setIcon ( QIcon ( ICON_REPORT )) # Menu button to open report in Layout designer self . designer_action = QAction ( QIcon ( ICON_LAYOUT ), \"Layout designer\" , parent = self ) self . designer_action . triggered . connect ( self . view_report_layout_designer ) self . designer_action . setEnabled ( False ) self . menu . addAction ( self . designer_action ) # Open a PDF version of the report self . pdf_action = QAction ( QIcon ( ICON_PDF ), \"Open PDF\" , parent = self ) self . pdf_action . triggered . connect ( self . view_report_pdf ) self . pdf_action . setEnabled ( False ) self . menu . addAction ( self . pdf_action ) # Open a Help for reports action = QAction ( QIcon ( ICON_HELP ), \"Help\" , parent = self ) action . triggered . connect ( self . open_report_help ) action . setEnabled ( True ) self . menu . addAction ( action ) # Connections self . btn_cancel . clicked . connect ( self . cancel_clicked ) self . analysis_finished_message = tr ( \"Analysis has finished.\" )","title":"ProgressDialog"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.cancel_clicked","text":"cancel_clicked () User clicked cancel. Processing will be stopped, and the UI will be updated to accommodate the processing status. Source code in src/cplus_plugin/gui/progress_dialog.py 190 191 192 193 194 195 196 197 198 199 200 201 202 203 def cancel_clicked ( self ) -> None : \"\"\"User clicked cancel. Processing will be stopped, and the UI will be updated to accommodate the processing status. \"\"\" self . cancel_reporting () if self . analysis_running : # If cancelled is clicked self . stop_processing () else : # If close has been clicked. In this case processing were already stopped super () . close ()","title":"cancel_clicked()"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.cancel_reporting","text":"cancel_reporting () Cancel the report generation process. Source code in src/cplus_plugin/gui/progress_dialog.py 205 206 207 208 def cancel_reporting ( self ): \"\"\"Cancel the report generation process.\"\"\" if self . report_running : self . report_manager . remove_report_task ( self . scenario_id )","title":"cancel_reporting()"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.change_status_message","text":"change_status_message ( message = 'Processing' , entity = 'scenario' ) Updates the status message Parameters: Name Type Description Default message str Message to show on the status bar 'Processing' Source code in src/cplus_plugin/gui/progress_dialog.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 def change_status_message ( self , message = \"Processing\" , entity = \"scenario\" ) -> None : \"\"\"Updates the status message :param message: Message to show on the status bar :type message: str :param message: The current processed entity, eg analysis scenario, ncs pathway or an implementation model :type message: str \"\"\" # Split like this so that the message gets translated, but not the scenario name msg = \" {} for {} \" . format ( message , entity ) final_msg = \" {}{} \" . format ( tr ( msg ), self . scenario_name , ) self . lbl_status . setText ( final_msg )","title":"change_status_message()"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.get_processing_status","text":"get_processing_status () Returns the status of the processing. Returns: Type Description bool Status of processing. Source code in src/cplus_plugin/gui/progress_dialog.py 101 102 103 104 105 106 107 108 def get_processing_status ( self ) -> bool : \"\"\"Returns the status of the processing. :returns: Status of processing. :rtype: bool \"\"\" return self . analysis_running","title":"get_processing_status()"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.get_progress_bar","text":"get_progress_bar () Returns a reference to the Progress bar object. Returns: Type Description QProgressBar Progress bar Source code in src/cplus_plugin/gui/progress_dialog.py 110 111 112 113 114 115 116 117 def get_progress_bar ( self ) -> QProgressBar : \"\"\"Returns a reference to the Progress bar object. :returns: Progress bar :rtype: QProgressBar \"\"\" return self . progress_bar","title":"get_progress_bar()"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.open_report_help","text":"open_report_help () Opens the Report guide in a browser Source code in src/cplus_plugin/gui/progress_dialog.py 186 187 188 def open_report_help ( self ) -> None : \"\"\"Opens the Report guide in a browser\"\"\" open_documentation ( REPORT_DOCUMENTATION )","title":"open_report_help()"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.processing_cancelled","text":"processing_cancelled () Post-steps when processing were cancelled. Source code in src/cplus_plugin/gui/progress_dialog.py 232 233 234 235 236 237 238 239 def processing_cancelled ( self ) -> None : \"\"\"Post-steps when processing were cancelled.\"\"\" self . analysis_running = False # Change cancel button to the close button status self . btn_cancel . setText ( tr ( \"Close\" )) self . btn_view_report . setEnabled ( False )","title":"processing_cancelled()"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.processing_finished","text":"processing_finished () Post-steps when processing succeeded. Source code in src/cplus_plugin/gui/progress_dialog.py 241 242 243 244 245 246 247 248 249 250 251 def processing_finished ( self ) -> None : \"\"\"Post-steps when processing succeeded.\"\"\" self . analysis_running = False self . change_status_message ( self . analysis_finished_message ) # Change cancel button to the close button status self . btn_cancel . setText ( tr ( \"Close\" )) self . btn_view_report . setEnabled ( True ) icon = self . style () . standardIcon ( QStyle . SP_DialogCloseButton ) self . btn_cancel . setIcon ( icon )","title":"processing_finished()"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.reject","text":"reject () Called when the dialog is closed Source code in src/cplus_plugin/gui/progress_dialog.py 210 211 212 213 214 215 216 217 218 219 def reject ( self ) -> None : \"\"\"Called when the dialog is closed\"\"\" if self . analysis_running : # Stops analysis if it is still running self . stop_processing () self . cancel_reporting () super () . reject ()","title":"reject()"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.run_dialog","text":"run_dialog () Runs/opens the dialog. Sets modal to modeless. This will allow the dialog to display and not interfere with other processes. Source code in src/cplus_plugin/gui/progress_dialog.py 93 94 95 96 97 98 99 def run_dialog ( self ): \"\"\"Runs/opens the dialog. Sets modal to modeless. This will allow the dialog to display and not interfere with other processes. \"\"\" self . setModal ( False ) self . show ()","title":"run_dialog()"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.set_report_complete","text":"set_report_complete () Enable layout designer and PDF report buttons. Source code in src/cplus_plugin/gui/progress_dialog.py 149 150 151 152 153 154 155 156 def set_report_complete ( self ): \"\"\"Enable layout designer and PDF report buttons.\"\"\" self . btn_view_report . setEnabled ( True ) self . designer_action . setEnabled ( True ) self . pdf_action . setEnabled ( True ) self . report_running = False self . processing_finished ()","title":"set_report_complete()"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.stop_processing","text":"stop_processing () The user cancelled the processing. Source code in src/cplus_plugin/gui/progress_dialog.py 221 222 223 224 225 226 227 228 229 230 def stop_processing ( self ) -> None : \"\"\"The user cancelled the processing.\"\"\" self . change_status_message ( \"Processing has been cancelled by the user\" ) # Stops the processing task if self . main_widget : self . main_widget . cancel_processing_task () self . processing_cancelled ()","title":"stop_processing()"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.update_progress_bar","text":"update_progress_bar ( value ) Sets the value of the progress bar Parameters: Name Type Description Default value float Value to be set on the progress bar required Source code in src/cplus_plugin/gui/progress_dialog.py 119 120 121 122 123 124 125 126 127 128 129 def update_progress_bar ( self , value ) -> None : \"\"\"Sets the value of the progress bar :param value: Value to be set on the progress bar :type value: float \"\"\" if self . progress_bar : try : self . progress_bar . setValue ( int ( value )) except RuntimeError : log ( tr ( \"Error setting value to a progress bar\" ), notify = False )","title":"update_progress_bar()"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.view_report_layout_designer","text":"view_report_layout_designer () Opens the report in layout designer Source code in src/cplus_plugin/gui/progress_dialog.py 172 173 174 175 176 177 178 179 180 181 182 183 184 def view_report_layout_designer ( self ) -> None : \"\"\"Opens the report in layout designer\"\"\" if not self . scenario_id : log ( \"Scenario ID has not been set.\" ) return result = report_manager . report_result ( self . scenario_id ) if result is None : log ( \"Report result not found.\" ) else : status = report_manager . open_layout_designer ( result ) if not status : log ( \"Unable to open layout designer.\" )","title":"view_report_layout_designer()"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.view_report_pdf","text":"view_report_pdf () Opens a PDF version of the report Source code in src/cplus_plugin/gui/progress_dialog.py 158 159 160 161 162 163 164 165 166 167 168 169 170 def view_report_pdf ( self ) -> None : \"\"\"Opens a PDF version of the report\"\"\" if not self . scenario_id : log ( \"Scenario ID has not been set.\" ) return result = report_manager . report_result ( self . scenario_id ) if result is None : log ( \"Report result not found.\" ) else : status = report_manager . view_pdf ( result ) if not status : log ( \"Unable to open PDF report.\" )","title":"view_report_pdf()"},{"location":"developer/api/models/api_base/","text":"Model base QGIS CPLUS plugin models. BaseModelComponent dataclass Base class for common model item properties. __eq__ __eq__ ( other ) Test equality of object with another BaseModelComponent object using the attributes. Parameters: Name Type Description Default other BaseModelComponent BaseModelComponent object to compare with this object. required Returns: Type Description bool True if the all the attribute values match, else False. Source code in src/cplus_plugin/models/base.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def __eq__ ( self , other : \"BaseModelComponent\" ) -> bool : \"\"\"Test equality of object with another BaseModelComponent object using the attributes. :param other: BaseModelComponent object to compare with this object. :type other: BaseModelComponent :returns: True if the all the attribute values match, else False. :rtype: bool \"\"\" if self . uuid != other . uuid : return False if self . name != other . name : return False if self . description != other . description : return False return True ImplementationModel dataclass Bases: LayerModelComponent Contains information about the implementation model for a scenario. If the layer has been set then it will not be possible to add NCS pathways unless the layer is cleared. Priority will be given to the layer property. __post_init__ __post_init__ () Pre-checks on initialization. Source code in src/cplus_plugin/models/base.py 308 309 310 311 312 313 314 315 316 317 318 319 320 321 def __post_init__ ( self ): \"\"\"Pre-checks on initialization.\"\"\" super () . __post_init__ () # Ensure there are no duplicate pathways. uuids = [ str ( p . uuid ) for p in self . pathways ] if len ( set ( uuids )) != len ( uuids ): msg = \"Duplicate pathways found in implementation model\" raise ValueError ( f \" { msg } { self . name } .\" ) # Reset pathways if layer has also been set. if self . to_map_layer () is not None and len ( self . pathways ) > 0 : self . pathways = [] add_ncs_pathway add_ncs_pathway ( ncs ) Adds an NCS pathway object to the collection. Parameters: Name Type Description Default ncs NcsPathway NCS pathway to be added to the model. required Returns: Type Description bool True if the NCS pathway was successfully added, else False if there was an existing NCS pathway object with a similar UUID or the layer property had already been set. Source code in src/cplus_plugin/models/base.py 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 def add_ncs_pathway ( self , ncs : NcsPathway ) -> bool : \"\"\"Adds an NCS pathway object to the collection. :param ncs: NCS pathway to be added to the model. :type ncs: NcsPathway :returns: True if the NCS pathway was successfully added, else False if there was an existing NCS pathway object with a similar UUID or the layer property had already been set. \"\"\" if not ncs . is_valid (): return False if self . contains_pathway ( str ( ncs . uuid )): return False self . pathways . append ( ncs ) return True clear_layer clear_layer () Removes a reference to the layer URI defined in the path attribute. Source code in src/cplus_plugin/models/base.py 359 360 361 def clear_layer ( self ): \"\"\"Removes a reference to the layer URI defined in the path attribute.\"\"\" self . path = \"\" contains_pathway contains_pathway ( pathway_uuid ) Checks if there is an NCS pathway matching the given UUID. Parameters: Name Type Description Default pathway_uuid str UUID to search for in the collection. required Returns: Type Description bool True if there is a matching NCS pathway, else False. Source code in src/cplus_plugin/models/base.py 323 324 325 326 327 328 329 330 331 332 333 334 335 336 def contains_pathway ( self , pathway_uuid : str ) -> bool : \"\"\"Checks if there is an NCS pathway matching the given UUID. :param pathway_uuid: UUID to search for in the collection. :type pathway_uuid: str :returns: True if there is a matching NCS pathway, else False. :rtype: bool \"\"\" ncs_pathway = self . pathway_by_uuid ( pathway_uuid ) if ncs_pathway is None : return False return True is_pwls_valid is_pwls_valid () Checks if the priority layers are valid. Returns: Type Description bool True if all priority layers are valid, else False if even one is invalid. If there are no priority layers defined, it will always return True. Source code in src/cplus_plugin/models/base.py 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 def is_pwls_valid ( self ) -> bool : \"\"\"Checks if the priority layers are valid. :returns: True if all priority layers are valid, else False if even one is invalid. If there are no priority layers defined, it will always return True. :rtype: bool \"\"\" is_valid = True for cl in self . pw_layers (): if not cl . isValid (): is_valid = False break return is_valid is_valid is_valid () Includes an additional check to assert if NCS pathways have been specified if the layer has not been set or is not valid. Does not check for validity of individual NCS pathways in the collection. Source code in src/cplus_plugin/models/base.py 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 def is_valid ( self ) -> bool : \"\"\"Includes an additional check to assert if NCS pathways have been specified if the layer has not been set or is not valid. Does not check for validity of individual NCS pathways in the collection. \"\"\" if self . to_map_layer () is not None : return super () . is_valid () else : if len ( self . pathways ) == 0 : return False if not self . is_pwls_valid (): return False return True pathway_by_uuid pathway_by_uuid ( pathway_uuid ) Returns an NCS pathway matching the given UUID. Parameters: Name Type Description Default pathway_uuid str UUID for the NCS pathway to retrieve. required Returns: Type Description NcsPathway NCS pathway object matching the given UUID else None if not found. Source code in src/cplus_plugin/models/base.py 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 def pathway_by_uuid ( self , pathway_uuid : str ) -> typing . Union [ NcsPathway , None ]: \"\"\"Returns an NCS pathway matching the given UUID. :param pathway_uuid: UUID for the NCS pathway to retrieve. :type pathway_uuid: str :returns: NCS pathway object matching the given UUID else None if not found. :rtype: NcsPathway \"\"\" pathways = [ p for p in self . pathways if str ( p . uuid ) == pathway_uuid ] if len ( pathways ) == 0 : return None return pathways [ 0 ] pw_layers pw_layers () Returns the list of priority weighting layers wdefined under the :py:attr: ~priority_layers attribute. Returns: Type Description list Priority layers for the implementation or an empty list if the path is not defined. Source code in src/cplus_plugin/models/base.py 400 401 402 403 404 405 406 407 408 def pw_layers ( self ) -> typing . List [ QgsRasterLayer ]: \"\"\"Returns the list of priority weighting layers wdefined under the :py:attr:`~priority_layers` attribute. :returns: Priority layers for the implementation or an empty list if the path is not defined. :rtype: list \"\"\" return [ QgsRasterLayer ( layer . get ( \"path\" )) for layer in self . priority_layers ] remove_ncs_pathway remove_ncs_pathway ( pathway_uuid ) Removes the NCS pathway with a matching UUID from the collection. Parameters: Name Type Description Default pathway_uuid str UUID for the NCS pathway to be removed. required Returns: Type Description bool True if the NCS pathway object was successfully removed, else False if there is no object matching the given UUID. Source code in src/cplus_plugin/models/base.py 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 def remove_ncs_pathway ( self , pathway_uuid : str ) -> bool : \"\"\"Removes the NCS pathway with a matching UUID from the collection. :param pathway_uuid: UUID for the NCS pathway to be removed. :type pathway_uuid: str :returns: True if the NCS pathway object was successfully removed, else False if there is no object matching the given UUID. :rtype: bool \"\"\" idxs = [ i for i , p in enumerate ( self . pathways ) if str ( p . uuid ) == pathway_uuid ] if len ( idxs ) == 0 : return False rem_idx = idxs [ 0 ] _ = self . pathways . pop ( rem_idx ) return True LayerModelComponent dataclass Bases: BaseModelComponent Base class for model components that support a map layer. __eq__ __eq__ ( other ) Uses BaseModelComponent equality test rather than what the dataclass default implementation will provide. Source code in src/cplus_plugin/models/base.py 178 179 180 181 182 def __eq__ ( self , other ) -> bool : \"\"\"Uses BaseModelComponent equality test rather than what the dataclass default implementation will provide. \"\"\" return super () . __eq__ ( other ) __post_init__ __post_init__ () Try to set the layer and layer type properties. Source code in src/cplus_plugin/models/base.py 121 122 123 def __post_init__ ( self ): \"\"\"Try to set the layer and layer type properties.\"\"\" self . update_layer_type () is_valid is_valid () Checks if the corresponding map layer is valid. Returns: Type Description bool True if the map layer is valid, else False if map layer is invalid or of None type. Source code in src/cplus_plugin/models/base.py 165 166 167 168 169 170 171 172 173 174 175 176 def is_valid ( self ) -> bool : \"\"\"Checks if the corresponding map layer is valid. :returns: True if the map layer is valid, else False if map layer is invalid or of None type. :rtype: bool \"\"\" layer = self . to_map_layer () if layer is None : return False return layer . isValid () to_map_layer to_map_layer () Constructs a map layer from the specified path. It will first check if the layer property has been set else try to construct the layer from the path else return None. Returns: Type Description QgsMapLayer Map layer corresponding to the set layer property or specified path. Source code in src/cplus_plugin/models/base.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 def to_map_layer ( self ) -> typing . Union [ QgsMapLayer , None ]: \"\"\"Constructs a map layer from the specified path. It will first check if the layer property has been set else try to construct the layer from the path else return None. :returns: Map layer corresponding to the set layer property or specified path. :rtype: QgsMapLayer \"\"\" if not os . path . exists ( self . path ): return None layer = None if self . layer_type == LayerType . RASTER : layer = QgsRasterLayer ( self . path , self . name ) elif self . layer_type == LayerType . VECTOR : layer = QgsVectorLayer ( self . path , self . name ) return layer update_layer_type update_layer_type () Update the layer type if either the layer or path properties have been set. Source code in src/cplus_plugin/models/base.py 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 def update_layer_type ( self ): \"\"\"Update the layer type if either the layer or path properties have been set. \"\"\" layer = self . to_map_layer () if layer is None : return if not layer . isValid (): return if isinstance ( layer , QgsRasterLayer ): self . layer_type = LayerType . RASTER elif isinstance ( layer , QgsVectorLayer ): self . layer_type = LayerType . VECTOR LayerType Bases: IntEnum QGIS spatial layer type. ModelComponentType Bases: Enum Type of model component i.e. NCS pathway or implementation model. from_string staticmethod from_string ( str_enum ) Creates an enum from the corresponding string equivalent. Parameters: Name Type Description Default str_enum str String representing the model component type. required Returns: Type Description ModelComponentType Component type enum corresponding to the given string else unknown if not found. Source code in src/cplus_plugin/models/base.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 @staticmethod def from_string ( str_enum : str ) -> \"ModelComponentType\" : \"\"\"Creates an enum from the corresponding string equivalent. :param str_enum: String representing the model component type. :type str_enum: str :returns: Component type enum corresponding to the given string else unknown if not found. :rtype: ModelComponentType \"\"\" if str_enum . lower () == \"ncs_pathway\" : return ModelComponentType . NCS_PATHWAY elif str_enum . lower () == \"implementation_model\" : return ModelComponentType . IMPLEMENTATION_MODEL return ModelComponentType . UNKNOWN NcsPathway dataclass Bases: LayerModelComponent Contains information about an NCS pathway layer. __eq__ __eq__ ( other ) Test equality of NcsPathway object with another NcsPathway object using the attributes. Excludes testing the map layer for equality. Parameters: Name Type Description Default other NcsPathway NcsPathway object to compare with this object. required Returns: Type Description bool True if all the attribute values match, else False. Source code in src/cplus_plugin/models/base.py 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 def __eq__ ( self , other : \"NcsPathway\" ) -> bool : \"\"\"Test equality of NcsPathway object with another NcsPathway object using the attributes. Excludes testing the map layer for equality. :param other: NcsPathway object to compare with this object. :type other: NcsPathway :returns: True if all the attribute values match, else False. :rtype: bool \"\"\" base_equality = super () . __eq__ ( other ) if not base_equality : return False if self . path != other . path : return False if self . layer_type != other . layer_type : return False if self . user_defined != other . user_defined : return False return True add_carbon_path add_carbon_path ( carbon_path ) Add a carbon layer path. Checks if the path has already been defined or if it exists in the file system. Returns: Type Description bool True if the carbon layer path was successfully added, else False if the path has already been defined or does not exist in the file system. Source code in src/cplus_plugin/models/base.py 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 def add_carbon_path ( self , carbon_path : str ) -> bool : \"\"\"Add a carbon layer path. Checks if the path has already been defined or if it exists in the file system. :returns: True if the carbon layer path was successfully added, else False if the path has already been defined or does not exist in the file system. :rtype: bool \"\"\" if carbon_path in self . carbon_paths : return False if not os . path . exists ( carbon_path ): return False self . carbon_paths . append ( carbon_path ) return True carbon_layers carbon_layers () Returns the list of carbon layers whose path is defined under the :py:attr: ~carbon_paths attribute. The caller should check the validity of the layers or use :py:meth: ~is_carbon_valid function. Returns: Type Description list Carbon layers for the NCS pathway or an empty list if the path is not defined. Source code in src/cplus_plugin/models/base.py 254 255 256 257 258 259 260 261 262 263 264 265 def carbon_layers ( self ) -> typing . List [ QgsRasterLayer ]: \"\"\"Returns the list of carbon layers whose path is defined under the :py:attr:`~carbon_paths` attribute. The caller should check the validity of the layers or use :py:meth:`~is_carbon_valid` function. :returns: Carbon layers for the NCS pathway or an empty list if the path is not defined. :rtype: list \"\"\" return [ QgsRasterLayer ( carbon_path ) for carbon_path in self . carbon_paths ] is_carbon_valid is_carbon_valid () Checks if the carbon layers are valid. Returns: Type Description bool True if all carbon layers are valid, else False if even one is invalid. If there are no carbon layers defined, it will always return True. Source code in src/cplus_plugin/models/base.py 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 def is_carbon_valid ( self ) -> bool : \"\"\"Checks if the carbon layers are valid. :returns: True if all carbon layers are valid, else False if even one is invalid. If there are no carbon layers defined, it will always return True. :rtype: bool \"\"\" is_valid = True for cl in self . carbon_layers (): if not cl . isValid (): is_valid = False break return is_valid is_valid is_valid () Additional check to include validity of carbon layers. Source code in src/cplus_plugin/models/base.py 283 284 285 286 287 288 289 290 291 292 293 def is_valid ( self ) -> bool : \"\"\"Additional check to include validity of carbon layers.\"\"\" valid = super () . is_valid () if not valid : return False carbon_valid = self . is_carbon_valid () if not carbon_valid : return False return True PRIORITY_GROUP Bases: Enum Represents priority groups types PriorityLayer dataclass Bases: BaseModelComponent Base class for model components storing priority weighting layers. Scenario dataclass Bases: BaseModelComponent Object for the handling workflow scenario information. ScenarioResult dataclass Scenario result details. ScenarioState Bases: Enum Defines scenario analysis process states SpatialExtent dataclass Extent object that stores the coordinates of the area of interest","title":"Model base"},{"location":"developer/api/models/api_base/#model-base","text":"QGIS CPLUS plugin models.","title":"Model base"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.BaseModelComponent","text":"Base class for common model item properties.","title":"BaseModelComponent"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.BaseModelComponent.__eq__","text":"__eq__ ( other ) Test equality of object with another BaseModelComponent object using the attributes. Parameters: Name Type Description Default other BaseModelComponent BaseModelComponent object to compare with this object. required Returns: Type Description bool True if the all the attribute values match, else False. Source code in src/cplus_plugin/models/base.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def __eq__ ( self , other : \"BaseModelComponent\" ) -> bool : \"\"\"Test equality of object with another BaseModelComponent object using the attributes. :param other: BaseModelComponent object to compare with this object. :type other: BaseModelComponent :returns: True if the all the attribute values match, else False. :rtype: bool \"\"\" if self . uuid != other . uuid : return False if self . name != other . name : return False if self . description != other . description : return False return True","title":"__eq__()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.ImplementationModel","text":"Bases: LayerModelComponent Contains information about the implementation model for a scenario. If the layer has been set then it will not be possible to add NCS pathways unless the layer is cleared. Priority will be given to the layer property.","title":"ImplementationModel"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.ImplementationModel.__post_init__","text":"__post_init__ () Pre-checks on initialization. Source code in src/cplus_plugin/models/base.py 308 309 310 311 312 313 314 315 316 317 318 319 320 321 def __post_init__ ( self ): \"\"\"Pre-checks on initialization.\"\"\" super () . __post_init__ () # Ensure there are no duplicate pathways. uuids = [ str ( p . uuid ) for p in self . pathways ] if len ( set ( uuids )) != len ( uuids ): msg = \"Duplicate pathways found in implementation model\" raise ValueError ( f \" { msg } { self . name } .\" ) # Reset pathways if layer has also been set. if self . to_map_layer () is not None and len ( self . pathways ) > 0 : self . pathways = []","title":"__post_init__()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.ImplementationModel.add_ncs_pathway","text":"add_ncs_pathway ( ncs ) Adds an NCS pathway object to the collection. Parameters: Name Type Description Default ncs NcsPathway NCS pathway to be added to the model. required Returns: Type Description bool True if the NCS pathway was successfully added, else False if there was an existing NCS pathway object with a similar UUID or the layer property had already been set. Source code in src/cplus_plugin/models/base.py 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 def add_ncs_pathway ( self , ncs : NcsPathway ) -> bool : \"\"\"Adds an NCS pathway object to the collection. :param ncs: NCS pathway to be added to the model. :type ncs: NcsPathway :returns: True if the NCS pathway was successfully added, else False if there was an existing NCS pathway object with a similar UUID or the layer property had already been set. \"\"\" if not ncs . is_valid (): return False if self . contains_pathway ( str ( ncs . uuid )): return False self . pathways . append ( ncs ) return True","title":"add_ncs_pathway()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.ImplementationModel.clear_layer","text":"clear_layer () Removes a reference to the layer URI defined in the path attribute. Source code in src/cplus_plugin/models/base.py 359 360 361 def clear_layer ( self ): \"\"\"Removes a reference to the layer URI defined in the path attribute.\"\"\" self . path = \"\"","title":"clear_layer()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.ImplementationModel.contains_pathway","text":"contains_pathway ( pathway_uuid ) Checks if there is an NCS pathway matching the given UUID. Parameters: Name Type Description Default pathway_uuid str UUID to search for in the collection. required Returns: Type Description bool True if there is a matching NCS pathway, else False. Source code in src/cplus_plugin/models/base.py 323 324 325 326 327 328 329 330 331 332 333 334 335 336 def contains_pathway ( self , pathway_uuid : str ) -> bool : \"\"\"Checks if there is an NCS pathway matching the given UUID. :param pathway_uuid: UUID to search for in the collection. :type pathway_uuid: str :returns: True if there is a matching NCS pathway, else False. :rtype: bool \"\"\" ncs_pathway = self . pathway_by_uuid ( pathway_uuid ) if ncs_pathway is None : return False return True","title":"contains_pathway()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.ImplementationModel.is_pwls_valid","text":"is_pwls_valid () Checks if the priority layers are valid. Returns: Type Description bool True if all priority layers are valid, else False if even one is invalid. If there are no priority layers defined, it will always return True. Source code in src/cplus_plugin/models/base.py 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 def is_pwls_valid ( self ) -> bool : \"\"\"Checks if the priority layers are valid. :returns: True if all priority layers are valid, else False if even one is invalid. If there are no priority layers defined, it will always return True. :rtype: bool \"\"\" is_valid = True for cl in self . pw_layers (): if not cl . isValid (): is_valid = False break return is_valid","title":"is_pwls_valid()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.ImplementationModel.is_valid","text":"is_valid () Includes an additional check to assert if NCS pathways have been specified if the layer has not been set or is not valid. Does not check for validity of individual NCS pathways in the collection. Source code in src/cplus_plugin/models/base.py 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 def is_valid ( self ) -> bool : \"\"\"Includes an additional check to assert if NCS pathways have been specified if the layer has not been set or is not valid. Does not check for validity of individual NCS pathways in the collection. \"\"\" if self . to_map_layer () is not None : return super () . is_valid () else : if len ( self . pathways ) == 0 : return False if not self . is_pwls_valid (): return False return True","title":"is_valid()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.ImplementationModel.pathway_by_uuid","text":"pathway_by_uuid ( pathway_uuid ) Returns an NCS pathway matching the given UUID. Parameters: Name Type Description Default pathway_uuid str UUID for the NCS pathway to retrieve. required Returns: Type Description NcsPathway NCS pathway object matching the given UUID else None if not found. Source code in src/cplus_plugin/models/base.py 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 def pathway_by_uuid ( self , pathway_uuid : str ) -> typing . Union [ NcsPathway , None ]: \"\"\"Returns an NCS pathway matching the given UUID. :param pathway_uuid: UUID for the NCS pathway to retrieve. :type pathway_uuid: str :returns: NCS pathway object matching the given UUID else None if not found. :rtype: NcsPathway \"\"\" pathways = [ p for p in self . pathways if str ( p . uuid ) == pathway_uuid ] if len ( pathways ) == 0 : return None return pathways [ 0 ]","title":"pathway_by_uuid()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.ImplementationModel.pw_layers","text":"pw_layers () Returns the list of priority weighting layers wdefined under the :py:attr: ~priority_layers attribute. Returns: Type Description list Priority layers for the implementation or an empty list if the path is not defined. Source code in src/cplus_plugin/models/base.py 400 401 402 403 404 405 406 407 408 def pw_layers ( self ) -> typing . List [ QgsRasterLayer ]: \"\"\"Returns the list of priority weighting layers wdefined under the :py:attr:`~priority_layers` attribute. :returns: Priority layers for the implementation or an empty list if the path is not defined. :rtype: list \"\"\" return [ QgsRasterLayer ( layer . get ( \"path\" )) for layer in self . priority_layers ]","title":"pw_layers()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.ImplementationModel.remove_ncs_pathway","text":"remove_ncs_pathway ( pathway_uuid ) Removes the NCS pathway with a matching UUID from the collection. Parameters: Name Type Description Default pathway_uuid str UUID for the NCS pathway to be removed. required Returns: Type Description bool True if the NCS pathway object was successfully removed, else False if there is no object matching the given UUID. Source code in src/cplus_plugin/models/base.py 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 def remove_ncs_pathway ( self , pathway_uuid : str ) -> bool : \"\"\"Removes the NCS pathway with a matching UUID from the collection. :param pathway_uuid: UUID for the NCS pathway to be removed. :type pathway_uuid: str :returns: True if the NCS pathway object was successfully removed, else False if there is no object matching the given UUID. :rtype: bool \"\"\" idxs = [ i for i , p in enumerate ( self . pathways ) if str ( p . uuid ) == pathway_uuid ] if len ( idxs ) == 0 : return False rem_idx = idxs [ 0 ] _ = self . pathways . pop ( rem_idx ) return True","title":"remove_ncs_pathway()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.LayerModelComponent","text":"Bases: BaseModelComponent Base class for model components that support a map layer.","title":"LayerModelComponent"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.LayerModelComponent.__eq__","text":"__eq__ ( other ) Uses BaseModelComponent equality test rather than what the dataclass default implementation will provide. Source code in src/cplus_plugin/models/base.py 178 179 180 181 182 def __eq__ ( self , other ) -> bool : \"\"\"Uses BaseModelComponent equality test rather than what the dataclass default implementation will provide. \"\"\" return super () . __eq__ ( other )","title":"__eq__()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.LayerModelComponent.__post_init__","text":"__post_init__ () Try to set the layer and layer type properties. Source code in src/cplus_plugin/models/base.py 121 122 123 def __post_init__ ( self ): \"\"\"Try to set the layer and layer type properties.\"\"\" self . update_layer_type ()","title":"__post_init__()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.LayerModelComponent.is_valid","text":"is_valid () Checks if the corresponding map layer is valid. Returns: Type Description bool True if the map layer is valid, else False if map layer is invalid or of None type. Source code in src/cplus_plugin/models/base.py 165 166 167 168 169 170 171 172 173 174 175 176 def is_valid ( self ) -> bool : \"\"\"Checks if the corresponding map layer is valid. :returns: True if the map layer is valid, else False if map layer is invalid or of None type. :rtype: bool \"\"\" layer = self . to_map_layer () if layer is None : return False return layer . isValid ()","title":"is_valid()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.LayerModelComponent.to_map_layer","text":"to_map_layer () Constructs a map layer from the specified path. It will first check if the layer property has been set else try to construct the layer from the path else return None. Returns: Type Description QgsMapLayer Map layer corresponding to the set layer property or specified path. Source code in src/cplus_plugin/models/base.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 def to_map_layer ( self ) -> typing . Union [ QgsMapLayer , None ]: \"\"\"Constructs a map layer from the specified path. It will first check if the layer property has been set else try to construct the layer from the path else return None. :returns: Map layer corresponding to the set layer property or specified path. :rtype: QgsMapLayer \"\"\" if not os . path . exists ( self . path ): return None layer = None if self . layer_type == LayerType . RASTER : layer = QgsRasterLayer ( self . path , self . name ) elif self . layer_type == LayerType . VECTOR : layer = QgsVectorLayer ( self . path , self . name ) return layer","title":"to_map_layer()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.LayerModelComponent.update_layer_type","text":"update_layer_type () Update the layer type if either the layer or path properties have been set. Source code in src/cplus_plugin/models/base.py 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 def update_layer_type ( self ): \"\"\"Update the layer type if either the layer or path properties have been set. \"\"\" layer = self . to_map_layer () if layer is None : return if not layer . isValid (): return if isinstance ( layer , QgsRasterLayer ): self . layer_type = LayerType . RASTER elif isinstance ( layer , QgsVectorLayer ): self . layer_type = LayerType . VECTOR","title":"update_layer_type()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.LayerType","text":"Bases: IntEnum QGIS spatial layer type.","title":"LayerType"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.ModelComponentType","text":"Bases: Enum Type of model component i.e. NCS pathway or implementation model.","title":"ModelComponentType"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.ModelComponentType.from_string","text":"from_string ( str_enum ) Creates an enum from the corresponding string equivalent. Parameters: Name Type Description Default str_enum str String representing the model component type. required Returns: Type Description ModelComponentType Component type enum corresponding to the given string else unknown if not found. Source code in src/cplus_plugin/models/base.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 @staticmethod def from_string ( str_enum : str ) -> \"ModelComponentType\" : \"\"\"Creates an enum from the corresponding string equivalent. :param str_enum: String representing the model component type. :type str_enum: str :returns: Component type enum corresponding to the given string else unknown if not found. :rtype: ModelComponentType \"\"\" if str_enum . lower () == \"ncs_pathway\" : return ModelComponentType . NCS_PATHWAY elif str_enum . lower () == \"implementation_model\" : return ModelComponentType . IMPLEMENTATION_MODEL return ModelComponentType . UNKNOWN","title":"from_string()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.NcsPathway","text":"Bases: LayerModelComponent Contains information about an NCS pathway layer.","title":"NcsPathway"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.NcsPathway.__eq__","text":"__eq__ ( other ) Test equality of NcsPathway object with another NcsPathway object using the attributes. Excludes testing the map layer for equality. Parameters: Name Type Description Default other NcsPathway NcsPathway object to compare with this object. required Returns: Type Description bool True if all the attribute values match, else False. Source code in src/cplus_plugin/models/base.py 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 def __eq__ ( self , other : \"NcsPathway\" ) -> bool : \"\"\"Test equality of NcsPathway object with another NcsPathway object using the attributes. Excludes testing the map layer for equality. :param other: NcsPathway object to compare with this object. :type other: NcsPathway :returns: True if all the attribute values match, else False. :rtype: bool \"\"\" base_equality = super () . __eq__ ( other ) if not base_equality : return False if self . path != other . path : return False if self . layer_type != other . layer_type : return False if self . user_defined != other . user_defined : return False return True","title":"__eq__()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.NcsPathway.add_carbon_path","text":"add_carbon_path ( carbon_path ) Add a carbon layer path. Checks if the path has already been defined or if it exists in the file system. Returns: Type Description bool True if the carbon layer path was successfully added, else False if the path has already been defined or does not exist in the file system. Source code in src/cplus_plugin/models/base.py 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 def add_carbon_path ( self , carbon_path : str ) -> bool : \"\"\"Add a carbon layer path. Checks if the path has already been defined or if it exists in the file system. :returns: True if the carbon layer path was successfully added, else False if the path has already been defined or does not exist in the file system. :rtype: bool \"\"\" if carbon_path in self . carbon_paths : return False if not os . path . exists ( carbon_path ): return False self . carbon_paths . append ( carbon_path ) return True","title":"add_carbon_path()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.NcsPathway.carbon_layers","text":"carbon_layers () Returns the list of carbon layers whose path is defined under the :py:attr: ~carbon_paths attribute. The caller should check the validity of the layers or use :py:meth: ~is_carbon_valid function. Returns: Type Description list Carbon layers for the NCS pathway or an empty list if the path is not defined. Source code in src/cplus_plugin/models/base.py 254 255 256 257 258 259 260 261 262 263 264 265 def carbon_layers ( self ) -> typing . List [ QgsRasterLayer ]: \"\"\"Returns the list of carbon layers whose path is defined under the :py:attr:`~carbon_paths` attribute. The caller should check the validity of the layers or use :py:meth:`~is_carbon_valid` function. :returns: Carbon layers for the NCS pathway or an empty list if the path is not defined. :rtype: list \"\"\" return [ QgsRasterLayer ( carbon_path ) for carbon_path in self . carbon_paths ]","title":"carbon_layers()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.NcsPathway.is_carbon_valid","text":"is_carbon_valid () Checks if the carbon layers are valid. Returns: Type Description bool True if all carbon layers are valid, else False if even one is invalid. If there are no carbon layers defined, it will always return True. Source code in src/cplus_plugin/models/base.py 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 def is_carbon_valid ( self ) -> bool : \"\"\"Checks if the carbon layers are valid. :returns: True if all carbon layers are valid, else False if even one is invalid. If there are no carbon layers defined, it will always return True. :rtype: bool \"\"\" is_valid = True for cl in self . carbon_layers (): if not cl . isValid (): is_valid = False break return is_valid","title":"is_carbon_valid()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.NcsPathway.is_valid","text":"is_valid () Additional check to include validity of carbon layers. Source code in src/cplus_plugin/models/base.py 283 284 285 286 287 288 289 290 291 292 293 def is_valid ( self ) -> bool : \"\"\"Additional check to include validity of carbon layers.\"\"\" valid = super () . is_valid () if not valid : return False carbon_valid = self . is_carbon_valid () if not carbon_valid : return False return True","title":"is_valid()"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.PRIORITY_GROUP","text":"Bases: Enum Represents priority groups types","title":"PRIORITY_GROUP"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.PriorityLayer","text":"Bases: BaseModelComponent Base class for model components storing priority weighting layers.","title":"PriorityLayer"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.Scenario","text":"Bases: BaseModelComponent Object for the handling workflow scenario information.","title":"Scenario"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.ScenarioResult","text":"Scenario result details.","title":"ScenarioResult"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.ScenarioState","text":"Bases: Enum Defines scenario analysis process states","title":"ScenarioState"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.SpatialExtent","text":"Extent object that stores the coordinates of the area of interest","title":"SpatialExtent"},{"location":"developer/api/models/api_helpers/","text":"Helpers Helper functions for supporting model management. clone_implementation_model clone_implementation_model ( implementation_model ) Creates a deep copy of the given implementation model. Parameters: Name Type Description Default implementation_model ImplementationModel Implementation model to clone. required Returns: Type Description ImplementationModel A deep copy of the original implementation model object. Source code in src/cplus_plugin/models/helpers.py 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 def clone_implementation_model ( implementation_model : ImplementationModel , ) -> ImplementationModel : \"\"\"Creates a deep copy of the given implementation model. :param implementation_model: Implementation model to clone. :type implementation_model: ImplementationModel :returns: A deep copy of the original implementation model object. :rtype: ImplementationModel \"\"\" imp_model = clone_layer_component ( implementation_model , ImplementationModel ) if imp_model is None : return None pathways = implementation_model . pathways cloned_pathways = [] for p in pathways : cloned_ncs = clone_ncs_pathway ( p ) if cloned_ncs is not None : cloned_pathways . append ( cloned_ncs ) imp_model . pathways = cloned_pathways return imp_model clone_layer_component clone_layer_component ( layer_component , model_cls ) Clones a layer-based model component. Parameters: Name Type Description Default layer_component LayerModelComponent Layer-based model component to clone. required model_cls Callable [[ UUID , str , str ], LayerModelComponentType ] Callable class that will be created based on the input argument values from the dictionary. required Returns: Type Description LayerModelComponent A new instance of the cloned model component. It will return None if the input is not a layer-based model component. Source code in src/cplus_plugin/models/helpers.py 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 def clone_layer_component ( layer_component : LayerModelComponent , model_cls : typing . Callable [[ uuid . UUID , str , str ], LayerModelComponentType ], ) -> typing . Union [ LayerModelComponent , None ]: \"\"\"Clones a layer-based model component. :param layer_component: Layer-based model component to clone. :type layer_component: LayerModelComponent :param model_cls: Callable class that will be created based on the input argument values from the dictionary. :type model_cls: LayerModelComponent :returns: A new instance of the cloned model component. It will return None if the input is not a layer-based model component. :rtype: LayerModelComponent \"\"\" if not isinstance ( layer_component , LayerModelComponent ): return None cloned_component = model_cls ( layer_component . uuid , layer_component . name , layer_component . description ) for f in fields ( layer_component ): attr_val = getattr ( layer_component , f . name ) setattr ( cloned_component , f . name , attr_val ) return cloned_component clone_ncs_pathway clone_ncs_pathway ( ncs ) Creates a deep copy of the given NCS pathway. Parameters: Name Type Description Default ncs NcsPathway NCS pathway to clone. required Returns: Type Description NcsPathway A deep copy of the original NCS pathway object. Source code in src/cplus_plugin/models/helpers.py 278 279 280 281 282 283 284 285 286 287 def clone_ncs_pathway ( ncs : NcsPathway ) -> NcsPathway : \"\"\"Creates a deep copy of the given NCS pathway. :param ncs: NCS pathway to clone. :type ncs: NcsPathway :returns: A deep copy of the original NCS pathway object. :rtype: NcsPathway \"\"\" return clone_layer_component ( ncs , NcsPathway ) copy_layer_component_attributes copy_layer_component_attributes ( target , source ) Copies the attribute values of source to target. The uuid attribute value is not copied as well as the layer attribute. However, for the latter, the path is copied. Parameters: Name Type Description Default target LayerModelComponent Target object whose attribute values will be updated. required source LayerModelComponent Source object whose attribute values will be copied to the target. required Returns: Type Description LayerModelComponent Target object containing the updated attribute values apart for the uuid whose value will not change. Source code in src/cplus_plugin/models/helpers.py 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 def copy_layer_component_attributes ( target : LayerModelComponent , source : LayerModelComponent ) -> LayerModelComponent : \"\"\"Copies the attribute values of source to target. The uuid attribute value is not copied as well as the layer attribute. However, for the latter, the path is copied. :param target: Target object whose attribute values will be updated. :type target: LayerModelComponent :param source: Source object whose attribute values will be copied to the target. :type source: LayerModelComponent :returns: Target object containing the updated attribute values apart for the uuid whose value will not change. :rtype: LayerModelComponent \"\"\" if not isinstance ( target , LayerModelComponent ) or not isinstance ( source , LayerModelComponent ): raise TypeError ( \"Source or target objects are not of type 'LayerModelComponent'\" ) for f in fields ( source ): # Exclude uuid if f . name == UUID_ATTRIBUTE : continue attr_val = getattr ( source , f . name ) setattr ( target , f . name , attr_val ) # Force layer to be set/updated target . update_layer_type () return target create_implementation_model create_implementation_model ( source_dict ) Factory method for creating an implementation model using attribute values defined in a dictionary. Parameters: Name Type Description Default source_dict dict Dictionary containing property values. required Returns: Type Description ImplementationModel Implementation model with property values set from the dictionary. Source code in src/cplus_plugin/models/helpers.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 def create_implementation_model ( source_dict ) -> typing . Union [ ImplementationModel , None ]: \"\"\"Factory method for creating an implementation model using attribute values defined in a dictionary. :param source_dict: Dictionary containing property values. :type source_dict: dict :returns: Implementation model with property values set from the dictionary. :rtype: ImplementationModel \"\"\" implementation_model = create_layer_component ( source_dict , ImplementationModel ) if PRIORITY_LAYERS_SEGMENT in source_dict . keys (): implementation_model . priority_layers = source_dict [ PRIORITY_LAYERS_SEGMENT ] return implementation_model create_layer_component create_layer_component ( source_dict , model_cls ) Factory method for creating a layer model component using attribute values defined in a dictionary. Parameters: Name Type Description Default source_dict dict Dictionary containing property values. required model_cls Callable [[ UUID , str , str , str , LayerType , bool ], LayerModelComponentType ] Callable class that will be created based on the input argument values from the dictionary. required Returns: Type Description LayerModelComponent Layer model component object with property values set from the dictionary. Source code in src/cplus_plugin/models/helpers.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def create_layer_component ( source_dict , model_cls : typing . Callable [ [ uuid . UUID , str , str , str , LayerType , bool ], LayerModelComponentType ], ) -> typing . Union [ LayerModelComponent , None ]: \"\"\"Factory method for creating a layer model component using attribute values defined in a dictionary. :param source_dict: Dictionary containing property values. :type source_dict: dict :param model_cls: Callable class that will be created based on the input argument values from the dictionary. :type model_cls: LayerModelComponent :returns: Layer model component object with property values set from the dictionary. :rtype: LayerModelComponent \"\"\" if UUID_ATTRIBUTE not in source_dict : return None source_uuid = source_dict [ UUID_ATTRIBUTE ] if isinstance ( source_uuid , str ): source_uuid = uuid . UUID ( source_uuid ) kwargs = {} if PATH_ATTRIBUTE in source_dict : kwargs [ PATH_ATTRIBUTE ] = source_dict [ PATH_ATTRIBUTE ] if LAYER_TYPE_ATTRIBUTE in source_dict : kwargs [ LAYER_TYPE_ATTRIBUTE ] = LayerType ( int ( source_dict [ LAYER_TYPE_ATTRIBUTE ])) if USER_DEFINED_ATTRIBUTE in source_dict : kwargs [ USER_DEFINED_ATTRIBUTE ] = bool ( source_dict [ USER_DEFINED_ATTRIBUTE ]) return model_cls ( source_uuid , source_dict [ NAME_ATTRIBUTE ], source_dict [ DESCRIPTION_ATTRIBUTE ], ** kwargs ) create_model_component create_model_component ( source_dict , model_cls ) Factory method for creating and setting attribute values for a base model component object. Parameters: Name Type Description Default source_dict dict Dictionary containing attribute values. required model_cls Callable [[ UUID , str , str ], BaseModelComponentType ] Callable class that will be created based on the input argument values from the dictionary. required Returns: Type Description BaseModelComponent Base model component object with property values derived from the dictionary. Source code in src/cplus_plugin/models/helpers.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def create_model_component ( source_dict : dict , model_cls : typing . Callable [[ uuid . UUID , str , str ], BaseModelComponentType ], ) -> typing . Union [ BaseModelComponentType , None ]: \"\"\"Factory method for creating and setting attribute values for a base model component object. :param source_dict: Dictionary containing attribute values. :type source_dict: dict :param model_cls: Callable class that will be created based on the input argument values from the dictionary. :type model_cls: BaseModelComponent :returns: Base model component object with property values derived from the dictionary. :rtype: BaseModelComponent \"\"\" if not issubclass ( model_cls , BaseModelComponent ): return None return model_cls ( uuid . UUID ( source_dict [ UUID_ATTRIBUTE ]), source_dict [ NAME_ATTRIBUTE ], source_dict [ DESCRIPTION_ATTRIBUTE ], ) create_ncs_pathway create_ncs_pathway ( source_dict ) Factory method for creating an NcsPathway object using attribute values defined in a dictionary. Parameters: Name Type Description Default source_dict dict Dictionary containing property values. required Returns: Type Description NcsPathway NCS pathway object with property values set from the dictionary. Source code in src/cplus_plugin/models/helpers.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def create_ncs_pathway ( source_dict ) -> typing . Union [ NcsPathway , None ]: \"\"\"Factory method for creating an NcsPathway object using attribute values defined in a dictionary. :param source_dict: Dictionary containing property values. :type source_dict: dict :returns: NCS pathway object with property values set from the dictionary. :rtype: NcsPathway \"\"\" ncs = create_layer_component ( source_dict , NcsPathway ) # We are checking because of the various iterations of the attributes # in the NcsPathway class where some of these attributes might # be missing. if CARBON_PATHS_ATTRIBUTE in source_dict : ncs . carbon_paths = source_dict [ CARBON_PATHS_ATTRIBUTE ] carbon_coefficient_attr = CARBON_COEFFICIENT_ATTRIBUTE if carbon_coefficient_attr in source_dict : ncs . carbon_coefficient = source_dict [ CARBON_COEFFICIENT_ATTRIBUTE ] return ncs extent_to_project_crs_extent extent_to_project_crs_extent ( spatial_extent , project = None ) Transforms SpatialExtent model to an QGIS extent based on the CRS of the given project. Parameters: Name Type Description Default spatial_extent SpatialExtent Spatial extent data model that defines the scenario bounds. required project QgsProject Project whose CRS will be used to determine the values of the output extent. None Returns: Type Description QgsRectangle Output extent in the project's CRS. If the input extent is invalid, this function will return None. Source code in src/cplus_plugin/models/helpers.py 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 def extent_to_project_crs_extent ( spatial_extent : SpatialExtent , project : QgsProject = None ) -> typing . Union [ QgsRectangle , None ]: \"\"\"Transforms SpatialExtent model to an QGIS extent based on the CRS of the given project. :param spatial_extent: Spatial extent data model that defines the scenario bounds. :type spatial_extent: SpatialExtent :param project: Project whose CRS will be used to determine the values of the output extent. :type project: QgsProject :returns: Output extent in the project's CRS. If the input extent is invalid, this function will return None. :rtype: QgsRectangle \"\"\" input_rect = extent_to_qgs_rectangle ( spatial_extent ) if input_rect is None : return None default_crs = QgsCoordinateReferenceSystem . fromEpsgId ( DEFAULT_CRS_ID ) if not default_crs . isValid (): return None if project is None : project = QgsProject . instance () target_crs = project . crs () if default_crs == target_crs : # No need for transformation return input_rect coordinate_xform = QgsCoordinateTransform ( default_crs , project . crs (), project ) return coordinate_xform . transformBoundingBox ( input_rect ) extent_to_qgs_rectangle extent_to_qgs_rectangle ( spatial_extent ) Returns a QgsRectangle object from the SpatialExtent object. If the SpatialExtent is invalid (i.e. less than four items) then it will return None. Parameters: Name Type Description Default spatial_extent SpatialExtent Spatial extent data model that defines the scenario bounds. required Returns: Type Description QgsRectangle QGIS rectangle defining the bounds for the scenario. Source code in src/cplus_plugin/models/helpers.py 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 def extent_to_qgs_rectangle ( spatial_extent : SpatialExtent , ) -> typing . Union [ QgsRectangle , None ]: \"\"\"Returns a QgsRectangle object from the SpatialExtent object. If the SpatialExtent is invalid (i.e. less than four items) then it will return None. :param spatial_extent: Spatial extent data model that defines the scenario bounds. :type spatial_extent: SpatialExtent :returns: QGIS rectangle defining the bounds for the scenario. :rtype: QgsRectangle \"\"\" if len ( spatial_extent . bbox ) < 4 : return None return QgsRectangle ( spatial_extent . bbox [ 0 ], spatial_extent . bbox [ 2 ], spatial_extent . bbox [ 1 ], spatial_extent . bbox [ 3 ], ) layer_component_to_dict layer_component_to_dict ( layer_component , uuid_to_str = True ) Creates a dictionary containing attribute name-value pairs from a layer model component object. Parameters: Name Type Description Default layer_component LayerModelComponentType Source layer model component object whose values are to be mapped to the corresponding attribute names. required uuid_to_str bool Set True to convert the UUID to a string equivalent, else False. Some serialization engines such as JSON are unable to handle UUID objects hence the need to convert to string. True Returns: Type Description dict Returns a dictionary item containing attribute name-value pairs. Source code in src/cplus_plugin/models/helpers.py 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 def layer_component_to_dict ( layer_component : LayerModelComponentType , uuid_to_str = True ) -> dict : \"\"\"Creates a dictionary containing attribute name-value pairs from a layer model component object. :param layer_component: Source layer model component object whose values are to be mapped to the corresponding attribute names. :type layer_component: LayerModelComponent :param uuid_to_str: Set True to convert the UUID to a string equivalent, else False. Some serialization engines such as JSON are unable to handle UUID objects hence the need to convert to string. :type uuid_to_str: bool :returns: Returns a dictionary item containing attribute name-value pairs. :rtype: dict \"\"\" base_attrs = model_component_to_dict ( layer_component , uuid_to_str ) base_attrs [ PATH_ATTRIBUTE ] = layer_component . path base_attrs [ LAYER_TYPE_ATTRIBUTE ] = int ( layer_component . layer_type ) base_attrs [ USER_DEFINED_ATTRIBUTE ] = layer_component . user_defined return base_attrs model_component_to_dict model_component_to_dict ( model_component , uuid_to_str = True ) Creates a dictionary containing the base attribute name-value pairs from a model component object. Parameters: Name Type Description Default model_component BaseModelComponentType Source model component object whose values are to be mapped to the corresponding attribute names. required uuid_to_str bool Set True to convert the UUID to a string equivalent, else False. Some serialization engines such as JSON are unable to handle UUID objects hence the need to convert to string. True Returns: Type Description dict Returns a dictionary item containing attribute name-value pairs. Source code in src/cplus_plugin/models/helpers.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def model_component_to_dict ( model_component : BaseModelComponentType , uuid_to_str = True ) -> dict : \"\"\"Creates a dictionary containing the base attribute name-value pairs from a model component object. :param model_component: Source model component object whose values are to be mapped to the corresponding attribute names. :type model_component: BaseModelComponent :param uuid_to_str: Set True to convert the UUID to a string equivalent, else False. Some serialization engines such as JSON are unable to handle UUID objects hence the need to convert to string. :type uuid_to_str: bool :returns: Returns a dictionary item containing attribute name-value pairs. :rtype: dict \"\"\" model_uuid = model_component . uuid if uuid_to_str : model_uuid = str ( model_uuid ) return { UUID_ATTRIBUTE : model_uuid , NAME_ATTRIBUTE : model_component . name , DESCRIPTION_ATTRIBUTE : model_component . description , } ncs_pathway_to_dict ncs_pathway_to_dict ( ncs_pathway , uuid_to_str = True ) Creates a dictionary containing attribute name-value pairs from an NCS pathway object. This function has been retained for legacy support. Parameters: Name Type Description Default ncs_pathway NcsPathway Source NCS pathway object whose values are to be mapped to the corresponding attribute names. required uuid_to_str bool Set True to convert the UUID to a string equivalent, else False. Some serialization engines such as JSON are unable to handle UUID objects hence the need to convert to string. True Returns: Type Description dict Returns a dictionary item containing attribute name-value pairs. Source code in src/cplus_plugin/models/helpers.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 def ncs_pathway_to_dict ( ncs_pathway : NcsPathway , uuid_to_str = True ) -> dict : \"\"\"Creates a dictionary containing attribute name-value pairs from an NCS pathway object. This function has been retained for legacy support. :param ncs_pathway: Source NCS pathway object whose values are to be mapped to the corresponding attribute names. :type ncs_pathway: NcsPathway :param uuid_to_str: Set True to convert the UUID to a string equivalent, else False. Some serialization engines such as JSON are unable to handle UUID objects hence the need to convert to string. :type uuid_to_str: bool :returns: Returns a dictionary item containing attribute name-value pairs. :rtype: dict \"\"\" base_ncs_dict = layer_component_to_dict ( ncs_pathway , uuid_to_str ) base_ncs_dict [ CARBON_PATHS_ATTRIBUTE ] = ncs_pathway . carbon_paths base_ncs_dict [ CARBON_COEFFICIENT_ATTRIBUTE ] = ncs_pathway . carbon_coefficient return base_ncs_dict","title":"Helpers"},{"location":"developer/api/models/api_helpers/#helpers","text":"Helper functions for supporting model management.","title":"Helpers"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.clone_implementation_model","text":"clone_implementation_model ( implementation_model ) Creates a deep copy of the given implementation model. Parameters: Name Type Description Default implementation_model ImplementationModel Implementation model to clone. required Returns: Type Description ImplementationModel A deep copy of the original implementation model object. Source code in src/cplus_plugin/models/helpers.py 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 def clone_implementation_model ( implementation_model : ImplementationModel , ) -> ImplementationModel : \"\"\"Creates a deep copy of the given implementation model. :param implementation_model: Implementation model to clone. :type implementation_model: ImplementationModel :returns: A deep copy of the original implementation model object. :rtype: ImplementationModel \"\"\" imp_model = clone_layer_component ( implementation_model , ImplementationModel ) if imp_model is None : return None pathways = implementation_model . pathways cloned_pathways = [] for p in pathways : cloned_ncs = clone_ncs_pathway ( p ) if cloned_ncs is not None : cloned_pathways . append ( cloned_ncs ) imp_model . pathways = cloned_pathways return imp_model","title":"clone_implementation_model()"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.clone_layer_component","text":"clone_layer_component ( layer_component , model_cls ) Clones a layer-based model component. Parameters: Name Type Description Default layer_component LayerModelComponent Layer-based model component to clone. required model_cls Callable [[ UUID , str , str ], LayerModelComponentType ] Callable class that will be created based on the input argument values from the dictionary. required Returns: Type Description LayerModelComponent A new instance of the cloned model component. It will return None if the input is not a layer-based model component. Source code in src/cplus_plugin/models/helpers.py 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 def clone_layer_component ( layer_component : LayerModelComponent , model_cls : typing . Callable [[ uuid . UUID , str , str ], LayerModelComponentType ], ) -> typing . Union [ LayerModelComponent , None ]: \"\"\"Clones a layer-based model component. :param layer_component: Layer-based model component to clone. :type layer_component: LayerModelComponent :param model_cls: Callable class that will be created based on the input argument values from the dictionary. :type model_cls: LayerModelComponent :returns: A new instance of the cloned model component. It will return None if the input is not a layer-based model component. :rtype: LayerModelComponent \"\"\" if not isinstance ( layer_component , LayerModelComponent ): return None cloned_component = model_cls ( layer_component . uuid , layer_component . name , layer_component . description ) for f in fields ( layer_component ): attr_val = getattr ( layer_component , f . name ) setattr ( cloned_component , f . name , attr_val ) return cloned_component","title":"clone_layer_component()"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.clone_ncs_pathway","text":"clone_ncs_pathway ( ncs ) Creates a deep copy of the given NCS pathway. Parameters: Name Type Description Default ncs NcsPathway NCS pathway to clone. required Returns: Type Description NcsPathway A deep copy of the original NCS pathway object. Source code in src/cplus_plugin/models/helpers.py 278 279 280 281 282 283 284 285 286 287 def clone_ncs_pathway ( ncs : NcsPathway ) -> NcsPathway : \"\"\"Creates a deep copy of the given NCS pathway. :param ncs: NCS pathway to clone. :type ncs: NcsPathway :returns: A deep copy of the original NCS pathway object. :rtype: NcsPathway \"\"\" return clone_layer_component ( ncs , NcsPathway )","title":"clone_ncs_pathway()"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.copy_layer_component_attributes","text":"copy_layer_component_attributes ( target , source ) Copies the attribute values of source to target. The uuid attribute value is not copied as well as the layer attribute. However, for the latter, the path is copied. Parameters: Name Type Description Default target LayerModelComponent Target object whose attribute values will be updated. required source LayerModelComponent Source object whose attribute values will be copied to the target. required Returns: Type Description LayerModelComponent Target object containing the updated attribute values apart for the uuid whose value will not change. Source code in src/cplus_plugin/models/helpers.py 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 def copy_layer_component_attributes ( target : LayerModelComponent , source : LayerModelComponent ) -> LayerModelComponent : \"\"\"Copies the attribute values of source to target. The uuid attribute value is not copied as well as the layer attribute. However, for the latter, the path is copied. :param target: Target object whose attribute values will be updated. :type target: LayerModelComponent :param source: Source object whose attribute values will be copied to the target. :type source: LayerModelComponent :returns: Target object containing the updated attribute values apart for the uuid whose value will not change. :rtype: LayerModelComponent \"\"\" if not isinstance ( target , LayerModelComponent ) or not isinstance ( source , LayerModelComponent ): raise TypeError ( \"Source or target objects are not of type 'LayerModelComponent'\" ) for f in fields ( source ): # Exclude uuid if f . name == UUID_ATTRIBUTE : continue attr_val = getattr ( source , f . name ) setattr ( target , f . name , attr_val ) # Force layer to be set/updated target . update_layer_type () return target","title":"copy_layer_component_attributes()"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.create_implementation_model","text":"create_implementation_model ( source_dict ) Factory method for creating an implementation model using attribute values defined in a dictionary. Parameters: Name Type Description Default source_dict dict Dictionary containing property values. required Returns: Type Description ImplementationModel Implementation model with property values set from the dictionary. Source code in src/cplus_plugin/models/helpers.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 def create_implementation_model ( source_dict ) -> typing . Union [ ImplementationModel , None ]: \"\"\"Factory method for creating an implementation model using attribute values defined in a dictionary. :param source_dict: Dictionary containing property values. :type source_dict: dict :returns: Implementation model with property values set from the dictionary. :rtype: ImplementationModel \"\"\" implementation_model = create_layer_component ( source_dict , ImplementationModel ) if PRIORITY_LAYERS_SEGMENT in source_dict . keys (): implementation_model . priority_layers = source_dict [ PRIORITY_LAYERS_SEGMENT ] return implementation_model","title":"create_implementation_model()"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.create_layer_component","text":"create_layer_component ( source_dict , model_cls ) Factory method for creating a layer model component using attribute values defined in a dictionary. Parameters: Name Type Description Default source_dict dict Dictionary containing property values. required model_cls Callable [[ UUID , str , str , str , LayerType , bool ], LayerModelComponentType ] Callable class that will be created based on the input argument values from the dictionary. required Returns: Type Description LayerModelComponent Layer model component object with property values set from the dictionary. Source code in src/cplus_plugin/models/helpers.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def create_layer_component ( source_dict , model_cls : typing . Callable [ [ uuid . UUID , str , str , str , LayerType , bool ], LayerModelComponentType ], ) -> typing . Union [ LayerModelComponent , None ]: \"\"\"Factory method for creating a layer model component using attribute values defined in a dictionary. :param source_dict: Dictionary containing property values. :type source_dict: dict :param model_cls: Callable class that will be created based on the input argument values from the dictionary. :type model_cls: LayerModelComponent :returns: Layer model component object with property values set from the dictionary. :rtype: LayerModelComponent \"\"\" if UUID_ATTRIBUTE not in source_dict : return None source_uuid = source_dict [ UUID_ATTRIBUTE ] if isinstance ( source_uuid , str ): source_uuid = uuid . UUID ( source_uuid ) kwargs = {} if PATH_ATTRIBUTE in source_dict : kwargs [ PATH_ATTRIBUTE ] = source_dict [ PATH_ATTRIBUTE ] if LAYER_TYPE_ATTRIBUTE in source_dict : kwargs [ LAYER_TYPE_ATTRIBUTE ] = LayerType ( int ( source_dict [ LAYER_TYPE_ATTRIBUTE ])) if USER_DEFINED_ATTRIBUTE in source_dict : kwargs [ USER_DEFINED_ATTRIBUTE ] = bool ( source_dict [ USER_DEFINED_ATTRIBUTE ]) return model_cls ( source_uuid , source_dict [ NAME_ATTRIBUTE ], source_dict [ DESCRIPTION_ATTRIBUTE ], ** kwargs )","title":"create_layer_component()"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.create_model_component","text":"create_model_component ( source_dict , model_cls ) Factory method for creating and setting attribute values for a base model component object. Parameters: Name Type Description Default source_dict dict Dictionary containing attribute values. required model_cls Callable [[ UUID , str , str ], BaseModelComponentType ] Callable class that will be created based on the input argument values from the dictionary. required Returns: Type Description BaseModelComponent Base model component object with property values derived from the dictionary. Source code in src/cplus_plugin/models/helpers.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def create_model_component ( source_dict : dict , model_cls : typing . Callable [[ uuid . UUID , str , str ], BaseModelComponentType ], ) -> typing . Union [ BaseModelComponentType , None ]: \"\"\"Factory method for creating and setting attribute values for a base model component object. :param source_dict: Dictionary containing attribute values. :type source_dict: dict :param model_cls: Callable class that will be created based on the input argument values from the dictionary. :type model_cls: BaseModelComponent :returns: Base model component object with property values derived from the dictionary. :rtype: BaseModelComponent \"\"\" if not issubclass ( model_cls , BaseModelComponent ): return None return model_cls ( uuid . UUID ( source_dict [ UUID_ATTRIBUTE ]), source_dict [ NAME_ATTRIBUTE ], source_dict [ DESCRIPTION_ATTRIBUTE ], )","title":"create_model_component()"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.create_ncs_pathway","text":"create_ncs_pathway ( source_dict ) Factory method for creating an NcsPathway object using attribute values defined in a dictionary. Parameters: Name Type Description Default source_dict dict Dictionary containing property values. required Returns: Type Description NcsPathway NCS pathway object with property values set from the dictionary. Source code in src/cplus_plugin/models/helpers.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def create_ncs_pathway ( source_dict ) -> typing . Union [ NcsPathway , None ]: \"\"\"Factory method for creating an NcsPathway object using attribute values defined in a dictionary. :param source_dict: Dictionary containing property values. :type source_dict: dict :returns: NCS pathway object with property values set from the dictionary. :rtype: NcsPathway \"\"\" ncs = create_layer_component ( source_dict , NcsPathway ) # We are checking because of the various iterations of the attributes # in the NcsPathway class where some of these attributes might # be missing. if CARBON_PATHS_ATTRIBUTE in source_dict : ncs . carbon_paths = source_dict [ CARBON_PATHS_ATTRIBUTE ] carbon_coefficient_attr = CARBON_COEFFICIENT_ATTRIBUTE if carbon_coefficient_attr in source_dict : ncs . carbon_coefficient = source_dict [ CARBON_COEFFICIENT_ATTRIBUTE ] return ncs","title":"create_ncs_pathway()"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.extent_to_project_crs_extent","text":"extent_to_project_crs_extent ( spatial_extent , project = None ) Transforms SpatialExtent model to an QGIS extent based on the CRS of the given project. Parameters: Name Type Description Default spatial_extent SpatialExtent Spatial extent data model that defines the scenario bounds. required project QgsProject Project whose CRS will be used to determine the values of the output extent. None Returns: Type Description QgsRectangle Output extent in the project's CRS. If the input extent is invalid, this function will return None. Source code in src/cplus_plugin/models/helpers.py 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 def extent_to_project_crs_extent ( spatial_extent : SpatialExtent , project : QgsProject = None ) -> typing . Union [ QgsRectangle , None ]: \"\"\"Transforms SpatialExtent model to an QGIS extent based on the CRS of the given project. :param spatial_extent: Spatial extent data model that defines the scenario bounds. :type spatial_extent: SpatialExtent :param project: Project whose CRS will be used to determine the values of the output extent. :type project: QgsProject :returns: Output extent in the project's CRS. If the input extent is invalid, this function will return None. :rtype: QgsRectangle \"\"\" input_rect = extent_to_qgs_rectangle ( spatial_extent ) if input_rect is None : return None default_crs = QgsCoordinateReferenceSystem . fromEpsgId ( DEFAULT_CRS_ID ) if not default_crs . isValid (): return None if project is None : project = QgsProject . instance () target_crs = project . crs () if default_crs == target_crs : # No need for transformation return input_rect coordinate_xform = QgsCoordinateTransform ( default_crs , project . crs (), project ) return coordinate_xform . transformBoundingBox ( input_rect )","title":"extent_to_project_crs_extent()"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.extent_to_qgs_rectangle","text":"extent_to_qgs_rectangle ( spatial_extent ) Returns a QgsRectangle object from the SpatialExtent object. If the SpatialExtent is invalid (i.e. less than four items) then it will return None. Parameters: Name Type Description Default spatial_extent SpatialExtent Spatial extent data model that defines the scenario bounds. required Returns: Type Description QgsRectangle QGIS rectangle defining the bounds for the scenario. Source code in src/cplus_plugin/models/helpers.py 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 def extent_to_qgs_rectangle ( spatial_extent : SpatialExtent , ) -> typing . Union [ QgsRectangle , None ]: \"\"\"Returns a QgsRectangle object from the SpatialExtent object. If the SpatialExtent is invalid (i.e. less than four items) then it will return None. :param spatial_extent: Spatial extent data model that defines the scenario bounds. :type spatial_extent: SpatialExtent :returns: QGIS rectangle defining the bounds for the scenario. :rtype: QgsRectangle \"\"\" if len ( spatial_extent . bbox ) < 4 : return None return QgsRectangle ( spatial_extent . bbox [ 0 ], spatial_extent . bbox [ 2 ], spatial_extent . bbox [ 1 ], spatial_extent . bbox [ 3 ], )","title":"extent_to_qgs_rectangle()"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.layer_component_to_dict","text":"layer_component_to_dict ( layer_component , uuid_to_str = True ) Creates a dictionary containing attribute name-value pairs from a layer model component object. Parameters: Name Type Description Default layer_component LayerModelComponentType Source layer model component object whose values are to be mapped to the corresponding attribute names. required uuid_to_str bool Set True to convert the UUID to a string equivalent, else False. Some serialization engines such as JSON are unable to handle UUID objects hence the need to convert to string. True Returns: Type Description dict Returns a dictionary item containing attribute name-value pairs. Source code in src/cplus_plugin/models/helpers.py 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 def layer_component_to_dict ( layer_component : LayerModelComponentType , uuid_to_str = True ) -> dict : \"\"\"Creates a dictionary containing attribute name-value pairs from a layer model component object. :param layer_component: Source layer model component object whose values are to be mapped to the corresponding attribute names. :type layer_component: LayerModelComponent :param uuid_to_str: Set True to convert the UUID to a string equivalent, else False. Some serialization engines such as JSON are unable to handle UUID objects hence the need to convert to string. :type uuid_to_str: bool :returns: Returns a dictionary item containing attribute name-value pairs. :rtype: dict \"\"\" base_attrs = model_component_to_dict ( layer_component , uuid_to_str ) base_attrs [ PATH_ATTRIBUTE ] = layer_component . path base_attrs [ LAYER_TYPE_ATTRIBUTE ] = int ( layer_component . layer_type ) base_attrs [ USER_DEFINED_ATTRIBUTE ] = layer_component . user_defined return base_attrs","title":"layer_component_to_dict()"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.model_component_to_dict","text":"model_component_to_dict ( model_component , uuid_to_str = True ) Creates a dictionary containing the base attribute name-value pairs from a model component object. Parameters: Name Type Description Default model_component BaseModelComponentType Source model component object whose values are to be mapped to the corresponding attribute names. required uuid_to_str bool Set True to convert the UUID to a string equivalent, else False. Some serialization engines such as JSON are unable to handle UUID objects hence the need to convert to string. True Returns: Type Description dict Returns a dictionary item containing attribute name-value pairs. Source code in src/cplus_plugin/models/helpers.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def model_component_to_dict ( model_component : BaseModelComponentType , uuid_to_str = True ) -> dict : \"\"\"Creates a dictionary containing the base attribute name-value pairs from a model component object. :param model_component: Source model component object whose values are to be mapped to the corresponding attribute names. :type model_component: BaseModelComponent :param uuid_to_str: Set True to convert the UUID to a string equivalent, else False. Some serialization engines such as JSON are unable to handle UUID objects hence the need to convert to string. :type uuid_to_str: bool :returns: Returns a dictionary item containing attribute name-value pairs. :rtype: dict \"\"\" model_uuid = model_component . uuid if uuid_to_str : model_uuid = str ( model_uuid ) return { UUID_ATTRIBUTE : model_uuid , NAME_ATTRIBUTE : model_component . name , DESCRIPTION_ATTRIBUTE : model_component . description , }","title":"model_component_to_dict()"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.ncs_pathway_to_dict","text":"ncs_pathway_to_dict ( ncs_pathway , uuid_to_str = True ) Creates a dictionary containing attribute name-value pairs from an NCS pathway object. This function has been retained for legacy support. Parameters: Name Type Description Default ncs_pathway NcsPathway Source NCS pathway object whose values are to be mapped to the corresponding attribute names. required uuid_to_str bool Set True to convert the UUID to a string equivalent, else False. Some serialization engines such as JSON are unable to handle UUID objects hence the need to convert to string. True Returns: Type Description dict Returns a dictionary item containing attribute name-value pairs. Source code in src/cplus_plugin/models/helpers.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 def ncs_pathway_to_dict ( ncs_pathway : NcsPathway , uuid_to_str = True ) -> dict : \"\"\"Creates a dictionary containing attribute name-value pairs from an NCS pathway object. This function has been retained for legacy support. :param ncs_pathway: Source NCS pathway object whose values are to be mapped to the corresponding attribute names. :type ncs_pathway: NcsPathway :param uuid_to_str: Set True to convert the UUID to a string equivalent, else False. Some serialization engines such as JSON are unable to handle UUID objects hence the need to convert to string. :type uuid_to_str: bool :returns: Returns a dictionary item containing attribute name-value pairs. :rtype: dict \"\"\" base_ncs_dict = layer_component_to_dict ( ncs_pathway , uuid_to_str ) base_ncs_dict [ CARBON_PATHS_ATTRIBUTE ] = ncs_pathway . carbon_paths base_ncs_dict [ CARBON_COEFFICIENT_ATTRIBUTE ] = ncs_pathway . carbon_coefficient return base_ncs_dict","title":"ncs_pathway_to_dict()"},{"location":"developer/api/models/api_report/","text":"Report Data models for report production. ReportContext dataclass Context information for generating a report. ReportResult dataclass Detailed result information from a report generation run. pdf_path property pdf_path Returns the absolute path to the PDF file if the process completed successfully. Caller needs to verify if the file actually exists in the given location. :returns: Absolute path to the PDF file if the process completed successfully else an empty string. ReportSubmitStatus dataclass Result of report submission process.","title":"Report"},{"location":"developer/api/models/api_report/#report","text":"Data models for report production.","title":"Report"},{"location":"developer/api/models/api_report/#src.cplus_plugin.models.report.ReportContext","text":"Context information for generating a report.","title":"ReportContext"},{"location":"developer/api/models/api_report/#src.cplus_plugin.models.report.ReportResult","text":"Detailed result information from a report generation run.","title":"ReportResult"},{"location":"developer/api/models/api_report/#src.cplus_plugin.models.report.ReportResult.pdf_path","text":"pdf_path Returns the absolute path to the PDF file if the process completed successfully. Caller needs to verify if the file actually exists in the given location. :returns: Absolute path to the PDF file if the process completed successfully else an empty string.","title":"pdf_path"},{"location":"developer/api/models/api_report/#src.cplus_plugin.models.report.ReportSubmitStatus","text":"Result of report submission process.","title":"ReportSubmitStatus"},{"location":"developer/architecture/","text":"Architecture Frameworks used High-level system architecture Data model","title":"Architecture"},{"location":"developer/architecture/#architecture","text":"","title":"Architecture"},{"location":"developer/architecture/#frameworks-used","text":"","title":"Frameworks used"},{"location":"developer/architecture/#high-level-system-architecture","text":"","title":"High-level system architecture"},{"location":"developer/architecture/#data-model","text":"","title":"Data model"},{"location":"developer/documentation/","text":"Working with documentation Documentation is written using mkdocs . A detailed description on getting-started with mkdocs is available here . Developer documentation will be created and generated using mkdocstrings . Install mkdocs Open the terminal Run \"pip install mkdocs\" This should install mkdocs and all requirements Creating a new project This should not be required as the mkdocs has been created already, but serves more of a guide for a user whom are new to mkdocs. Open the terminal Run \"mkdocs new .\" This will generate the documents folder with the home page index markdown file Updating the mkdocs.yml file Mostly, the only changes a user will need to make is to the nav section in the mkdocs.yml file ( Figure 1 ). Other options, such as the themes, plugins and extensions, should require no changes. Figure 1: Navigation example of mkdocs Here is an explanation on how the nav should be updated: It is important to keep to the structure of the mkdocs Each section focusses on a particular aspect, for example User will provide information on installing the plugin, a guide on how to use the plugin, etc. The order in which the nav is structured will determine the tabs order on the site, as shown in Figure 2 Figure 2: Tabs in a generated site Each tab, or group, will then be structured as in Figure 3 Figure 3: Structure created by markdown headings The additional titles (in the Plugin guide section in the above example) is based on the headings provided in the guide markdown file ( cplus_ui_guide.md in this case) Headings for each section should be short, but descriptive The section itself can have a more detailed description Add screenshots where possible. This will make the guide(s) user-friendly mkdocstrings This is an important aspect of documenting code. Using mkdocstrings is an easy and effective way of keeping track of classes, functions, etc. Any changes to the code will automatically update here, but the developer needs to make the changes in the code (comments) for this to happen. The comments for mkdocstrings is three sections: Description: A description on what the function does. A destailed description are welcome param: List of parameters for the function. Type and description should be included returns: A list of values which the function would return. Type should be included, with a description Here is an example of the end-result: mkdocstrings options The user can also do fine-tuning of the resulting site. Here is a list of important options to be aware of: members, show_root_directory, show_source, and heading_level. heading_level : The header level of the content (functions, etc.) which will be added members : Only these function/classes will be shown show_root_directory : The root directory of the code Best will be to disable this, as it looks neater Here is an example of show_root_directory enabled, followed by an example when it is disabled: show_source : Shows the directory of the source code and a snippet of the code More information on this can be found here . Serving the pages locally This step is useful when making changes and the user wants to test and review their changes to the mkdocs before creating a pull request. Open the terminal Run \"mkdocs serve\" Figure 4 shows an example of the result Figure 4: Console example of serving mkdocs On default, mkdocs is served to localhost:8000. But if the port is already in use, the user needs to provide a port number Run \"mkdocs serve -a localhost:8001\". The user can use a port number of their choosing Open the URL in a browser: localhost:8000 The Home page should be similar to Figure 5 Figure 5: Site example. This is the Home page Errors When performing the serve, mkdocs will automatically check for any errors. An example will be when a file linked in the documentation cannot be found ( Figure 6 ). Figure 6: Missing file example when serving mkdocs Be sure to check for such errors in the console prior to creating a pull request for your documentation changes. GitHub pages This is only required if it has not been set up on GitHub for the repository, or if it has been disabled. Only a user with admin rights to the repository will be able to do this. Go to the repository and click on Settings Click on Pages Set the branch to \"gh-pages\" Click Save Select the action Select Deploy Open the Run mkdocs gh-deploy section The URL should be https://kartoza.github.io/cplus-plugin/","title":"Documentation"},{"location":"developer/documentation/#working-with-documentation","text":"Documentation is written using mkdocs . A detailed description on getting-started with mkdocs is available here . Developer documentation will be created and generated using mkdocstrings .","title":"Working with documentation"},{"location":"developer/documentation/#install-mkdocs","text":"Open the terminal Run \"pip install mkdocs\" This should install mkdocs and all requirements","title":"Install mkdocs"},{"location":"developer/documentation/#creating-a-new-project","text":"This should not be required as the mkdocs has been created already, but serves more of a guide for a user whom are new to mkdocs. Open the terminal Run \"mkdocs new .\" This will generate the documents folder with the home page index markdown file","title":"Creating a new project"},{"location":"developer/documentation/#updating-the-mkdocsyml-file","text":"Mostly, the only changes a user will need to make is to the nav section in the mkdocs.yml file ( Figure 1 ). Other options, such as the themes, plugins and extensions, should require no changes. Figure 1: Navigation example of mkdocs Here is an explanation on how the nav should be updated: It is important to keep to the structure of the mkdocs Each section focusses on a particular aspect, for example User will provide information on installing the plugin, a guide on how to use the plugin, etc. The order in which the nav is structured will determine the tabs order on the site, as shown in Figure 2 Figure 2: Tabs in a generated site Each tab, or group, will then be structured as in Figure 3 Figure 3: Structure created by markdown headings The additional titles (in the Plugin guide section in the above example) is based on the headings provided in the guide markdown file ( cplus_ui_guide.md in this case) Headings for each section should be short, but descriptive The section itself can have a more detailed description Add screenshots where possible. This will make the guide(s) user-friendly","title":"Updating the mkdocs.yml file"},{"location":"developer/documentation/#mkdocstrings","text":"This is an important aspect of documenting code. Using mkdocstrings is an easy and effective way of keeping track of classes, functions, etc. Any changes to the code will automatically update here, but the developer needs to make the changes in the code (comments) for this to happen. The comments for mkdocstrings is three sections: Description: A description on what the function does. A destailed description are welcome param: List of parameters for the function. Type and description should be included returns: A list of values which the function would return. Type should be included, with a description Here is an example of the end-result:","title":"mkdocstrings"},{"location":"developer/documentation/#mkdocstrings-options","text":"The user can also do fine-tuning of the resulting site. Here is a list of important options to be aware of: members, show_root_directory, show_source, and heading_level. heading_level : The header level of the content (functions, etc.) which will be added members : Only these function/classes will be shown show_root_directory : The root directory of the code Best will be to disable this, as it looks neater Here is an example of show_root_directory enabled, followed by an example when it is disabled: show_source : Shows the directory of the source code and a snippet of the code More information on this can be found here .","title":"mkdocstrings options"},{"location":"developer/documentation/#serving-the-pages-locally","text":"This step is useful when making changes and the user wants to test and review their changes to the mkdocs before creating a pull request. Open the terminal Run \"mkdocs serve\" Figure 4 shows an example of the result Figure 4: Console example of serving mkdocs On default, mkdocs is served to localhost:8000. But if the port is already in use, the user needs to provide a port number Run \"mkdocs serve -a localhost:8001\". The user can use a port number of their choosing Open the URL in a browser: localhost:8000 The Home page should be similar to Figure 5 Figure 5: Site example. This is the Home page","title":"Serving the pages locally"},{"location":"developer/documentation/#errors","text":"When performing the serve, mkdocs will automatically check for any errors. An example will be when a file linked in the documentation cannot be found ( Figure 6 ). Figure 6: Missing file example when serving mkdocs Be sure to check for such errors in the console prior to creating a pull request for your documentation changes.","title":"Errors"},{"location":"developer/documentation/#github-pages","text":"This is only required if it has not been set up on GitHub for the repository, or if it has been disabled. Only a user with admin rights to the repository will be able to do this. Go to the repository and click on Settings Click on Pages Set the branch to \"gh-pages\" Click Save Select the action Select Deploy Open the Run mkdocs gh-deploy section The URL should be https://kartoza.github.io/cplus-plugin/","title":"GitHub pages"},{"location":"developer/setup/","text":"Setup To use the plugin for development purposes, clone the repository locally, install pip, a python dependencies management tool see https://pypi.org/project/pip/ Create virtual environment Using any python virtual environment manager create project environment. Recommending to use virtualenv-wrapper . It can be installed using python pip pip install virtualenvwrapper Create virtual environment mkvirtualenv cplus Using the pip, install plugin development dependencies by running pip install -r requirements-dev.txt To install the plugin into the QGIS application, activate virtual environment and then use the below command python admin.py install","title":"Setup"},{"location":"developer/setup/#setup","text":"To use the plugin for development purposes, clone the repository locally, install pip, a python dependencies management tool see https://pypi.org/project/pip/","title":"Setup"},{"location":"developer/setup/#create-virtual-environment","text":"Using any python virtual environment manager create project environment. Recommending to use virtualenv-wrapper . It can be installed using python pip pip install virtualenvwrapper Create virtual environment mkvirtualenv cplus Using the pip, install plugin development dependencies by running pip install -r requirements-dev.txt To install the plugin into the QGIS application, activate virtual environment and then use the below command python admin.py install","title":"Create virtual environment"},{"location":"user/","text":"Users The following sections aims at guiding and helping a user on how to use the plugin. This is split into three sections: The quickstart tutorial shows how to install the plugin and help the user to get familiar with the platform. The user guide details common workflows in a tutorial format. The user manual describes the user interface and the various options of the plugin.","title":"Users"},{"location":"user/#users","text":"The following sections aims at guiding and helping a user on how to use the plugin. This is split into three sections: The quickstart tutorial shows how to install the plugin and help the user to get familiar with the platform. The user guide details common workflows in a tutorial format. The user manual describes the user interface and the various options of the plugin.","title":"Users"},{"location":"user/guide/","text":"Guide Perform analysis Figure 1 shows the toolbar button/menu for the plugin. Clicking on the icon will open the plugin. When a user clicks on the drop-down button, they will be presented with four options: CPLUS : Close or open the plugin dock widget Settings : Open the settings for the plugin Help : Takes the user to the online guide for the plugin About : Will take the user to the About section on the GH pages Figure 1: CPLUS toolbar icon Open the CPLUS dockwidget by clicking on the CPLUS toolbar icon ( Figure 1 ). Step 1: Scenario Information The first step focuses on the Scenario Information . A Scenario refers to an overall analysis done in an area of interest (AOI). Different criteria and priorities for spatial decision-making and comparison will be considered for each scenario. Scenario name : A name for the analysis to be performed Scenario description : A detailed description of the analysis Extent : The area of interest for this analysis. This can be calculated from the current canvas view extent, a layer, or an extent drawn by the user Figure 2 shows an example of Step 1 Once the information has been provided, click Step 2 Figure 2: Step 1 focusses on Scenario Information Step 2: Pathways and models This step deals with the Natural Climate Solution (NCS) pathways and the Implementation models (IM) . A NCS pathway can be defined as a composite spatial layer on specific land use classes and other factors that determine areas ideal for a specific use case (e.g. Animal mangement). An IM is a combination of NCS pathways represented in an AOI spatial layer. Figure 3 shows the UI. Figure 3: Step 2 allows the user to create and edit NCS pathways and Implementation Models Step 2 buttons ( Figure 4 ): Add : Adds a new pathway or model Editing : Edit and existing pathway or model Delete : Delete a pathway or model Figure 4: Create, delete, and edit buttons NCS Pathway Click on the left green plus button to add a new pathway ( Figure 5 ) Provide a Name and Description for the pathway Two approaches to select a layer: A layer from the QGIS canvas , or Upload from a file Click OK The new NCS pathway will be added NOTE: If the NCS pathway is broken (e.g. layer or file cannot be found), the pathway text will be highlighted in red. The user will need to rectify the issue before continuing to step 3. Figure 5: NCS Pathway creator/editor Implementation model Add pathways to an existing IM: Select the IM to which a pathway should be added Select the pathway you want to add to the IM Click the right arrow to add a pathway to the selected IM Click the double right arrow to add all pathways to the IM The user can also drag-and-drop a pathway onto the desired IM How to add a new IM: Click on the right green plus button to add an Implementation model ( Figure 6 ) Provide a Name and Description (optional) The user can provide an existing raster for the IM. Enable Map layer to do this Click OK The new Implementation model will be added Figure 6: Implementation Model creator/editor The final step is to select each of the IMs a user want to include in the scenario run A user can exclude IMs if they don't want to include it, even if the IM has pathways Figure 7: Selected Implementation models Before proceeding to Step 3, a user needs to define at least one NCS pathway layer for an implementation model else a warning message will be displayed as shown in Figure 7 below: Step 3: Priority weighting The final step deals with the Weighting priorities and Priority groups . These weights will be applied when the user starts running the scenario. An example is shown in Figure 11 . Figure 8: Step 3 allows the user to set the Weights of each Priority Group The priority weighting layers can be selected and added and removed into each priority group by using the arrow buttons. Add priority layers Select the target layer from the priority weighting layers list and the destination group from the priority groups and use the left arrow button to add the layer into the group. Remove priority layers Select the target layer from the priority weighting layers list from its priority group and use the right arrow button to remove the layer into the group. Create custom priority layers Click on to add a new custom priority layer, or to edit an existing priority layer This will open the Priority Layer dialog (see Figure 9 ) The following parameters needs to be set: Priority layer : The layer which represents the priority layer Priority layer name : A unique identifier for the priority layer Priority layer description : A detailed description of the priority layer Click the Assign implementation models button to select IMs to be associated with the priority layer (see Figure 10 ) Figure 9: Priority layer dialog Select the IMs you want to be associated with the priority layer Click OK Figure 10: Implementation model selection for priority layers : Remove the selected PWL Setting groups values Move the slider to adjust the weight of each group, values can also be set manually, by using the left input spin box. Once done selecting weights, click Run Scenario button to run the analysis. Steps 1 to 3 example The following recording ( Figure 11 ) shows an example on how to do Step 1, 2 and 3. Figure 11: Shows how to implement Step 1, 2 and 3 in QGIS Processing Once the user has provided all desired parameters, click Run Scenario The processing dialog will open ( Figure 12 ) The processing will take a while, depending on the number of IMs and pathways provided for each IM Click the Cancel button to stop the processing Figure 12: Processing dialog while the algorithm is running Figure 13 will be the result if the processing succceeded The user should take note that the View Report button is now available Figure 13: Processing dialog if successfull Processing results The following groups and layers will be added to the QGIS canvas once the processing finishes (see Figure 14 ): - A group containing the results - Implementation Model Maps : Non-weighted IMs created by the user in Step 2 - Weighted Implementation Model Maps : Weighted IMs based on the IMs added in Step 2 and weighing set in Step 3 - NCS Pathways Maps : Pathways used for each IM in Step 2. If a layer were provided as the IM in Step 2, this will contain no pathways Figure 14: Groups and layers added to the QGIS canvas An example of output results in QGIS is detailed by Figure 15 Figure 15: A recording example of an example scenario Report generating Click the View Report button The user will have the following options: Layout designer : Open PDF : Help : Open the help documentation related to the reports Figure 16: Report options Figure 17 shows an example of a report opened in the layout designer Figure 17: Report opened in the QGIS layout designer Figure 18 shows an report in PDF format Figure 18: PDF version of a report Generated report example Here is an example on how to open a report in the QGIS layout designer, or as a PDF ( Figure 19 ). Figure 19: Example of a generated report in PDF and layout designer formats Settings Open CPLUS settings The user can follow two approaches to open the CPLUS settings. QGIS options ( Figure 20 ): Click on Settings -> Options Figure 20: QGIS settings Select the CPLUS tab to the left This will open the CPLUS settings dialog. See Figure 21 for an example Figure 21: CPLUS section as loaded in the QGIS settings dialog CPLUS toolbar ( Figure 22 ): - Click on the CPLUS toolbar drop-down - Select Settings - This will take you directly to the CPLUS settings dialog in the QGIS options Figure 22: CPLUS toolbar button CPLUS settings A short description of each available setting a user can change. Most are optional. Configure Analysis : Settings will be added as the plugin development continues Reports : Information which will be included when a report is generated. These settings are optional, and will be excluded from the report if not provided Organization : The organization(s) to be included in the report Contact Email : Contact email for the author Website : A website link to the project or company Custom logo : Enable and provide a custom logo of your choosing. If disabled, the CI logo will be used in the report Footer : Footer section for the report Disclaimer : A disclaimer to be added to the report License : A license to be added to the report Advanced : Base data directory (required): Data accessed and download by the plugin will be stored here Coefficient for carbon layers : Value applied during processing to the carbon-based layers. Default is 0 Figure 23 shows an example of updating and applying CPLUS settings. Figure 23: CPLUS settings example","title":"Guide"},{"location":"user/guide/#guide","text":"","title":"Guide"},{"location":"user/guide/#perform-analysis","text":"Figure 1 shows the toolbar button/menu for the plugin. Clicking on the icon will open the plugin. When a user clicks on the drop-down button, they will be presented with four options: CPLUS : Close or open the plugin dock widget Settings : Open the settings for the plugin Help : Takes the user to the online guide for the plugin About : Will take the user to the About section on the GH pages Figure 1: CPLUS toolbar icon Open the CPLUS dockwidget by clicking on the CPLUS toolbar icon ( Figure 1 ).","title":"Perform analysis"},{"location":"user/guide/#step-1-scenario-information","text":"The first step focuses on the Scenario Information . A Scenario refers to an overall analysis done in an area of interest (AOI). Different criteria and priorities for spatial decision-making and comparison will be considered for each scenario. Scenario name : A name for the analysis to be performed Scenario description : A detailed description of the analysis Extent : The area of interest for this analysis. This can be calculated from the current canvas view extent, a layer, or an extent drawn by the user Figure 2 shows an example of Step 1 Once the information has been provided, click Step 2 Figure 2: Step 1 focusses on Scenario Information","title":"Step 1: Scenario Information"},{"location":"user/guide/#step-2-pathways-and-models","text":"This step deals with the Natural Climate Solution (NCS) pathways and the Implementation models (IM) . A NCS pathway can be defined as a composite spatial layer on specific land use classes and other factors that determine areas ideal for a specific use case (e.g. Animal mangement). An IM is a combination of NCS pathways represented in an AOI spatial layer. Figure 3 shows the UI. Figure 3: Step 2 allows the user to create and edit NCS pathways and Implementation Models Step 2 buttons ( Figure 4 ): Add : Adds a new pathway or model Editing : Edit and existing pathway or model Delete : Delete a pathway or model Figure 4: Create, delete, and edit buttons","title":"Step 2: Pathways and models"},{"location":"user/guide/#ncs-pathway","text":"Click on the left green plus button to add a new pathway ( Figure 5 ) Provide a Name and Description for the pathway Two approaches to select a layer: A layer from the QGIS canvas , or Upload from a file Click OK The new NCS pathway will be added NOTE: If the NCS pathway is broken (e.g. layer or file cannot be found), the pathway text will be highlighted in red. The user will need to rectify the issue before continuing to step 3. Figure 5: NCS Pathway creator/editor","title":"NCS Pathway"},{"location":"user/guide/#implementation-model","text":"Add pathways to an existing IM: Select the IM to which a pathway should be added Select the pathway you want to add to the IM Click the right arrow to add a pathway to the selected IM Click the double right arrow to add all pathways to the IM The user can also drag-and-drop a pathway onto the desired IM How to add a new IM: Click on the right green plus button to add an Implementation model ( Figure 6 ) Provide a Name and Description (optional) The user can provide an existing raster for the IM. Enable Map layer to do this Click OK The new Implementation model will be added Figure 6: Implementation Model creator/editor The final step is to select each of the IMs a user want to include in the scenario run A user can exclude IMs if they don't want to include it, even if the IM has pathways Figure 7: Selected Implementation models Before proceeding to Step 3, a user needs to define at least one NCS pathway layer for an implementation model else a warning message will be displayed as shown in Figure 7 below:","title":"Implementation model"},{"location":"user/guide/#step-3-priority-weighting","text":"The final step deals with the Weighting priorities and Priority groups . These weights will be applied when the user starts running the scenario. An example is shown in Figure 11 . Figure 8: Step 3 allows the user to set the Weights of each Priority Group The priority weighting layers can be selected and added and removed into each priority group by using the arrow buttons.","title":"Step 3: Priority weighting"},{"location":"user/guide/#add-priority-layers","text":"Select the target layer from the priority weighting layers list and the destination group from the priority groups and use the left arrow button to add the layer into the group.","title":"Add priority layers"},{"location":"user/guide/#remove-priority-layers","text":"Select the target layer from the priority weighting layers list from its priority group and use the right arrow button to remove the layer into the group.","title":"Remove priority layers"},{"location":"user/guide/#create-custom-priority-layers","text":"Click on to add a new custom priority layer, or to edit an existing priority layer This will open the Priority Layer dialog (see Figure 9 ) The following parameters needs to be set: Priority layer : The layer which represents the priority layer Priority layer name : A unique identifier for the priority layer Priority layer description : A detailed description of the priority layer Click the Assign implementation models button to select IMs to be associated with the priority layer (see Figure 10 ) Figure 9: Priority layer dialog Select the IMs you want to be associated with the priority layer Click OK Figure 10: Implementation model selection for priority layers : Remove the selected PWL","title":"Create custom priority layers"},{"location":"user/guide/#setting-groups-values","text":"Move the slider to adjust the weight of each group, values can also be set manually, by using the left input spin box. Once done selecting weights, click Run Scenario button to run the analysis.","title":"Setting groups values"},{"location":"user/guide/#steps-1-to-3-example","text":"The following recording ( Figure 11 ) shows an example on how to do Step 1, 2 and 3. Figure 11: Shows how to implement Step 1, 2 and 3 in QGIS","title":"Steps 1 to 3 example"},{"location":"user/guide/#processing","text":"Once the user has provided all desired parameters, click Run Scenario The processing dialog will open ( Figure 12 ) The processing will take a while, depending on the number of IMs and pathways provided for each IM Click the Cancel button to stop the processing Figure 12: Processing dialog while the algorithm is running Figure 13 will be the result if the processing succceeded The user should take note that the View Report button is now available Figure 13: Processing dialog if successfull","title":"Processing"},{"location":"user/guide/#processing-results","text":"The following groups and layers will be added to the QGIS canvas once the processing finishes (see Figure 14 ): - A group containing the results - Implementation Model Maps : Non-weighted IMs created by the user in Step 2 - Weighted Implementation Model Maps : Weighted IMs based on the IMs added in Step 2 and weighing set in Step 3 - NCS Pathways Maps : Pathways used for each IM in Step 2. If a layer were provided as the IM in Step 2, this will contain no pathways Figure 14: Groups and layers added to the QGIS canvas An example of output results in QGIS is detailed by Figure 15 Figure 15: A recording example of an example scenario","title":"Processing results"},{"location":"user/guide/#report-generating","text":"Click the View Report button The user will have the following options: Layout designer : Open PDF : Help : Open the help documentation related to the reports Figure 16: Report options Figure 17 shows an example of a report opened in the layout designer Figure 17: Report opened in the QGIS layout designer Figure 18 shows an report in PDF format Figure 18: PDF version of a report","title":"Report generating"},{"location":"user/guide/#generated-report-example","text":"Here is an example on how to open a report in the QGIS layout designer, or as a PDF ( Figure 19 ). Figure 19: Example of a generated report in PDF and layout designer formats","title":"Generated report example"},{"location":"user/guide/#settings","text":"","title":"Settings"},{"location":"user/guide/#open-cplus-settings","text":"The user can follow two approaches to open the CPLUS settings. QGIS options ( Figure 20 ): Click on Settings -> Options Figure 20: QGIS settings Select the CPLUS tab to the left This will open the CPLUS settings dialog. See Figure 21 for an example Figure 21: CPLUS section as loaded in the QGIS settings dialog CPLUS toolbar ( Figure 22 ): - Click on the CPLUS toolbar drop-down - Select Settings - This will take you directly to the CPLUS settings dialog in the QGIS options Figure 22: CPLUS toolbar button","title":"Open CPLUS settings"},{"location":"user/guide/#cplus-settings","text":"A short description of each available setting a user can change. Most are optional. Configure Analysis : Settings will be added as the plugin development continues Reports : Information which will be included when a report is generated. These settings are optional, and will be excluded from the report if not provided Organization : The organization(s) to be included in the report Contact Email : Contact email for the author Website : A website link to the project or company Custom logo : Enable and provide a custom logo of your choosing. If disabled, the CI logo will be used in the report Footer : Footer section for the report Disclaimer : A disclaimer to be added to the report License : A license to be added to the report Advanced : Base data directory (required): Data accessed and download by the plugin will be stored here Coefficient for carbon layers : Value applied during processing to the carbon-based layers. Default is 0 Figure 23 shows an example of updating and applying CPLUS settings. Figure 23: CPLUS settings example","title":"CPLUS settings"},{"location":"user/manual/","text":"Manual Detailed descriptions for each UI element of the plugin. This covers steps 1 to 3, dialogs, and the settings UI. Dock widget This is the main UI of the plugin. The dock widget opens on the right side of QGIS. The dock widget consist of three tabs, each focussing on a particular phase of the analyis. Here is a short description of those steps: Step 1 : Scenario information Step 2 : NCS pathways and Implementation models Step 3 : Weighting priorities Step 1: Scenario information Figure 1: Step 1 of the dock widget Step 1 allows a user to set up the scenario details and parameters. Scenario name : This title will be used throughout the processing, will be used for the groups added to the QGIS canvas, and in the generated report Scenario description : A detailed description of the scenario the user will be running. This information will be added to the final report Extent : The area of interest (AOI) for analysis. Any spatial data outside this region will be ignored Map Canvas Extent : The AOI will be the current extent the user has in QGIS Draw on Canvas : Allows the user to manually draw the AOI Zoom to Pilot Area : Zooms to the Bushbuckridge pilot study area Step 2: NCS pathways and Implementation models Step 2 focuses on the implementation models (IMs) and pathways. Figure 2: Step 2 of the dock widget NCS pathways : Pathways which can be added to IMs. Multiple pathways can be added to each IM Implementation models : Each selected model will be created in used to perform the analysis Description : A description of the IM or pathway selected : Add the selected pathway to the selected IM : Adds all pathways to the selected IM : Add a new IM : Remove the selected IM or pathway : Edit the selected IM Implementation Model Editor dialog Figure 3: Implementation model editing/adding dialog Name : The name of the new IM or IM being edited. IM title will be used in the report Description : A detailed description of the IM. This will be used in the report Map layer : If enabled, a user can provide an existing IM. This has to be a raster Step 3: Weighting priorities Figure 4: Step 3 of the dock widget Priority groups : Groups to which PWLs can be assigned Priority weighted layers (PWL) : : Remove the selected PWL from the priority group : Add the selected PWL to the selected priority group : Add a new PWL : Remove the selected PWL : Edit the selected PWL Run Scenario : Starts running the analysis. The progress dialog will open when the user clicks this button Priority Weighted Layers Editor dialog Figure 5: Priority layer dialog Priority layer : Select the priority layer Priority layer name : A unique name for the priority layer Priority layer description : A detailed description for the priority layer Assign implementation models : Selected IMs associated with the priority layer Figure 6: Selection of IMs for a custom priority layer List of IMs a user can select. Multiple IMs can be selected OK : Save the selected models Select All : Selects each of the available IMs Clear Selection : Deselects each of the selected IMs Toggle Selection : Switches each option from deselected to selected, or selected to deselected Progress dialog Figure 7: Processing dialog which will show the status of the analysis Analysis Progress : Progress of the current step Status : A status message on the current analysis being performed View Report : This button will remain disabled until the processing is done Cancel : Clicking this button will stop the processing Close : Only visible once the processing stops. Will close the progress dialog Report options These options will be available once the analysis has finished. The options will stay disabled if the analysis failed Figure 8: Options available to the user related to the generated report Layout designer : Opens the report in the QGIS layout designer Open PDF : Opens the created PDF Help : Takes the user to the Users documentation site Settings Figure 9: Settings available to the user Reports : Information to be added to the report Organization : (optional) Organization or institute name Contact email : (optional) Contact email of the user Website : (optional) Link to website of your company or institute Custom logo : (optional) If enabled, the user needs to provide a custom logo. Most formats should suffice (png, jpeg, etc.) Logo preview : Visual previre of the default CI logo, or the custom logo a user selected Footer : (optional) Will be added to the report Disclaimer : Change as desired, otherwise use the default disclaimer License : Change as desired, otherwise use the default license description Advanced : Base data directory : Directory to read data from, and to which results will be written Coefficient for carbon layers : Applied to carbon layers during processing OK : Apply and save settings Cancel : Any changes to the settings will not be saved","title":"Manual"},{"location":"user/manual/#manual","text":"Detailed descriptions for each UI element of the plugin. This covers steps 1 to 3, dialogs, and the settings UI.","title":"Manual"},{"location":"user/manual/#dock-widget","text":"This is the main UI of the plugin. The dock widget opens on the right side of QGIS. The dock widget consist of three tabs, each focussing on a particular phase of the analyis. Here is a short description of those steps: Step 1 : Scenario information Step 2 : NCS pathways and Implementation models Step 3 : Weighting priorities","title":"Dock widget"},{"location":"user/manual/#step-1-scenario-information","text":"Figure 1: Step 1 of the dock widget Step 1 allows a user to set up the scenario details and parameters. Scenario name : This title will be used throughout the processing, will be used for the groups added to the QGIS canvas, and in the generated report Scenario description : A detailed description of the scenario the user will be running. This information will be added to the final report Extent : The area of interest (AOI) for analysis. Any spatial data outside this region will be ignored Map Canvas Extent : The AOI will be the current extent the user has in QGIS Draw on Canvas : Allows the user to manually draw the AOI Zoom to Pilot Area : Zooms to the Bushbuckridge pilot study area","title":"Step 1: Scenario information"},{"location":"user/manual/#step-2-ncs-pathways-and-implementation-models","text":"Step 2 focuses on the implementation models (IMs) and pathways. Figure 2: Step 2 of the dock widget NCS pathways : Pathways which can be added to IMs. Multiple pathways can be added to each IM Implementation models : Each selected model will be created in used to perform the analysis Description : A description of the IM or pathway selected : Add the selected pathway to the selected IM : Adds all pathways to the selected IM : Add a new IM : Remove the selected IM or pathway : Edit the selected IM","title":"Step 2: NCS pathways and Implementation models"},{"location":"user/manual/#implementation-model-editor-dialog","text":"Figure 3: Implementation model editing/adding dialog Name : The name of the new IM or IM being edited. IM title will be used in the report Description : A detailed description of the IM. This will be used in the report Map layer : If enabled, a user can provide an existing IM. This has to be a raster","title":"Implementation Model Editor dialog"},{"location":"user/manual/#step-3-weighting-priorities","text":"Figure 4: Step 3 of the dock widget Priority groups : Groups to which PWLs can be assigned Priority weighted layers (PWL) : : Remove the selected PWL from the priority group : Add the selected PWL to the selected priority group : Add a new PWL : Remove the selected PWL : Edit the selected PWL Run Scenario : Starts running the analysis. The progress dialog will open when the user clicks this button","title":"Step 3: Weighting priorities"},{"location":"user/manual/#priority-weighted-layers-editor-dialog","text":"Figure 5: Priority layer dialog Priority layer : Select the priority layer Priority layer name : A unique name for the priority layer Priority layer description : A detailed description for the priority layer Assign implementation models : Selected IMs associated with the priority layer Figure 6: Selection of IMs for a custom priority layer List of IMs a user can select. Multiple IMs can be selected OK : Save the selected models Select All : Selects each of the available IMs Clear Selection : Deselects each of the selected IMs Toggle Selection : Switches each option from deselected to selected, or selected to deselected","title":"Priority Weighted Layers Editor dialog"},{"location":"user/manual/#progress-dialog","text":"Figure 7: Processing dialog which will show the status of the analysis Analysis Progress : Progress of the current step Status : A status message on the current analysis being performed View Report : This button will remain disabled until the processing is done Cancel : Clicking this button will stop the processing Close : Only visible once the processing stops. Will close the progress dialog","title":"Progress dialog"},{"location":"user/manual/#report-options","text":"These options will be available once the analysis has finished. The options will stay disabled if the analysis failed Figure 8: Options available to the user related to the generated report Layout designer : Opens the report in the QGIS layout designer Open PDF : Opens the created PDF Help : Takes the user to the Users documentation site","title":"Report options"},{"location":"user/manual/#settings","text":"Figure 9: Settings available to the user Reports : Information to be added to the report Organization : (optional) Organization or institute name Contact email : (optional) Contact email of the user Website : (optional) Link to website of your company or institute Custom logo : (optional) If enabled, the user needs to provide a custom logo. Most formats should suffice (png, jpeg, etc.) Logo preview : Visual previre of the default CI logo, or the custom logo a user selected Footer : (optional) Will be added to the report Disclaimer : Change as desired, otherwise use the default disclaimer License : Change as desired, otherwise use the default license description Advanced : Base data directory : Directory to read data from, and to which results will be written Coefficient for carbon layers : Applied to carbon layers during processing OK : Apply and save settings Cancel : Any changes to the settings will not be saved","title":"Settings"},{"location":"user/quickstart/","text":"Quick start Installation Plugin repository During the development phase the plugin is available to install via a dedicated plugin repository https://raw.githubusercontent.com/kartoza/cplus-plugin/release/docs/repository/plugins.xml Install from QGIS plugin repository Open QGIS application and open plugin manager. Click on Plugins -> Manage and Install Plugins (see Figure 1 ) Figure 1: QGIS plugin manager Search for CPLUS in the All page of the plugin manager. From the found results, click on the CPLUS result item and a page with plugin information will show up. Click the Install Plugin button at the bottom of the dialog to install the plugin. Install from ZIP file Alternatively the plugin can be installed using Install from ZIP option on the QGIS plugin manager. Download zip file from the required plugin released version https://github.com/kartoza/cplus-plugin/releases/download/{tagname}/cplus.{version}.zip Open QGIS application and open plugin manager Click on Plugins -> Manage and Install Plugins Click on Install from ZIP ( Figure 2 ) Select the zip file which contains the plugin Click Install Plugin Figure 2: Plugin manager install from zip option From the Install from ZIP page, select the zip file and click the Install button to install plugin Install from custom plugin repository Current repository: https://raw.githubusercontent.com/kartoza/cplus-plugin/release/docs/repository/plugins.xml Open the QGIS plugin manager, then select the Settings page ( Figure 3 ) NOTE: The plugin is currently in experimental phase, so enable Show also Experimental Plugins Figure 3: Custom repository installation Click Add button on the Plugin Repositories group box and use the above url to create the new plugin repository. The plugin should now be available from the list of all plugins that can be installed. Disable QGIS official plugin repository in order to not fetch plugins from it. NOTE: While the development phase is on going the plugin will be flagged as experimental, make sure to enable the QGIS plugin manager in the Settings page to show the experimental plugins in order to be able to install it. When the development work is complete the plugin will be available on the QGIS official plugin repository. Short tutorial Short example ( Figure 4 ) on how to set parameters in step 1, implementation models in step 2, and weighing in step 3. For a more detailed instructions on how to use the plugin, see the guide and the manual . Figure 4: Quick guide on how to use the plugin","title":"Quick Start"},{"location":"user/quickstart/#quick-start","text":"","title":"Quick start"},{"location":"user/quickstart/#installation","text":"","title":"Installation"},{"location":"user/quickstart/#plugin-repository","text":"During the development phase the plugin is available to install via a dedicated plugin repository https://raw.githubusercontent.com/kartoza/cplus-plugin/release/docs/repository/plugins.xml","title":"Plugin repository"},{"location":"user/quickstart/#install-from-qgis-plugin-repository","text":"Open QGIS application and open plugin manager. Click on Plugins -> Manage and Install Plugins (see Figure 1 ) Figure 1: QGIS plugin manager Search for CPLUS in the All page of the plugin manager. From the found results, click on the CPLUS result item and a page with plugin information will show up. Click the Install Plugin button at the bottom of the dialog to install the plugin.","title":"Install from QGIS plugin repository"},{"location":"user/quickstart/#install-from-zip-file","text":"Alternatively the plugin can be installed using Install from ZIP option on the QGIS plugin manager. Download zip file from the required plugin released version https://github.com/kartoza/cplus-plugin/releases/download/{tagname}/cplus.{version}.zip Open QGIS application and open plugin manager Click on Plugins -> Manage and Install Plugins Click on Install from ZIP ( Figure 2 ) Select the zip file which contains the plugin Click Install Plugin Figure 2: Plugin manager install from zip option From the Install from ZIP page, select the zip file and click the Install button to install plugin","title":"Install from ZIP file"},{"location":"user/quickstart/#install-from-custom-plugin-repository","text":"Current repository: https://raw.githubusercontent.com/kartoza/cplus-plugin/release/docs/repository/plugins.xml Open the QGIS plugin manager, then select the Settings page ( Figure 3 ) NOTE: The plugin is currently in experimental phase, so enable Show also Experimental Plugins Figure 3: Custom repository installation Click Add button on the Plugin Repositories group box and use the above url to create the new plugin repository. The plugin should now be available from the list of all plugins that can be installed. Disable QGIS official plugin repository in order to not fetch plugins from it. NOTE: While the development phase is on going the plugin will be flagged as experimental, make sure to enable the QGIS plugin manager in the Settings page to show the experimental plugins in order to be able to install it. When the development work is complete the plugin will be available on the QGIS official plugin repository.","title":"Install from custom plugin repository"},{"location":"user/quickstart/#short-tutorial","text":"Short example ( Figure 4 ) on how to set parameters in step 1, implementation models in step 2, and weighing in step 3. For a more detailed instructions on how to use the plugin, see the guide and the manual . Figure 4: Quick guide on how to use the plugin","title":"Short tutorial"}]}